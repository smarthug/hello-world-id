var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b2) => (typeof require !== "undefined" ? require : a)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});

// .wrangler/tmp/bundle-nu0i5Q/checked-fetch.js
var urls = /* @__PURE__ */ new Set();
function checkURL(request, init2) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init2) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
__name(checkURL, "checkURL");
globalThis.fetch = new Proxy(globalThis.fetch, {
  apply(target, thisArg, argArray) {
    const [request, init2] = argArray;
    checkURL(request, init2);
    return Reflect.apply(target, thisArg, argArray);
  }
});

// .wrangler/tmp/pages-hrbx3s/functionsWorker-0.05453709306899546.mjs
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
var __require2 = /* @__PURE__ */ ((x2) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof __require !== "undefined" ? __require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof __require !== "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = /* @__PURE__ */ __name((fn, res) => /* @__PURE__ */ __name(function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
}, "__init"), "__esm");
var __commonJS = /* @__PURE__ */ __name((cb, mod2) => /* @__PURE__ */ __name(function __require22() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
}, "__require2"), "__commonJS");
var __export = /* @__PURE__ */ __name((target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
}, "__export");
var __copyProps = /* @__PURE__ */ __name((to3, from27, except, desc) => {
  if (from27 && typeof from27 === "object" || typeof from27 === "function") {
    for (let key of __getOwnPropNames(from27))
      if (!__hasOwnProp.call(to3, key) && key !== except)
        __defProp2(to3, key, { get: () => from27[key], enumerable: !(desc = __getOwnPropDesc(from27, key)) || desc.enumerable });
  }
  return to3;
}, "__copyProps");
var __toESM = /* @__PURE__ */ __name((mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
)), "__toESM");
function checkURL2(request, init2) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init2) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls2.has(url.toString())) {
      urls2.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
__name(checkURL2, "checkURL");
var urls2;
var init_checked_fetch = __esm({
  "../.wrangler/tmp/bundle-6kz7g5/checked-fetch.js"() {
    urls2 = /* @__PURE__ */ new Set();
    __name2(checkURL2, "checkURL");
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init2] = argArray;
        checkURL2(request, init2);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA of keysA) {
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
      return false;
    }
  }
  return true;
}
__name(shallow$1, "shallow$1");
var init_shallow = __esm({
  "../node_modules/zustand/esm/shallow.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(shallow$1, "shallow$1");
  }
});
var require_react_development = __commonJS({
  "../node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    (function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component3.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      __name(defineDeprecationWarning, "defineDeprecationWarning");
      __name2(defineDeprecationWarning, "defineDeprecationWarning");
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      __name(getIteratorFn, "getIteratorFn");
      __name2(getIteratorFn, "getIteratorFn");
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      __name(warnNoop, "warnNoop");
      __name2(warnNoop, "warnNoop");
      function Component3(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      __name(Component3, "Component3");
      __name2(Component3, "Component");
      function ComponentDummy() {
      }
      __name(ComponentDummy, "ComponentDummy");
      __name2(ComponentDummy, "ComponentDummy");
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      __name(PureComponent, "PureComponent");
      __name2(PureComponent, "PureComponent");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      __name2(testStringCoercion, "testStringCoercion");
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      __name(checkKeyStringCoercion, "checkKeyStringCoercion");
      __name2(checkKeyStringCoercion, "checkKeyStringCoercion");
      function getComponentNameFromType(type6) {
        if (null == type6)
          return null;
        if ("function" === typeof type6)
          return type6.$$typeof === REACT_CLIENT_REFERENCE ? null : type6.displayName || type6.name || null;
        if ("string" === typeof type6)
          return type6;
        switch (type6) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type6)
          switch ("number" === typeof type6.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type6.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type6.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type6._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type6.render;
              type6 = type6.displayName;
              type6 || (type6 = innerType.displayName || innerType.name || "", type6 = "" !== type6 ? "ForwardRef(" + type6 + ")" : "ForwardRef");
              return type6;
            case REACT_MEMO_TYPE:
              return innerType = type6.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type6.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type6._payload;
              type6 = type6._init;
              try {
                return getComponentNameFromType(type6(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      __name2(getComponentNameFromType, "getComponentNameFromType");
      function getTaskName(type6) {
        if (type6 === REACT_FRAGMENT_TYPE)
          return "<>";
        if ("object" === typeof type6 && null !== type6 && type6.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type6);
          return name ? "<" + name + ">" : "<...>";
        } catch (x2) {
          return "<...>";
        }
      }
      __name(getTaskName, "getTaskName");
      __name2(getTaskName, "getTaskName");
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      __name(getOwner, "getOwner");
      __name2(getOwner, "getOwner");
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      __name(UnknownOwner, "UnknownOwner");
      __name2(UnknownOwner, "UnknownOwner");
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning)
            return false;
        }
        return void 0 !== config.key;
      }
      __name(hasValidKey, "hasValidKey");
      __name2(hasValidKey, "hasValidKey");
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        __name(warnAboutAccessingKey, "warnAboutAccessingKey");
        __name2(warnAboutAccessingKey, "warnAboutAccessingKey");
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      __name(defineKeyPropWarningGetter, "defineKeyPropWarningGetter");
      __name2(defineKeyPropWarningGetter, "defineKeyPropWarningGetter");
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      __name(elementRefGetterWithDeprecationWarning, "elementRefGetterWithDeprecationWarning");
      __name2(elementRefGetterWithDeprecationWarning, "elementRefGetterWithDeprecationWarning");
      function ReactElement(type6, key, self2, source, owner, props, debugStack, debugTask) {
        self2 = props.ref;
        type6 = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type6,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type6, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type6, "ref", { enumerable: false, value: null });
        type6._store = {};
        Object.defineProperty(type6._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type6, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type6, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type6, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type6.props), Object.freeze(type6));
        return type6;
      }
      __name(ReactElement, "ReactElement");
      __name2(ReactElement, "ReactElement");
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          oldElement._owner,
          oldElement.props,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      __name(cloneAndReplaceKey, "cloneAndReplaceKey");
      __name2(cloneAndReplaceKey, "cloneAndReplaceKey");
      function isValidElement3(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      __name(isValidElement3, "isValidElement3");
      __name2(isValidElement3, "isValidElement");
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match2) {
          return escaperLookup[match2];
        });
      }
      __name(escape, "escape");
      __name2(escape, "escape");
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      __name(getElementKey, "getElementKey");
      __name2(getElementKey, "getElementKey");
      function noop$1() {
      }
      __name(noop$1, "noop$1");
      __name2(noop$1, "noop$1");
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      __name(resolveThenable, "resolveThenable");
      __name2(resolveThenable, "resolveThenable");
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type6 = typeof children;
        if ("undefined" === type6 || "boolean" === type6)
          children = null;
        var invokeCallback = false;
        if (null === children)
          invokeCallback = true;
        else
          switch (type6) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
            return c2;
          })) : null != callback && (isValidElement3(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement3(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i2 = 0; i2 < children.length; i2++)
            nameSoFar = children[i2], type6 = childKey + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type6,
              callback
            );
        else if (i2 = getIteratorFn(children), "function" === typeof i2)
          for (i2 === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type6 = childKey + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type6,
              callback
            );
        else if ("object" === type6) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      __name(mapIntoArray, "mapIntoArray");
      __name2(mapIntoArray, "mapIntoArray");
      function mapChildren(children, func, context) {
        if (null == children)
          return children;
        var result = [], count3 = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count3++);
        });
        return result;
      }
      __name(mapChildren, "mapChildren");
      __name2(mapChildren, "mapChildren");
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return ctor = payload._result, void 0 === ctor && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ctor
          ), "default" in ctor || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ctor
          ), ctor.default;
        throw payload._result;
      }
      __name(lazyInitializer, "lazyInitializer");
      __name2(lazyInitializer, "lazyInitializer");
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      __name(resolveDispatcher, "resolveDispatcher");
      __name2(resolveDispatcher, "resolveDispatcher");
      function noop2() {
      }
      __name(noop2, "noop2");
      __name2(noop2, "noop");
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module && module[requireString]).call(
              module,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = /* @__PURE__ */ __name2(function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            }, "enqueueTaskImpl");
          }
        return enqueueTaskImpl(task);
      }
      __name(enqueueTask, "enqueueTask");
      __name2(enqueueTask, "enqueueTask");
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      __name(aggregateErrors, "aggregateErrors");
      __name2(aggregateErrors, "aggregateErrors");
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      __name(popActScope, "popActScope");
      __name2(popActScope, "popActScope");
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else
            ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      __name(recursivelyFlushAsyncActWork, "recursivelyFlushAsyncActWork");
      __name2(recursivelyFlushAsyncActWork, "recursivelyFlushAsyncActWork");
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i2 = 0;
          try {
            for (; i2 < queue.length; i2++) {
              var callback = queue[i2];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i2] = callback;
                    queue.splice(0, i2);
                    return;
                  }
                  callback = continuation;
                } else
                  break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i2 + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      __name(flushActQueue, "flushActQueue");
      __name2(flushActQueue, "flushActQueue");
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component3.prototype.isReactComponent = {};
      Component3.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component3.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, fnName;
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component3.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component3.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        "react-stack-bottom-frame": function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event))
            return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size3) {
          return resolveDispatcher().useMemoCache(size3);
        }
      });
      exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement3(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Component = Component3;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = deprecatedAPIs;
      exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else
                    resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName)
          props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i2 = 0; i2 < propName; i2++)
            JSCompiler_inline_result[i2] = arguments[i2 + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          void 0,
          void 0,
          owner,
          props,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          owner = arguments[key], isValidElement3(owner) && owner._store && (owner._store.validated = 1);
        return props;
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports.createElement = function(type6, config, children) {
        for (var i2 = 2; i2 < arguments.length; i2++) {
          var node = arguments[i2];
          isValidElement3(node) && node._store && (node._store.validated = 1);
        }
        i2 = {};
        node = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i2[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength)
          i2.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
            childArray[_i] = arguments[_i + 2];
          Object.freeze && Object.freeze(childArray);
          i2.children = childArray;
        }
        if (type6 && type6.defaultProps)
          for (propName in childrenLength = type6.defaultProps, childrenLength)
            void 0 === i2[propName] && (i2[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(
          i2,
          "function" === typeof type6 ? type6.displayName || type6.name || "Unknown" : type6
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type6,
          node,
          void 0,
          void 0,
          getOwner(),
          i2,
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type6)) : unknownOwnerDebugTask
        );
      };
      exports.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }
        });
        return elementType;
      };
      exports.isValidElement = isValidElement3;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type6, compare) {
        null == type6 && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type6 ? "null" : typeof type6
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type: type6,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            type6.name || type6.displayName || (Object.defineProperty(type6, "name", { value: name }), type6.displayName = name);
          }
        });
        return compare;
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create4, createDeps, update) {
        null == create4 && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var dispatcher = resolveDispatcher();
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create4, createDeps);
      };
      exports.useId = function() {
        return resolveDispatcher().useId();
      };
      exports.useImperativeHandle = function(ref, create4, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create4, deps);
      };
      exports.useInsertionEffect = function(create4, deps) {
        null == create4 && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create4, deps);
      };
      exports.useLayoutEffect = function(create4, deps) {
        null == create4 && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create4, deps);
      };
      exports.useMemo = function(create4, deps) {
        return resolveDispatcher().useMemo(create4, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init2) {
        return resolveDispatcher().useReducer(reducer, initialArg, init2);
      };
      exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports.version = "19.1.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});
var require_react = __commonJS({
  "../node_modules/react/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});
var require_use_sync_external_store_shim_development = __commonJS({
  "../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    (function() {
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      __name(is, "is");
      __name2(is, "is");
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React31.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState13({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect5(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect20(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue3(value);
        return value;
      }
      __name(useSyncExternalStore$2, "useSyncExternalStore$2");
      __name2(useSyncExternalStore$2, "useSyncExternalStore$2");
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      __name(checkIfSnapshotChanged, "checkIfSnapshotChanged");
      __name2(checkIfSnapshotChanged, "checkIfSnapshotChanged");
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      __name(useSyncExternalStore$1, "useSyncExternalStore$1");
      __name2(useSyncExternalStore$1, "useSyncExternalStore$1");
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React31 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState13 = React31.useState, useEffect20 = React31.useEffect, useLayoutEffect5 = React31.useLayoutEffect, useDebugValue3 = React31.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React31.useSyncExternalStore ? React31.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});
var require_shim = __commonJS({
  "../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});
var require_with_selector_development = __commonJS({
  "../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    (function() {
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      __name(is, "is");
      __name2(is, "is");
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React31 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef16 = React31.useRef, useEffect20 = React31.useEffect, useMemo14 = React31.useMemo, useDebugValue3 = React31.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual4) {
        var instRef = useRef16(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else
          inst = instRef.current;
        instRef = useMemo14(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual4 && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual4(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual4 && isEqual4(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            __name(memoizedSelector, "memoizedSelector");
            __name2(memoizedSelector, "memoizedSelector");
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual4]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect20(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue3(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});
var require_with_selector = __commonJS({
  "../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});
var createStoreImpl;
var createStore;
var init_vanilla = __esm({
  "../node_modules/zustand/esm/vanilla.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    createStoreImpl = /* @__PURE__ */ __name2((createState2) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = /* @__PURE__ */ __name2((partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      }, "setState");
      const getState2 = /* @__PURE__ */ __name2(() => state, "getState");
      const getInitialState = /* @__PURE__ */ __name2(() => initialState, "getInitialState");
      const subscribe = /* @__PURE__ */ __name2((listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      }, "subscribe");
      const destroy = /* @__PURE__ */ __name2(() => {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      }, "destroy");
      const api = { setState, getState: getState2, getInitialState, subscribe, destroy };
      const initialState = state = createState2(setState, getState2, api);
      return api;
    }, "createStoreImpl");
    createStore = /* @__PURE__ */ __name2((createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl, "createStore");
  }
});
function useStoreWithEqualityFn(api, selector = identity, equalityFn) {
  const slice3 = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice3);
  return slice3;
}
__name(useStoreWithEqualityFn, "useStoreWithEqualityFn");
var import_react;
var import_with_selector;
var useDebugValue;
var useSyncExternalStoreWithSelector;
var identity;
var createWithEqualityFnImpl;
var createWithEqualityFn;
var init_traditional = __esm({
  "../node_modules/zustand/esm/traditional.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react = __toESM(require_react(), 1);
    import_with_selector = __toESM(require_with_selector(), 1);
    init_vanilla();
    ({ useDebugValue } = import_react.default);
    ({ useSyncExternalStoreWithSelector } = import_with_selector.default);
    identity = /* @__PURE__ */ __name2((arg) => arg, "identity");
    __name2(useStoreWithEqualityFn, "useStoreWithEqualityFn");
    createWithEqualityFnImpl = /* @__PURE__ */ __name2((createState2, defaultEqualityFn) => {
      const api = createStore(createState2);
      const useBoundStoreWithEqualityFn = /* @__PURE__ */ __name2((selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn), "useBoundStoreWithEqualityFn");
      Object.assign(useBoundStoreWithEqualityFn, api);
      return useBoundStoreWithEqualityFn;
    }, "createWithEqualityFnImpl");
    createWithEqualityFn = /* @__PURE__ */ __name2((createState2, defaultEqualityFn) => createState2 ? createWithEqualityFnImpl(createState2, defaultEqualityFn) : createWithEqualityFnImpl, "createWithEqualityFn");
  }
});
var require_base64_js = __commonJS({
  "../node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    __name2(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    __name2(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    __name2(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    __name2(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    __name2(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    __name2(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
    __name2(fromByteArray, "fromByteArray");
  }
});
var require_ieee754 = __commonJS({
  "../node_modules/ieee754/index.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    exports.read = function(buffer, offset, isLE2, mLen, nBytes) {
      var e2, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE2 ? nBytes - 1 : 0;
      var d2 = isLE2 ? -1 : 1;
      var s2 = buffer[offset + i2];
      i2 += d2;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE2, mLen, nBytes) {
      var e2, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE2 ? 0 : nBytes - 1;
      var d2 = isLE2 ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m2 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d2] |= s2 * 128;
    };
  }
});
var require_buffer = __commonJS({
  "../node_modules/buffer/index.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer4;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    __name2(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer4.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer4.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    __name(createBuffer, "createBuffer");
    __name2(createBuffer, "createBuffer");
    function Buffer4(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from27(arg, encodingOrOffset, length);
    }
    __name(Buffer4, "Buffer4");
    __name2(Buffer4, "Buffer");
    Buffer4.poolSize = 8192;
    function from27(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString5(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer4.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from27, "from27");
    __name2(from27, "from");
    Buffer4.from = function(value, encodingOrOffset, length) {
      return from27(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer4, Uint8Array);
    function assertSize3(size3) {
      if (typeof size3 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size3 < 0) {
        throw new RangeError('The value "' + size3 + '" is invalid for option "size"');
      }
    }
    __name(assertSize3, "assertSize3");
    __name2(assertSize3, "assertSize");
    function alloc(size3, fill, encoding) {
      assertSize3(size3);
      if (size3 <= 0) {
        return createBuffer(size3);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size3).fill(fill, encoding) : createBuffer(size3).fill(fill);
      }
      return createBuffer(size3);
    }
    __name(alloc, "alloc");
    __name2(alloc, "alloc");
    Buffer4.alloc = function(size3, fill, encoding) {
      return alloc(size3, fill, encoding);
    };
    function allocUnsafe(size3) {
      assertSize3(size3);
      return createBuffer(size3 < 0 ? 0 : checked(size3) | 0);
    }
    __name(allocUnsafe, "allocUnsafe");
    __name2(allocUnsafe, "allocUnsafe");
    Buffer4.allocUnsafe = function(size3) {
      return allocUnsafe(size3);
    };
    Buffer4.allocUnsafeSlow = function(size3) {
      return allocUnsafe(size3);
    };
    function fromString5(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    __name(fromString5, "fromString5");
    __name2(fromString5, "fromString");
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    __name(fromArrayLike, "fromArrayLike");
    __name2(fromArrayLike, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    __name2(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    __name2(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer4.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    __name2(fromObject, "fromObject");
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    __name(checked, "checked");
    __name2(checked, "checked");
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer4.alloc(+length);
    }
    __name(SlowBuffer, "SlowBuffer");
    __name2(SlowBuffer, "SlowBuffer");
    Buffer4.isBuffer = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
    }, "isBuffer"), "isBuffer");
    Buffer4.compare = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function compare(a2, b2) {
      if (isInstance(a2, Uint8Array))
        a2 = Buffer4.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
      if (!Buffer4.isBuffer(a2) || !Buffer4.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2)
        return 0;
      let x2 = a2.length;
      let y2 = b2.length;
      for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x2 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    }, "compare"), "compare");
    Buffer4.isEncoding = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding"), "isEncoding");
    Buffer4.concat = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function concat3(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer4.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer = Buffer4.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer4.isBuffer(buf))
              buf = Buffer4.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    }, "concat3"), "concat");
    function byteLength(string, encoding) {
      if (Buffer4.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes3(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes3(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength, "byteLength");
    __name2(byteLength, "byteLength");
    Buffer4.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    __name2(slowToString, "slowToString");
    Buffer4.prototype._isBuffer = true;
    function swap(b2, n2, m2) {
      const i2 = b2[n2];
      b2[n2] = b2[m2];
      b2[m2] = i2;
    }
    __name(swap, "swap");
    __name2(swap, "swap");
    Buffer4.prototype.swap16 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    }, "swap16"), "swap16");
    Buffer4.prototype.swap32 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    }, "swap32"), "swap32");
    Buffer4.prototype.swap64 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    }, "swap64"), "swap64");
    Buffer4.prototype.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString5() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    }, "toString5"), "toString");
    Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
    Buffer4.prototype.equals = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function equals(b2) {
      if (!Buffer4.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer4.compare(this, b2) === 0;
    }, "equals"), "equals");
    Buffer4.prototype.inspect = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect"), "inspect");
    if (customInspectSymbol) {
      Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
    }
    Buffer4.prototype.compare = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer4.from(target, target.offset, target.byteLength);
      }
      if (!Buffer4.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end - start;
      const len = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    }, "compare"), "compare");
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer4.from(val, encoding);
      }
      if (Buffer4.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    __name2(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      __name(read, "read");
      __name2(read, "read");
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i2 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    __name2(arrayIndexOf, "arrayIndexOf");
    Buffer4.prototype.includes = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    }, "includes"), "includes");
    Buffer4.prototype.indexOf = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    }, "indexOf"), "indexOf");
    Buffer4.prototype.lastIndexOf = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    }, "lastIndexOf"), "lastIndexOf");
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    __name(hexWrite, "hexWrite");
    __name2(hexWrite, "hexWrite");
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes3(string, buf.length - offset), buf, offset, length);
    }
    __name(utf8Write, "utf8Write");
    __name2(utf8Write, "utf8Write");
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    __name(asciiWrite, "asciiWrite");
    __name2(asciiWrite, "asciiWrite");
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    __name(base64Write, "base64Write");
    __name2(base64Write, "base64Write");
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(ucs2Write, "ucs2Write");
    __name2(ucs2Write, "ucs2Write");
    Buffer4.prototype.write = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write"), "write");
    Buffer4.prototype.toJSON = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON"), "toJSON");
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    __name2(base64Slice, "base64Slice");
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    __name(utf8Slice, "utf8Slice");
    __name2(utf8Slice, "utf8Slice");
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    __name2(decodeCodePointsArray, "decodeCodePointsArray");
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    __name2(asciiSlice, "asciiSlice");
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    __name2(latin1Slice, "latin1Slice");
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    __name2(hexSlice, "hexSlice");
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    __name2(utf16leSlice, "utf16leSlice");
    Buffer4.prototype.slice = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function slice3(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer4.prototype);
      return newBuf;
    }, "slice3"), "slice");
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    __name2(checkOffset, "checkOffset");
    Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    }, "readUIntLE"), "readUIntLE");
    Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    }, "readUIntBE"), "readUIntBE");
    Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8"), "readUInt8");
    Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE"), "readUInt16LE");
    Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE"), "readUInt16BE");
    Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE"), "readUInt32LE");
    Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE"), "readUInt32BE");
    Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    }, "readBigUInt64LE"), "readBigUInt64LE"));
    Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    }, "readBigUInt64BE"), "readBigUInt64BE"));
    Buffer4.prototype.readIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntLE"), "readIntLE");
    Buffer4.prototype.readIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i2 = byteLength2;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntBE"), "readIntBE");
    Buffer4.prototype.readInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8"), "readInt8");
    Buffer4.prototype.readInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16LE"), "readInt16LE");
    Buffer4.prototype.readInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16BE"), "readInt16BE");
    Buffer4.prototype.readInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE"), "readInt32LE");
    Buffer4.prototype.readInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE"), "readInt32BE");
    Buffer4.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    }, "readBigInt64LE"), "readBigInt64LE"));
    Buffer4.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    }, "readBigInt64BE"), "readBigInt64BE"));
    Buffer4.prototype.readFloatLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    }, "readFloatLE"), "readFloatLE");
    Buffer4.prototype.readFloatBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    }, "readFloatBE"), "readFloatBE");
    Buffer4.prototype.readDoubleLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    }, "readDoubleLE"), "readDoubleLE");
    Buffer4.prototype.readDoubleBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    }, "readDoubleBE"), "readDoubleBE");
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer4.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    __name2(checkInt, "checkInt");
    Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntLE"), "writeUIntLE");
    Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntBE"), "writeUIntBE");
    Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8"), "writeUInt8");
    Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE"), "writeUInt16LE");
    Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE"), "writeUInt16BE");
    Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE"), "writeUInt32LE");
    Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE"), "writeUInt32BE");
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    __name(wrtBigUInt64LE, "wrtBigUInt64LE");
    __name2(wrtBigUInt64LE, "wrtBigUInt64LE");
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    __name(wrtBigUInt64BE, "wrtBigUInt64BE");
    __name2(wrtBigUInt64BE, "wrtBigUInt64BE");
    Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64LE"), "writeBigUInt64LE"));
    Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"), "writeBigUInt64BE"));
    Buffer4.prototype.writeIntLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntLE"), "writeIntLE");
    Buffer4.prototype.writeIntBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntBE"), "writeIntBE");
    Buffer4.prototype.writeInt8 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8"), "writeInt8");
    Buffer4.prototype.writeInt16LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE"), "writeInt16LE");
    Buffer4.prototype.writeInt16BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE"), "writeInt16BE");
    Buffer4.prototype.writeInt32LE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE"), "writeInt32LE");
    Buffer4.prototype.writeInt32BE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE"), "writeInt32BE");
    Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"), "writeBigInt64LE"));
    Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE"), "writeBigInt64BE"));
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    __name2(checkIEEE754, "checkIEEE754");
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    __name2(writeFloat, "writeFloat");
    Buffer4.prototype.writeFloatLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE"), "writeFloatLE");
    Buffer4.prototype.writeFloatBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE"), "writeFloatBE");
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    __name2(writeDouble, "writeDouble");
    Buffer4.prototype.writeDoubleLE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE"), "writeDoubleLE");
    Buffer4.prototype.writeDoubleBE = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE"), "writeDoubleBE");
    Buffer4.prototype.copy = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function copy2(target, targetStart, start, end) {
      if (!Buffer4.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy2"), "copy");
    Buffer4.prototype.fill = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    }, "fill"), "fill");
    var errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      }, "NodeError"), "NodeError");
    }
    __name(E2, "E2");
    __name2(E2, "E");
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    __name2(addNumericalSeparator, "addNumericalSeparator");
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    __name(checkBounds, "checkBounds");
    __name2(checkBounds, "checkBounds");
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range = `>= ${min}${n2} and <= ${max}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    __name(checkIntBI, "checkIntBI");
    __name2(checkIntBI, "checkIntBI");
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    __name(validateNumber, "validateNumber");
    __name2(validateNumber, "validateNumber");
    function boundsError(value, length, type6) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type6);
        throw new errors.ERR_OUT_OF_RANGE(type6 || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type6 || "offset",
        `>= ${type6 ? 1 : 0} and <= ${length}`,
        value
      );
    }
    __name(boundsError, "boundsError");
    __name2(boundsError, "boundsError");
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    __name2(base64clean, "base64clean");
    function utf8ToBytes3(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes3, "utf8ToBytes3");
    __name2(utf8ToBytes3, "utf8ToBytes");
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    __name2(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      let c2, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i2);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    __name2(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    __name(base64ToBytes, "base64ToBytes");
    __name2(base64ToBytes, "base64ToBytes");
    function blitBuffer(src, dst, offset, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length)
          break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    __name(blitBuffer, "blitBuffer");
    __name2(blitBuffer, "blitBuffer");
    function isInstance(obj, type6) {
      return obj instanceof type6 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type6.name;
    }
    __name(isInstance, "isInstance");
    __name2(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    __name2(numberIsNaN, "numberIsNaN");
    var hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    __name(defineBigIntMethod, "defineBigIntMethod");
    __name2(defineBigIntMethod, "defineBigIntMethod");
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    __name(BufferBigIntNotDefined, "BufferBigIntNotDefined");
    __name2(BufferBigIntNotDefined, "BufferBigIntNotDefined");
  }
});
var version;
var init_version = __esm({
  "../node_modules/abitype/dist/esm/version.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    version = "1.0.8";
  }
});
var BaseError;
var init_errors = __esm({
  "../node_modules/abitype/dist/esm/errors.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_version();
    BaseError = /* @__PURE__ */ __name(class extends Error {
      constructor(shortMessage, args = {}) {
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: abitype@${version}`
        ].join("\n");
        super(message);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiTypeError"
        });
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
    }, "BaseError");
    __name2(BaseError, "BaseError");
  }
});
function execTyped(regex, string) {
  const match2 = regex.exec(string);
  return match2?.groups;
}
__name(execTyped, "execTyped");
var bytesRegex;
var integerRegex;
var isTupleRegex;
var init_regex = __esm({
  "../node_modules/abitype/dist/esm/regex.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(execTyped, "execTyped");
    bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    isTupleRegex = /^\(.+?\).*?$/;
  }
});
function formatAbiParameter(abiParameter) {
  let type6 = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type6 = "(";
    const length = abiParameter.components.length;
    for (let i2 = 0; i2 < length; i2++) {
      const component = abiParameter.components[i2];
      type6 += formatAbiParameter(component);
      if (i2 < length - 1)
        type6 += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type6 += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type: type6
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type6 = `${type6} indexed`;
  if (abiParameter.name)
    return `${type6} ${abiParameter.name}`;
  return type6;
}
__name(formatAbiParameter, "formatAbiParameter");
var tupleRegex;
var init_formatAbiParameter = __esm({
  "../node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_regex();
    tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    __name2(formatAbiParameter, "formatAbiParameter");
  }
});
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i2 = 0; i2 < length; i2++) {
    const abiParameter = abiParameters[i2];
    params += formatAbiParameter(abiParameter);
    if (i2 !== length - 1)
      params += ", ";
  }
  return params;
}
__name(formatAbiParameters, "formatAbiParameters");
var init_formatAbiParameters = __esm({
  "../node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_formatAbiParameter();
    __name2(formatAbiParameters, "formatAbiParameters");
  }
});
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  return "receive() external payable";
}
__name(formatAbiItem, "formatAbiItem");
var init_formatAbiItem = __esm({
  "../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_formatAbiParameters();
    __name2(formatAbiItem, "formatAbiItem");
  }
});
function formatAbi(abi) {
  const signatures = [];
  const length = abi.length;
  for (let i2 = 0; i2 < length; i2++) {
    const abiItem = abi[i2];
    const signature = formatAbiItem(abiItem);
    signatures.push(signature);
  }
  return signatures;
}
__name(formatAbi, "formatAbi");
var init_formatAbi = __esm({
  "../node_modules/abitype/dist/esm/human-readable/formatAbi.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_formatAbiItem();
    __name2(formatAbi, "formatAbi");
  }
});
function isErrorSignature(signature) {
  return errorSignatureRegex.test(signature);
}
__name(isErrorSignature, "isErrorSignature");
function execErrorSignature(signature) {
  return execTyped(errorSignatureRegex, signature);
}
__name(execErrorSignature, "execErrorSignature");
function isEventSignature(signature) {
  return eventSignatureRegex.test(signature);
}
__name(isEventSignature, "isEventSignature");
function execEventSignature(signature) {
  return execTyped(eventSignatureRegex, signature);
}
__name(execEventSignature, "execEventSignature");
function isFunctionSignature(signature) {
  return functionSignatureRegex.test(signature);
}
__name(isFunctionSignature, "isFunctionSignature");
function execFunctionSignature(signature) {
  return execTyped(functionSignatureRegex, signature);
}
__name(execFunctionSignature, "execFunctionSignature");
function isStructSignature(signature) {
  return structSignatureRegex.test(signature);
}
__name(isStructSignature, "isStructSignature");
function execStructSignature(signature) {
  return execTyped(structSignatureRegex, signature);
}
__name(execStructSignature, "execStructSignature");
function isConstructorSignature(signature) {
  return constructorSignatureRegex.test(signature);
}
__name(isConstructorSignature, "isConstructorSignature");
function execConstructorSignature(signature) {
  return execTyped(constructorSignatureRegex, signature);
}
__name(execConstructorSignature, "execConstructorSignature");
function isFallbackSignature(signature) {
  return fallbackSignatureRegex.test(signature);
}
__name(isFallbackSignature, "isFallbackSignature");
function execFallbackSignature(signature) {
  return execTyped(fallbackSignatureRegex, signature);
}
__name(execFallbackSignature, "execFallbackSignature");
function isReceiveSignature(signature) {
  return receiveSignatureRegex.test(signature);
}
__name(isReceiveSignature, "isReceiveSignature");
var errorSignatureRegex;
var eventSignatureRegex;
var functionSignatureRegex;
var structSignatureRegex;
var constructorSignatureRegex;
var fallbackSignatureRegex;
var receiveSignatureRegex;
var modifiers;
var eventModifiers;
var functionModifiers;
var init_signatures = __esm({
  "../node_modules/abitype/dist/esm/human-readable/runtime/signatures.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_regex();
    errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    __name2(isErrorSignature, "isErrorSignature");
    __name2(execErrorSignature, "execErrorSignature");
    eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    __name2(isEventSignature, "isEventSignature");
    __name2(execEventSignature, "execEventSignature");
    functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
    __name2(isFunctionSignature, "isFunctionSignature");
    __name2(execFunctionSignature, "execFunctionSignature");
    structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
    __name2(isStructSignature, "isStructSignature");
    __name2(execStructSignature, "execStructSignature");
    constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
    __name2(isConstructorSignature, "isConstructorSignature");
    __name2(execConstructorSignature, "execConstructorSignature");
    fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
    __name2(isFallbackSignature, "isFallbackSignature");
    __name2(execFallbackSignature, "execFallbackSignature");
    receiveSignatureRegex = /^receive\(\) external payable$/;
    __name2(isReceiveSignature, "isReceiveSignature");
    modifiers = /* @__PURE__ */ new Set([
      "memory",
      "indexed",
      "storage",
      "calldata"
    ]);
    eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
    functionModifiers = /* @__PURE__ */ new Set([
      "calldata",
      "memory",
      "storage"
    ]);
  }
});
var InvalidAbiItemError;
var UnknownTypeError;
var UnknownSolidityTypeError;
var init_abiItem = __esm({
  "../node_modules/abitype/dist/esm/human-readable/errors/abiItem.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_errors();
    InvalidAbiItemError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ signature }) {
        super("Failed to parse ABI item.", {
          details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
          docsPath: "/api/human#parseabiitem-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiItemError"
        });
      }
    }, "InvalidAbiItemError");
    __name2(InvalidAbiItemError, "InvalidAbiItemError");
    UnknownTypeError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ type: type6 }) {
        super("Unknown type.", {
          metaMessages: [
            `Type "${type6}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownTypeError"
        });
      }
    }, "UnknownTypeError");
    __name2(UnknownTypeError, "UnknownTypeError");
    UnknownSolidityTypeError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ type: type6 }) {
        super("Unknown type.", {
          metaMessages: [`Type "${type6}" is not a valid ABI type.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSolidityTypeError"
        });
      }
    }, "UnknownSolidityTypeError");
    __name2(UnknownSolidityTypeError, "UnknownSolidityTypeError");
  }
});
var InvalidAbiParametersError;
var InvalidParameterError;
var SolidityProtectedKeywordError;
var InvalidModifierError;
var InvalidFunctionModifierError;
var InvalidAbiTypeParameterError;
var init_abiParameter = __esm({
  "../node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_errors();
    InvalidAbiParametersError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ params }) {
        super("Failed to parse ABI parameters.", {
          details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
          docsPath: "/api/human#parseabiparameters-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParametersError"
        });
      }
    }, "InvalidAbiParametersError");
    __name2(InvalidAbiParametersError, "InvalidAbiParametersError");
    InvalidParameterError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ param }) {
        super("Invalid ABI parameter.", {
          details: param
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParameterError"
        });
      }
    }, "InvalidParameterError");
    __name2(InvalidParameterError, "InvalidParameterError");
    SolidityProtectedKeywordError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ param, name }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SolidityProtectedKeywordError"
        });
      }
    }, "SolidityProtectedKeywordError");
    __name2(SolidityProtectedKeywordError, "SolidityProtectedKeywordError");
    InvalidModifierError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ param, type: type6, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type6 ? ` in "${type6}" type` : ""}.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidModifierError"
        });
      }
    }, "InvalidModifierError");
    __name2(InvalidModifierError, "InvalidModifierError");
    InvalidFunctionModifierError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ param, type: type6, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type6 ? ` in "${type6}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidFunctionModifierError"
        });
      }
    }, "InvalidFunctionModifierError");
    __name2(InvalidFunctionModifierError, "InvalidFunctionModifierError");
    InvalidAbiTypeParameterError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ abiParameter }) {
        super("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiTypeParameterError"
        });
      }
    }, "InvalidAbiTypeParameterError");
    __name2(InvalidAbiTypeParameterError, "InvalidAbiTypeParameterError");
  }
});
var InvalidSignatureError;
var UnknownSignatureError;
var InvalidStructSignatureError;
var init_signature = __esm({
  "../node_modules/abitype/dist/esm/human-readable/errors/signature.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_errors();
    InvalidSignatureError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ signature, type: type6 }) {
        super(`Invalid ${type6} signature.`, {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSignatureError"
        });
      }
    }, "InvalidSignatureError");
    __name2(InvalidSignatureError, "InvalidSignatureError");
    UnknownSignatureError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ signature }) {
        super("Unknown signature.", {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSignatureError"
        });
      }
    }, "UnknownSignatureError");
    __name2(UnknownSignatureError, "UnknownSignatureError");
    InvalidStructSignatureError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ signature }) {
        super("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStructSignatureError"
        });
      }
    }, "InvalidStructSignatureError");
    __name2(InvalidStructSignatureError, "InvalidStructSignatureError");
  }
});
var CircularReferenceError;
var init_struct = __esm({
  "../node_modules/abitype/dist/esm/human-readable/errors/struct.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_errors();
    CircularReferenceError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ type: type6 }) {
        super("Circular reference detected.", {
          metaMessages: [`Struct "${type6}" is a circular reference.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CircularReferenceError"
        });
      }
    }, "CircularReferenceError");
    __name2(CircularReferenceError, "CircularReferenceError");
  }
});
var InvalidParenthesisError;
var init_splitParameters = __esm({
  "../node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_errors();
    InvalidParenthesisError = /* @__PURE__ */ __name(class extends BaseError {
      constructor({ current, depth }) {
        super("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParenthesisError"
        });
      }
    }, "InvalidParenthesisError");
    __name2(InvalidParenthesisError, "InvalidParenthesisError");
  }
});
function getParameterCacheKey(param, type6, structs) {
  let structKey = "";
  if (structs)
    for (const struct of Object.entries(structs)) {
      if (!struct)
        continue;
      let propertyKey = "";
      for (const property of struct[1]) {
        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
      }
      structKey += `(${struct[0]}{${propertyKey}})`;
    }
  if (type6)
    return `${type6}:${param}${structKey}`;
  return param;
}
__name(getParameterCacheKey, "getParameterCacheKey");
var parameterCache;
var init_cache = __esm({
  "../node_modules/abitype/dist/esm/human-readable/runtime/cache.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(getParameterCacheKey, "getParameterCacheKey");
    parameterCache = /* @__PURE__ */ new Map([
      // Unnamed
      ["address", { type: "address" }],
      ["bool", { type: "bool" }],
      ["bytes", { type: "bytes" }],
      ["bytes32", { type: "bytes32" }],
      ["int", { type: "int256" }],
      ["int256", { type: "int256" }],
      ["string", { type: "string" }],
      ["uint", { type: "uint256" }],
      ["uint8", { type: "uint8" }],
      ["uint16", { type: "uint16" }],
      ["uint24", { type: "uint24" }],
      ["uint32", { type: "uint32" }],
      ["uint64", { type: "uint64" }],
      ["uint96", { type: "uint96" }],
      ["uint112", { type: "uint112" }],
      ["uint160", { type: "uint160" }],
      ["uint192", { type: "uint192" }],
      ["uint256", { type: "uint256" }],
      // Named
      ["address owner", { type: "address", name: "owner" }],
      ["address to", { type: "address", name: "to" }],
      ["bool approved", { type: "bool", name: "approved" }],
      ["bytes _data", { type: "bytes", name: "_data" }],
      ["bytes data", { type: "bytes", name: "data" }],
      ["bytes signature", { type: "bytes", name: "signature" }],
      ["bytes32 hash", { type: "bytes32", name: "hash" }],
      ["bytes32 r", { type: "bytes32", name: "r" }],
      ["bytes32 root", { type: "bytes32", name: "root" }],
      ["bytes32 s", { type: "bytes32", name: "s" }],
      ["string name", { type: "string", name: "name" }],
      ["string symbol", { type: "string", name: "symbol" }],
      ["string tokenURI", { type: "string", name: "tokenURI" }],
      ["uint tokenId", { type: "uint256", name: "tokenId" }],
      ["uint8 v", { type: "uint8", name: "v" }],
      ["uint256 balance", { type: "uint256", name: "balance" }],
      ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
      ["uint256 value", { type: "uint256", name: "value" }],
      // Indexed
      [
        "event:address indexed from",
        { type: "address", name: "from", indexed: true }
      ],
      ["event:address indexed to", { type: "address", name: "to", indexed: true }],
      [
        "event:uint indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ],
      [
        "event:uint256 indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ]
    ]);
  }
});
function parseSignature(signature, structs = {}) {
  if (isFunctionSignature(signature))
    return parseFunctionSignature(signature, structs);
  if (isEventSignature(signature))
    return parseEventSignature(signature, structs);
  if (isErrorSignature(signature))
    return parseErrorSignature(signature, structs);
  if (isConstructorSignature(signature))
    return parseConstructorSignature(signature, structs);
  if (isFallbackSignature(signature))
    return parseFallbackSignature(signature);
  if (isReceiveSignature(signature))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature });
}
__name(parseSignature, "parseSignature");
function parseFunctionSignature(signature, structs = {}) {
  const match2 = execFunctionSignature(signature);
  if (!match2)
    throw new InvalidSignatureError({ signature, type: "function" });
  const inputParams = splitParameters(match2.parameters);
  const inputs = [];
  const inputLength = inputParams.length;
  for (let i2 = 0; i2 < inputLength; i2++) {
    inputs.push(parseAbiParameter(inputParams[i2], {
      modifiers: functionModifiers,
      structs,
      type: "function"
    }));
  }
  const outputs = [];
  if (match2.returns) {
    const outputParams = splitParameters(match2.returns);
    const outputLength = outputParams.length;
    for (let i2 = 0; i2 < outputLength; i2++) {
      outputs.push(parseAbiParameter(outputParams[i2], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
  }
  return {
    name: match2.name,
    type: "function",
    stateMutability: match2.stateMutability ?? "nonpayable",
    inputs,
    outputs
  };
}
__name(parseFunctionSignature, "parseFunctionSignature");
function parseEventSignature(signature, structs = {}) {
  const match2 = execEventSignature(signature);
  if (!match2)
    throw new InvalidSignatureError({ signature, type: "event" });
  const params = splitParameters(match2.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i2 = 0; i2 < length; i2++)
    abiParameters.push(parseAbiParameter(params[i2], {
      modifiers: eventModifiers,
      structs,
      type: "event"
    }));
  return { name: match2.name, type: "event", inputs: abiParameters };
}
__name(parseEventSignature, "parseEventSignature");
function parseErrorSignature(signature, structs = {}) {
  const match2 = execErrorSignature(signature);
  if (!match2)
    throw new InvalidSignatureError({ signature, type: "error" });
  const params = splitParameters(match2.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i2 = 0; i2 < length; i2++)
    abiParameters.push(parseAbiParameter(params[i2], { structs, type: "error" }));
  return { name: match2.name, type: "error", inputs: abiParameters };
}
__name(parseErrorSignature, "parseErrorSignature");
function parseConstructorSignature(signature, structs = {}) {
  const match2 = execConstructorSignature(signature);
  if (!match2)
    throw new InvalidSignatureError({ signature, type: "constructor" });
  const params = splitParameters(match2.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i2 = 0; i2 < length; i2++)
    abiParameters.push(parseAbiParameter(params[i2], { structs, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: match2.stateMutability ?? "nonpayable",
    inputs: abiParameters
  };
}
__name(parseConstructorSignature, "parseConstructorSignature");
function parseFallbackSignature(signature) {
  const match2 = execFallbackSignature(signature);
  if (!match2)
    throw new InvalidSignatureError({ signature, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: match2.stateMutability ?? "nonpayable"
  };
}
__name(parseFallbackSignature, "parseFallbackSignature");
function parseAbiParameter(param, options2) {
  const parameterCacheKey = getParameterCacheKey(param, options2?.type, options2?.structs);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match2 = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
  if (!match2)
    throw new InvalidParameterError({ param });
  if (match2.name && isSolidityKeyword(match2.name))
    throw new SolidityProtectedKeywordError({ param, name: match2.name });
  const name = match2.name ? { name: match2.name } : {};
  const indexed = match2.modifier === "indexed" ? { indexed: true } : {};
  const structs = options2?.structs ?? {};
  let type6;
  let components = {};
  if (isTuple) {
    type6 = "tuple";
    const params = splitParameters(match2.type);
    const components_ = [];
    const length = params.length;
    for (let i2 = 0; i2 < length; i2++) {
      components_.push(parseAbiParameter(params[i2], { structs }));
    }
    components = { components: components_ };
  } else if (match2.type in structs) {
    type6 = "tuple";
    components = { components: structs[match2.type] };
  } else if (dynamicIntegerRegex.test(match2.type)) {
    type6 = `${match2.type}256`;
  } else {
    type6 = match2.type;
    if (!(options2?.type === "struct") && !isSolidityType(type6))
      throw new UnknownSolidityTypeError({ type: type6 });
  }
  if (match2.modifier) {
    if (!options2?.modifiers?.has?.(match2.modifier))
      throw new InvalidModifierError({
        param,
        type: options2?.type,
        modifier: match2.modifier
      });
    if (functionModifiers.has(match2.modifier) && !isValidDataLocation(type6, !!match2.array))
      throw new InvalidFunctionModifierError({
        param,
        type: options2?.type,
        modifier: match2.modifier
      });
  }
  const abiParameter = {
    type: `${type6}${match2.array ?? ""}`,
    ...name,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
__name(parseAbiParameter, "parseAbiParameter");
function splitParameters(params, result = [], current = "", depth = 0) {
  const length = params.trim().length;
  for (let i2 = 0; i2 < length; i2++) {
    const char = params[i2];
    const tail = params.slice(i2 + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char}`, depth);
    }
  }
  if (current === "")
    return result;
  if (depth !== 0)
    throw new InvalidParenthesisError({ current, depth });
  result.push(current.trim());
  return result;
}
__name(splitParameters, "splitParameters");
function isSolidityType(type6) {
  return type6 === "address" || type6 === "bool" || type6 === "function" || type6 === "string" || bytesRegex.test(type6) || integerRegex.test(type6);
}
__name(isSolidityType, "isSolidityType");
function isSolidityKeyword(name) {
  return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
}
__name(isSolidityKeyword, "isSolidityKeyword");
function isValidDataLocation(type6, isArray) {
  return isArray || type6 === "bytes" || type6 === "string" || type6 === "tuple";
}
__name(isValidDataLocation, "isValidDataLocation");
var abiParameterWithoutTupleRegex;
var abiParameterWithTupleRegex;
var dynamicIntegerRegex;
var protectedKeywordsRegex;
var init_utils = __esm({
  "../node_modules/abitype/dist/esm/human-readable/runtime/utils.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_regex();
    init_abiItem();
    init_abiParameter();
    init_signature();
    init_splitParameters();
    init_cache();
    init_signatures();
    __name2(parseSignature, "parseSignature");
    __name2(parseFunctionSignature, "parseFunctionSignature");
    __name2(parseEventSignature, "parseEventSignature");
    __name2(parseErrorSignature, "parseErrorSignature");
    __name2(parseConstructorSignature, "parseConstructorSignature");
    __name2(parseFallbackSignature, "parseFallbackSignature");
    abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    dynamicIntegerRegex = /^u?int$/;
    __name2(parseAbiParameter, "parseAbiParameter");
    __name2(splitParameters, "splitParameters");
    __name2(isSolidityType, "isSolidityType");
    protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    __name2(isSolidityKeyword, "isSolidityKeyword");
    __name2(isValidDataLocation, "isValidDataLocation");
  }
});
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i2 = 0; i2 < signaturesLength; i2++) {
    const signature = signatures[i2];
    if (!isStructSignature(signature))
      continue;
    const match2 = execStructSignature(signature);
    if (!match2)
      throw new InvalidSignatureError({ signature, type: "struct" });
    const properties = match2.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k = 0; k < propertiesLength; k++) {
      const property = properties[k];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new InvalidStructSignatureError({ signature });
    shallowStructs[match2.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i2 = 0; i2 < entriesLength; i2++) {
    const [name, parameters] = entries[i2];
    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
__name(parseStructs, "parseStructs");
function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
  const components = [];
  const length = abiParameters.length;
  for (let i2 = 0; i2 < length; i2++) {
    const abiParameter = abiParameters[i2];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match2 = execTyped(typeWithoutTupleRegex, abiParameter.type);
      if (!match2?.type)
        throw new InvalidAbiTypeParameterError({ abiParameter });
      const { array, type: type6 } = match2;
      if (type6 in structs) {
        if (ancestors.has(type6))
          throw new CircularReferenceError({ type: type6 });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs[type6] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type6]))
        });
      } else {
        if (isSolidityType(type6))
          components.push(abiParameter);
        else
          throw new UnknownTypeError({ type: type6 });
      }
    }
  }
  return components;
}
__name(resolveStructs, "resolveStructs");
var typeWithoutTupleRegex;
var init_structs = __esm({
  "../node_modules/abitype/dist/esm/human-readable/runtime/structs.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_regex();
    init_abiItem();
    init_abiParameter();
    init_signature();
    init_struct();
    init_signatures();
    init_utils();
    __name2(parseStructs, "parseStructs");
    typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    __name2(resolveStructs, "resolveStructs");
  }
});
function parseAbi(signatures) {
  const structs = parseStructs(signatures);
  const abi = [];
  const length = signatures.length;
  for (let i2 = 0; i2 < length; i2++) {
    const signature = signatures[i2];
    if (isStructSignature(signature))
      continue;
    abi.push(parseSignature(signature, structs));
  }
  return abi;
}
__name(parseAbi, "parseAbi");
var init_parseAbi = __esm({
  "../node_modules/abitype/dist/esm/human-readable/parseAbi.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_signatures();
    init_structs();
    init_utils();
    __name2(parseAbi, "parseAbi");
  }
});
function parseAbiItem(signature) {
  let abiItem;
  if (typeof signature === "string")
    abiItem = parseSignature(signature);
  else {
    const structs = parseStructs(signature);
    const length = signature.length;
    for (let i2 = 0; i2 < length; i2++) {
      const signature_ = signature[i2];
      if (isStructSignature(signature_))
        continue;
      abiItem = parseSignature(signature_, structs);
      break;
    }
  }
  if (!abiItem)
    throw new InvalidAbiItemError({ signature });
  return abiItem;
}
__name(parseAbiItem, "parseAbiItem");
var init_parseAbiItem = __esm({
  "../node_modules/abitype/dist/esm/human-readable/parseAbiItem.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_abiItem();
    init_signatures();
    init_structs();
    init_utils();
    __name2(parseAbiItem, "parseAbiItem");
  }
});
function parseAbiParameters(params) {
  const abiParameters = [];
  if (typeof params === "string") {
    const parameters = splitParameters(params);
    const length = parameters.length;
    for (let i2 = 0; i2 < length; i2++) {
      abiParameters.push(parseAbiParameter(parameters[i2], { modifiers }));
    }
  } else {
    const structs = parseStructs(params);
    const length = params.length;
    for (let i2 = 0; i2 < length; i2++) {
      const signature = params[i2];
      if (isStructSignature(signature))
        continue;
      const parameters = splitParameters(signature);
      const length2 = parameters.length;
      for (let k = 0; k < length2; k++) {
        abiParameters.push(parseAbiParameter(parameters[k], { modifiers, structs }));
      }
    }
  }
  if (abiParameters.length === 0)
    throw new InvalidAbiParametersError({ params });
  return abiParameters;
}
__name(parseAbiParameters, "parseAbiParameters");
var init_parseAbiParameters = __esm({
  "../node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_abiParameter();
    init_signatures();
    init_structs();
    init_utils();
    init_utils();
    __name2(parseAbiParameters, "parseAbiParameters");
  }
});
var init_exports = __esm({
  "../node_modules/abitype/dist/esm/exports/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_formatAbi();
    init_formatAbiItem();
    init_formatAbiParameters();
    init_parseAbi();
    init_parseAbiItem();
    init_parseAbiParameters();
  }
});
function isSignatures(value) {
  for (const item of value) {
    if (typeof item !== "string")
      return false;
  }
  return true;
}
__name(isSignatures, "isSignatures");
var init_abi = __esm({
  "../node_modules/ox/_esm/core/internal/abi.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isSignatures, "isSignatures");
  }
});
function format(abi) {
  return formatAbi(abi);
}
__name(format, "format");
function from(abi) {
  if (isSignatures(abi))
    return parseAbi(abi);
  return abi;
}
__name(from, "from");
var init_Abi = __esm({
  "../node_modules/ox/_esm/core/Abi.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_exports();
    init_abi();
    __name2(format, "format");
    format.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from, "from");
    from.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
var version2;
var init_version2 = __esm({
  "../node_modules/ox/_esm/core/version.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    version2 = "0.1.1";
  }
});
function getUrl(url) {
  return url;
}
__name(getUrl, "getUrl");
function getVersion() {
  return version2;
}
__name(getVersion, "getVersion");
function prettyPrint(args) {
  if (!args)
    return "";
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
__name(prettyPrint, "prettyPrint");
var init_errors2 = __esm({
  "../node_modules/ox/_esm/core/internal/errors.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_version2();
    __name2(getUrl, "getUrl");
    __name2(getVersion, "getVersion");
    __name2(prettyPrint, "prettyPrint");
  }
});
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk(err.cause, fn);
  return fn ? null : err;
}
__name(walk, "walk");
var BaseError2;
var init_Errors = __esm({
  "../node_modules/ox/_esm/core/Errors.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_errors2();
    BaseError2 = /* @__PURE__ */ __name(class extends Error {
      constructor(shortMessage, options2 = {}) {
        const details = (() => {
          if (options2.cause instanceof BaseError2) {
            if (options2.cause.details)
              return options2.cause.details;
            if (options2.cause.shortMessage)
              return options2.cause.shortMessage;
          }
          if (options2.cause?.message)
            return options2.cause.message;
          return options2.details;
        })();
        const docsPath = (() => {
          if (options2.cause instanceof BaseError2)
            return options2.cause.docsPath || options2.docsPath;
          return options2.docsPath;
        })();
        const docsBaseUrl = "https://oxlib.sh";
        const docs = `${docsBaseUrl}${docsPath ?? ""}`;
        const message = [
          shortMessage || "An error occurred.",
          ...options2.metaMessages ? ["", ...options2.metaMessages] : [],
          ...details || docsPath ? [
            "",
            details ? `Details: ${details}` : void 0,
            docsPath ? `See: ${docs}` : void 0
          ] : []
        ].filter((x2) => typeof x2 === "string").join("\n");
        super(message, options2.cause ? { cause: options2.cause } : void 0);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BaseError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: `ox@${getVersion()}`
        });
        this.cause = options2.cause;
        this.details = details;
        this.docs = docs;
        this.docsPath = docsPath;
        this.shortMessage = shortMessage;
      }
      walk(fn) {
        return walk(this, fn);
      }
    }, "BaseError2");
    __name2(BaseError2, "BaseError");
    __name2(walk, "walk");
  }
});
var crypto2;
var init_crypto = __esm({
  "../node_modules/@noble/hashes/esm/crypto.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
__name(isBytes, "isBytes");
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
__name(anumber, "anumber");
function abytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
__name(abytes, "abytes");
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h2.outputLen);
  anumber(h2.blockLen);
}
__name(ahash, "ahash");
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
__name(aexists, "aexists");
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
__name(aoutput, "aoutput");
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
__name(u32, "u32");
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
__name(clean, "clean");
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
__name(createView, "createView");
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
__name(rotr, "rotr");
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
__name(rotl, "rotl");
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
__name(byteSwap, "byteSwap");
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
  return arr;
}
__name(byteSwap32, "byteSwap32");
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex3 = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex3 += hexes[bytes[i2]];
  }
  return hex3;
}
__name(bytesToHex, "bytesToHex");
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
__name(asciiToBase16, "asciiToBase16");
function hexToBytes(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex3);
  const hl = hex3.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex3.charCodeAt(hi));
    const n2 = asciiToBase16(hex3.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex3[hi] + hex3[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
__name(hexToBytes, "hexToBytes");
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
__name(utf8ToBytes, "utf8ToBytes");
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
__name(toBytes, "toBytes");
function kdfInputToBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
__name(kdfInputToBytes, "kdfInputToBytes");
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad3 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad3);
    pad3 += a2.length;
  }
  return res;
}
__name(concatBytes, "concatBytes");
function checkOpts(defaults, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
__name(checkOpts, "checkOpts");
function createHasher(hashCons) {
  const hashC = /* @__PURE__ */ __name2((msg) => hashCons().update(toBytes(msg)).digest(), "hashC");
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
__name(createHasher, "createHasher");
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
__name(randomBytes, "randomBytes");
var isLE;
var swap32IfBE;
var hasHexBuiltin;
var hexes;
var asciis;
var Hash;
var init_utils2 = __esm({
  "../node_modules/@noble/hashes/esm/utils.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_crypto();
    __name2(isBytes, "isBytes");
    __name2(anumber, "anumber");
    __name2(abytes, "abytes");
    __name2(ahash, "ahash");
    __name2(aexists, "aexists");
    __name2(aoutput, "aoutput");
    __name2(u32, "u32");
    __name2(clean, "clean");
    __name2(createView, "createView");
    __name2(rotr, "rotr");
    __name2(rotl, "rotl");
    isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    __name2(byteSwap, "byteSwap");
    __name2(byteSwap32, "byteSwap32");
    swap32IfBE = isLE ? (u2) => u2 : byteSwap32;
    hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
    __name2(bytesToHex, "bytesToHex");
    asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    __name2(asciiToBase16, "asciiToBase16");
    __name2(hexToBytes, "hexToBytes");
    __name2(utf8ToBytes, "utf8ToBytes");
    __name2(toBytes, "toBytes");
    __name2(kdfInputToBytes, "kdfInputToBytes");
    __name2(concatBytes, "concatBytes");
    __name2(checkOpts, "checkOpts");
    Hash = /* @__PURE__ */ __name(class {
    }, "Hash");
    __name2(Hash, "Hash");
    __name2(createHasher, "createHasher");
    __name2(randomBytes, "randomBytes");
  }
});
function setBigUint64(view2, byteOffset, value, isLE2) {
  if (typeof view2.setBigUint64 === "function")
    return view2.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view2.setUint32(byteOffset + h2, wh, isLE2);
  view2.setUint32(byteOffset + l2, wl, isLE2);
}
__name(setBigUint64, "setBigUint64");
function Chi(a2, b2, c2) {
  return a2 & b2 ^ ~a2 & c2;
}
__name(Chi, "Chi");
function Maj(a2, b2, c2) {
  return a2 & b2 ^ a2 & c2 ^ b2 & c2;
}
__name(Maj, "Maj");
var HashMD;
var SHA256_IV;
var SHA384_IV;
var SHA512_IV;
var init_md = __esm({
  "../node_modules/@noble/hashes/esm/_md.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_utils2();
    __name2(setBigUint64, "setBigUint64");
    __name2(Chi, "Chi");
    __name2(Maj, "Maj");
    HashMD = /* @__PURE__ */ __name(class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        aexists(this);
        data = toBytes(data);
        abytes(data);
        const { view: view2, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view2, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer, view: view2, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        clean(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view2, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint64(view2, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view2, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to3) {
        to3 || (to3 = new this.constructor());
        to3.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to3.destroyed = destroyed;
        to3.finished = finished;
        to3.length = length;
        to3.pos = pos;
        if (length % blockLen)
          to3.buffer.set(buffer);
        return to3;
      }
      clone() {
        return this._cloneInto();
      }
    }, "HashMD");
    __name2(HashMD, "HashMD");
    SHA256_IV = /* @__PURE__ */ Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA384_IV = /* @__PURE__ */ Uint32Array.from([
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ]);
    SHA512_IV = /* @__PURE__ */ Uint32Array.from([
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ]);
  }
});
function ripemd_f(group, x2, y2, z2) {
  if (group === 0)
    return x2 ^ y2 ^ z2;
  if (group === 1)
    return x2 & y2 | ~x2 & z2;
  if (group === 2)
    return (x2 | ~y2) ^ z2;
  if (group === 3)
    return x2 & z2 | y2 & ~z2;
  return x2 ^ (y2 | ~z2);
}
__name(ripemd_f, "ripemd_f");
var Rho160;
var Id160;
var Pi160;
var idxLR;
var idxL;
var idxR;
var shifts160;
var shiftsL160;
var shiftsR160;
var Kl160;
var Kr160;
var BUF_160;
var RIPEMD160;
var ripemd160;
var init_legacy = __esm({
  "../node_modules/@noble/hashes/esm/legacy.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_md();
    init_utils2();
    Rho160 = /* @__PURE__ */ Uint8Array.from([
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8
    ]);
    Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i2) => i2)))();
    Pi160 = /* @__PURE__ */ (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
    idxLR = /* @__PURE__ */ (() => {
      const L = [Id160];
      const R = [Pi160];
      const res = [L, R];
      for (let i2 = 0; i2 < 4; i2++)
        for (let j2 of res)
          j2.push(j2[i2].map((k) => Rho160[k]));
      return res;
    })();
    idxL = /* @__PURE__ */ (() => idxLR[0])();
    idxR = /* @__PURE__ */ (() => idxLR[1])();
    shifts160 = /* @__PURE__ */ [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i2) => Uint8Array.from(i2));
    shiftsL160 = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j2) => shifts160[i2][j2]));
    shiftsR160 = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j2) => shifts160[i2][j2]));
    Kl160 = /* @__PURE__ */ Uint32Array.from([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    Kr160 = /* @__PURE__ */ Uint32Array.from([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    __name2(ripemd_f, "ripemd_f");
    BUF_160 = /* @__PURE__ */ new Uint32Array(16);
    RIPEMD160 = /* @__PURE__ */ __name(class extends HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view2, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          BUF_160[i2] = view2.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl160[group], hbr = Kr160[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL160[group], sr = shiftsR160[group];
          for (let i2 = 0; i2 < 16; i2++) {
            const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i2 = 0; i2 < 16; i2++) {
            const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i2]] + hbr, sr[i2]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        clean(BUF_160);
      }
      destroy() {
        this.destroyed = true;
        clean(this.buffer);
        this.set(0, 0, 0, 0, 0);
      }
    }, "RIPEMD160");
    __name2(RIPEMD160, "RIPEMD160");
    ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());
  }
});
var ripemd1602;
var init_ripemd160 = __esm({
  "../node_modules/@noble/hashes/esm/ripemd160.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_legacy();
    ripemd1602 = ripemd160;
  }
});
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
__name(fromBig, "fromBig");
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h: h2, l: l2 } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h2, l2];
  }
  return [Ah, Al];
}
__name(split, "split");
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
__name(add, "add");
var U32_MASK64;
var _32n;
var shrSH;
var shrSL;
var rotrSH;
var rotrSL;
var rotrBH;
var rotrBL;
var rotlSH;
var rotlSL;
var rotlBH;
var rotlBL;
var add3L;
var add3H;
var add4L;
var add4H;
var add5L;
var add5H;
var init_u64 = __esm({
  "../node_modules/@noble/hashes/esm/_u64.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n = /* @__PURE__ */ BigInt(32);
    __name2(fromBig, "fromBig");
    __name2(split, "split");
    shrSH = /* @__PURE__ */ __name2((h2, _l, s2) => h2 >>> s2, "shrSH");
    shrSL = /* @__PURE__ */ __name2((h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2, "shrSL");
    rotrSH = /* @__PURE__ */ __name2((h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2, "rotrSH");
    rotrSL = /* @__PURE__ */ __name2((h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2, "rotrSL");
    rotrBH = /* @__PURE__ */ __name2((h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32, "rotrBH");
    rotrBL = /* @__PURE__ */ __name2((h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2, "rotrBL");
    rotlSH = /* @__PURE__ */ __name2((h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2, "rotlSH");
    rotlSL = /* @__PURE__ */ __name2((h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2, "rotlSL");
    rotlBH = /* @__PURE__ */ __name2((h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2, "rotlBH");
    rotlBL = /* @__PURE__ */ __name2((h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2, "rotlBL");
    __name2(add, "add");
    add3L = /* @__PURE__ */ __name2((Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0), "add3L");
    add3H = /* @__PURE__ */ __name2((low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0, "add3H");
    add4L = /* @__PURE__ */ __name2((Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0), "add4L");
    add4H = /* @__PURE__ */ __name2((low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0, "add4H");
    add5L = /* @__PURE__ */ __name2((Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0), "add5L");
    add5H = /* @__PURE__ */ __name2((low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0, "add5H");
  }
});
function keccakP(s2, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x2 + y2] ^= Th;
        s2[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B[x2] = s2[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y2 + x2] ^= ~B[(x2 + 2) % 10] & B[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round];
    s2[1] ^= SHA3_IOTA_L[round];
  }
  clean(B);
}
__name(keccakP, "keccakP");
var _0n;
var _1n;
var _2n;
var _7n;
var _256n;
var _0x71n;
var SHA3_PI;
var SHA3_ROTL;
var _SHA3_IOTA;
var IOTAS;
var SHA3_IOTA_H;
var SHA3_IOTA_L;
var rotlH;
var rotlL;
var Keccak;
var gen;
var keccak_256;
var init_sha3 = __esm({
  "../node_modules/@noble/hashes/esm/sha3.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_u64();
    init_utils2();
    _0n = BigInt(0);
    _1n = BigInt(1);
    _2n = BigInt(2);
    _7n = BigInt(7);
    _256n = BigInt(256);
    _0x71n = BigInt(113);
    SHA3_PI = [];
    SHA3_ROTL = [];
    _SHA3_IOTA = [];
    for (let round = 0, R = _1n, x2 = 1, y2 = 0; round < 24; round++) {
      [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
      SHA3_PI.push(2 * (5 * y2 + x2));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t2 = _0n;
      for (let j2 = 0; j2 < 7; j2++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t2 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j2)) - _1n;
      }
      _SHA3_IOTA.push(t2);
    }
    IOTAS = split(_SHA3_IOTA, true);
    SHA3_IOTA_H = IOTAS[0];
    SHA3_IOTA_L = IOTAS[1];
    rotlH = /* @__PURE__ */ __name2((h2, l2, s2) => s2 > 32 ? rotlBH(h2, l2, s2) : rotlSH(h2, l2, s2), "rotlH");
    rotlL = /* @__PURE__ */ __name2((h2, l2, s2) => s2 > 32 ? rotlBL(h2, l2, s2) : rotlSL(h2, l2, s2), "rotlL");
    __name2(keccakP, "keccakP");
    Keccak = /* @__PURE__ */ __name(class extends Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        anumber(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        swap32IfBE(this.state32);
        keccakP(this.state32, this.rounds);
        swap32IfBE(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        aexists(this);
        data = toBytes(data);
        abytes(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i2 = 0; i2 < take; i2++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        aexists(this, false);
        abytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        anumber(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        aoutput(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        clean(this.state);
      }
      _cloneInto(to3) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to3 || (to3 = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to3.state32.set(this.state32);
        to3.pos = this.pos;
        to3.posOut = this.posOut;
        to3.finished = this.finished;
        to3.rounds = rounds;
        to3.suffix = suffix;
        to3.outputLen = outputLen;
        to3.enableXOF = enableXOF;
        to3.destroyed = this.destroyed;
        return to3;
      }
    }, "Keccak");
    __name2(Keccak, "Keccak");
    gen = /* @__PURE__ */ __name2((suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen)), "gen");
    keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();
  }
});
var SHA256_K;
var SHA256_W;
var SHA256;
var K512;
var SHA512_Kh;
var SHA512_Kl;
var SHA512_W_H;
var SHA512_W_L;
var SHA512;
var SHA384;
var sha256;
var sha512;
var sha384;
var init_sha2 = __esm({
  "../node_modules/@noble/hashes/esm/sha2.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_md();
    init_u64();
    init_utils2();
    SHA256_K = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    SHA256 = /* @__PURE__ */ __name(class extends HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C: C2, D, E: E2, F, G, H } = this;
        return [A, B, C2, D, E2, F, G, H];
      }
      // prettier-ignore
      set(A, B, C2, D, E2, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C2 | 0;
        this.D = D | 0;
        this.E = E2 | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view2, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W[i2] = view2.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W[i2 - 15];
          const W2 = SHA256_W[i2 - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
        }
        let { A, B, C: C2, D, E: E2, F, G, H } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
          const T12 = H + sigma1 + Chi(E2, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C2) | 0;
          H = G;
          G = F;
          F = E2;
          E2 = D + T12 | 0;
          D = C2;
          C2 = B;
          B = A;
          A = T12 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C2 = C2 + this.C | 0;
        D = D + this.D | 0;
        E2 = E2 + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C2, D, E2, F, G, H);
      }
      roundClean() {
        clean(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        clean(this.buffer);
      }
    }, "SHA256");
    __name2(SHA256, "SHA256");
    K512 = /* @__PURE__ */ (() => split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n2) => BigInt(n2))))();
    SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
    SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
    SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    SHA512 = /* @__PURE__ */ __name(class extends HashMD {
      constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        this.Ah = SHA512_IV[0] | 0;
        this.Al = SHA512_IV[1] | 0;
        this.Bh = SHA512_IV[2] | 0;
        this.Bl = SHA512_IV[3] | 0;
        this.Ch = SHA512_IV[4] | 0;
        this.Cl = SHA512_IV[5] | 0;
        this.Dh = SHA512_IV[6] | 0;
        this.Dl = SHA512_IV[7] | 0;
        this.Eh = SHA512_IV[8] | 0;
        this.El = SHA512_IV[9] | 0;
        this.Fh = SHA512_IV[10] | 0;
        this.Fl = SHA512_IV[11] | 0;
        this.Gh = SHA512_IV[12] | 0;
        this.Gl = SHA512_IV[13] | 0;
        this.Hh = SHA512_IV[14] | 0;
        this.Hl = SHA512_IV[15] | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view2, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4) {
          SHA512_W_H[i2] = view2.getUint32(offset);
          SHA512_W_L[i2] = view2.getUint32(offset += 4);
        }
        for (let i2 = 16; i2 < 80; i2++) {
          const W15h = SHA512_W_H[i2 - 15] | 0;
          const W15l = SHA512_W_L[i2 - 15] | 0;
          const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
          const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i2 - 2] | 0;
          const W2l = SHA512_W_L[i2 - 2] | 0;
          const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
          const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
          const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
          const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
          SHA512_W_H[i2] = SUMh | 0;
          SHA512_W_L[i2] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i2 = 0; i2 < 80; i2++) {
          const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
          const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
          const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
          const T1l = T1ll | 0;
          const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
          const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = add3L(T1l, sigma0l, MAJl);
          Ah = add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        clean(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        clean(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }, "SHA512");
    __name2(SHA512, "SHA512");
    SHA384 = /* @__PURE__ */ __name(class extends SHA512 {
      constructor() {
        super(48);
        this.Ah = SHA384_IV[0] | 0;
        this.Al = SHA384_IV[1] | 0;
        this.Bh = SHA384_IV[2] | 0;
        this.Bl = SHA384_IV[3] | 0;
        this.Ch = SHA384_IV[4] | 0;
        this.Cl = SHA384_IV[5] | 0;
        this.Dh = SHA384_IV[6] | 0;
        this.Dl = SHA384_IV[7] | 0;
        this.Eh = SHA384_IV[8] | 0;
        this.El = SHA384_IV[9] | 0;
        this.Fh = SHA384_IV[10] | 0;
        this.Fl = SHA384_IV[11] | 0;
        this.Gh = SHA384_IV[12] | 0;
        this.Gl = SHA384_IV[13] | 0;
        this.Hh = SHA384_IV[14] | 0;
        this.Hl = SHA384_IV[15] | 0;
      }
    }, "SHA384");
    __name2(SHA384, "SHA384");
    sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
    sha512 = /* @__PURE__ */ createHasher(() => new SHA512());
    sha384 = /* @__PURE__ */ createHasher(() => new SHA384());
  }
});
var sha2562;
var init_sha256 = __esm({
  "../node_modules/@noble/hashes/esm/sha256.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sha2();
    sha2562 = sha256;
  }
});
function isBytes2(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
__name(isBytes2, "isBytes2");
function abytes2(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
__name(abytes2, "abytes2");
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
__name(abool, "abool");
function numberToHexUnpadded(num) {
  const hex3 = num.toString(16);
  return hex3.length & 1 ? "0" + hex3 : hex3;
}
__name(numberToHexUnpadded, "numberToHexUnpadded");
function hexToNumber(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  return hex3 === "" ? _0n2 : BigInt("0x" + hex3);
}
__name(hexToNumber, "hexToNumber");
function bytesToHex2(bytes) {
  abytes2(bytes);
  if (hasHexBuiltin2)
    return bytes.toHex();
  let hex3 = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex3 += hexes2[bytes[i2]];
  }
  return hex3;
}
__name(bytesToHex2, "bytesToHex2");
function asciiToBase162(ch) {
  if (ch >= asciis2._0 && ch <= asciis2._9)
    return ch - asciis2._0;
  if (ch >= asciis2.A && ch <= asciis2.F)
    return ch - (asciis2.A - 10);
  if (ch >= asciis2.a && ch <= asciis2.f)
    return ch - (asciis2.a - 10);
  return;
}
__name(asciiToBase162, "asciiToBase162");
function hexToBytes2(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex3);
  const hl = hex3.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex3.charCodeAt(hi));
    const n2 = asciiToBase162(hex3.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex3[hi] + hex3[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
__name(hexToBytes2, "hexToBytes2");
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex2(bytes));
}
__name(bytesToNumberBE, "bytesToNumberBE");
function bytesToNumberLE(bytes) {
  abytes2(bytes);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
__name(bytesToNumberLE, "bytesToNumberLE");
function numberToBytesBE(n2, len) {
  return hexToBytes2(n2.toString(16).padStart(len * 2, "0"));
}
__name(numberToBytesBE, "numberToBytesBE");
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
__name(numberToBytesLE, "numberToBytesLE");
function ensureBytes(title, hex3, expectedLength) {
  let res;
  if (typeof hex3 === "string") {
    try {
      res = hexToBytes2(hex3);
    } catch (e2) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e2);
    }
  } else if (isBytes2(hex3)) {
    res = Uint8Array.from(hex3);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
__name(ensureBytes, "ensureBytes");
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes2(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad3 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad3);
    pad3 += a2.length;
  }
  return res;
}
__name(concatBytes2, "concatBytes2");
function equalBytes(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b2[i2];
  return diff === 0;
}
__name(equalBytes, "equalBytes");
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
__name(utf8ToBytes2, "utf8ToBytes2");
function inRange(n2, min, max) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
}
__name(inRange, "inRange");
function aInRange(title, n2, min, max) {
  if (!inRange(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
__name(aInRange, "aInRange");
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n2; n2 >>= _1n2, len += 1)
    ;
  return len;
}
__name(bitLen, "bitLen");
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n2;
}
__name(bitGet, "bitGet");
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = /* @__PURE__ */ __name2(() => {
    v2.fill(1);
    k.fill(0);
    i2 = 0;
  }, "reset");
  const h2 = /* @__PURE__ */ __name2((...b2) => hmacFn(k, v2, ...b2), "h");
  const reseed = /* @__PURE__ */ __name2((seed = u8n(0)) => {
    k = h2(u8fr([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr([1]), seed);
    v2 = h2();
  }, "reseed");
  const gen2 = /* @__PURE__ */ __name2(() => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl = v2.slice();
      out.push(sl);
      len += v2.length;
    }
    return concatBytes2(...out);
  }, "gen");
  const genUntil = /* @__PURE__ */ __name2((seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  }, "genUntil");
  return genUntil;
}
__name(createHmacDrbg, "createHmacDrbg");
function validateObject(object, validators, optValidators = {}) {
  const checkField = /* @__PURE__ */ __name2((fieldName, type6, isOptional) => {
    const checkVal = validatorFns[type6];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type6 + ", got " + val);
    }
  }, "checkField");
  for (const [fieldName, type6] of Object.entries(validators))
    checkField(fieldName, type6, false);
  for (const [fieldName, type6] of Object.entries(optValidators))
    checkField(fieldName, type6, true);
  return object;
}
__name(validateObject, "validateObject");
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
__name(memoized, "memoized");
var _0n2;
var _1n2;
var hasHexBuiltin2;
var hexes2;
var asciis2;
var isPosBig;
var bitMask;
var u8n;
var u8fr;
var validatorFns;
var notImplemented;
var init_utils3 = __esm({
  "../node_modules/@noble/curves/esm/abstract/utils.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    _0n2 = /* @__PURE__ */ BigInt(0);
    _1n2 = /* @__PURE__ */ BigInt(1);
    __name2(isBytes2, "isBytes");
    __name2(abytes2, "abytes");
    __name2(abool, "abool");
    __name2(numberToHexUnpadded, "numberToHexUnpadded");
    __name2(hexToNumber, "hexToNumber");
    hasHexBuiltin2 = // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function";
    hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
    __name2(bytesToHex2, "bytesToHex");
    asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    __name2(asciiToBase162, "asciiToBase16");
    __name2(hexToBytes2, "hexToBytes");
    __name2(bytesToNumberBE, "bytesToNumberBE");
    __name2(bytesToNumberLE, "bytesToNumberLE");
    __name2(numberToBytesBE, "numberToBytesBE");
    __name2(numberToBytesLE, "numberToBytesLE");
    __name2(ensureBytes, "ensureBytes");
    __name2(concatBytes2, "concatBytes");
    __name2(equalBytes, "equalBytes");
    __name2(utf8ToBytes2, "utf8ToBytes");
    isPosBig = /* @__PURE__ */ __name2((n2) => typeof n2 === "bigint" && _0n2 <= n2, "isPosBig");
    __name2(inRange, "inRange");
    __name2(aInRange, "aInRange");
    __name2(bitLen, "bitLen");
    __name2(bitGet, "bitGet");
    bitMask = /* @__PURE__ */ __name2((n2) => (_1n2 << BigInt(n2)) - _1n2, "bitMask");
    u8n = /* @__PURE__ */ __name2((len) => new Uint8Array(len), "u8n");
    u8fr = /* @__PURE__ */ __name2((arr) => Uint8Array.from(arr), "u8fr");
    __name2(createHmacDrbg, "createHmacDrbg");
    validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    __name2(validateObject, "validateObject");
    notImplemented = /* @__PURE__ */ __name2(() => {
      throw new Error("not implemented");
    }, "notImplemented");
    __name2(memoized, "memoized");
  }
});
function parse(string, reviver) {
  return JSON.parse(string, (key, value_) => {
    const value = value_;
    if (typeof value === "string" && value.endsWith(bigIntSuffix))
      return BigInt(value.slice(0, -bigIntSuffix.length));
    return typeof reviver === "function" ? reviver(key, value) : value;
  });
}
__name(parse, "parse");
function stringify(value, replacer, space) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof replacer === "function")
      return replacer(key, value2);
    if (typeof value2 === "bigint")
      return value2.toString() + bigIntSuffix;
    return value2;
  }, space);
}
__name(stringify, "stringify");
var bigIntSuffix;
var init_Json = __esm({
  "../node_modules/ox/_esm/core/Json.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    bigIntSuffix = "#__bigint";
    __name2(parse, "parse");
    parse.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(stringify, "stringify");
    stringify.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function assertSize(bytes, size_) {
  if (size(bytes) > size_)
    throw new SizeOverflowError({
      givenSize: size(bytes),
      maxSize: size_
    });
}
__name(assertSize, "assertSize");
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size(value)
    });
}
__name(assertStartOffset, "assertStartOffset");
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
__name(assertEndOffset, "assertEndOffset");
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
__name(charCodeToBase16, "charCodeToBase16");
function pad(bytes, options2 = {}) {
  const { dir, size: size3 = 32 } = options2;
  if (size3 === 0)
    return bytes;
  if (bytes.length > size3)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size3,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size3);
  for (let i2 = 0; i2 < size3; i2++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i2 : size3 - i2 - 1] = bytes[padEnd ? i2 : bytes.length - i2 - 1];
  }
  return paddedBytes;
}
__name(pad, "pad");
function trim(value, options2 = {}) {
  const { dir = "left" } = options2;
  let data = value;
  let sliceLength = 0;
  for (let i2 = 0; i2 < data.length - 1; i2++) {
    if (data[dir === "left" ? i2 : data.length - i2 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  return data;
}
__name(trim, "trim");
var charCodeMap;
var init_bytes = __esm({
  "../node_modules/ox/_esm/core/internal/bytes.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    __name2(assertSize, "assertSize");
    __name2(assertStartOffset, "assertStartOffset");
    __name2(assertEndOffset, "assertEndOffset");
    charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
    __name2(charCodeToBase16, "charCodeToBase16");
    __name2(pad, "pad");
    __name2(trim, "trim");
  }
});
function assertSize2(hex3, size_) {
  if (size2(hex3) > size_)
    throw new SizeOverflowError2({
      givenSize: size2(hex3),
      maxSize: size_
    });
}
__name(assertSize2, "assertSize2");
function assertStartOffset2(value, start) {
  if (typeof start === "number" && start > 0 && start > size2(value) - 1)
    throw new SliceOffsetOutOfBoundsError2({
      offset: start,
      position: "start",
      size: size2(value)
    });
}
__name(assertStartOffset2, "assertStartOffset2");
function assertEndOffset2(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size2(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError2({
      offset: end,
      position: "end",
      size: size2(value)
    });
  }
}
__name(assertEndOffset2, "assertEndOffset2");
function pad2(hex_, options2 = {}) {
  const { dir, size: size3 = 32 } = options2;
  if (size3 === 0)
    return hex_;
  const hex3 = hex_.replace("0x", "");
  if (hex3.length > size3 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex3.length / 2),
      targetSize: size3,
      type: "Hex"
    });
  return `0x${hex3[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
}
__name(pad2, "pad2");
function trim2(value, options2 = {}) {
  const { dir = "left" } = options2;
  let data = value.replace("0x", "");
  let sliceLength = 0;
  for (let i2 = 0; i2 < data.length - 1; i2++) {
    if (data[dir === "left" ? i2 : data.length - i2 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (data === "0")
    return "0x";
  if (dir === "right" && data.length % 2 === 1)
    return `0x${data}0`;
  return `0x${data}`;
}
__name(trim2, "trim2");
var init_hex = __esm({
  "../node_modules/ox/_esm/core/internal/hex.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    __name2(assertSize2, "assertSize");
    __name2(assertStartOffset2, "assertStartOffset");
    __name2(assertEndOffset2, "assertEndOffset");
    __name2(pad2, "pad");
    __name2(trim2, "trim");
  }
});
var Hex_exports = {};
__export(Hex_exports, {
  IntegerOutOfRangeError: () => IntegerOutOfRangeError,
  InvalidHexBooleanError: () => InvalidHexBooleanError,
  InvalidHexTypeError: () => InvalidHexTypeError,
  InvalidHexValueError: () => InvalidHexValueError,
  InvalidLengthError: () => InvalidLengthError,
  SizeExceedsPaddingSizeError: () => SizeExceedsPaddingSizeError2,
  SizeOverflowError: () => SizeOverflowError2,
  SliceOffsetOutOfBoundsError: () => SliceOffsetOutOfBoundsError2,
  assert: () => assert,
  concat: () => concat,
  from: () => from2,
  fromBoolean: () => fromBoolean,
  fromBytes: () => fromBytes,
  fromNumber: () => fromNumber,
  fromString: () => fromString,
  isEqual: () => isEqual,
  padLeft: () => padLeft,
  padRight: () => padRight,
  random: () => random2,
  size: () => size2,
  slice: () => slice,
  toBigInt: () => toBigInt,
  toBoolean: () => toBoolean,
  toBytes: () => toBytes2,
  toNumber: () => toNumber,
  toString: () => toString,
  trimLeft: () => trimLeft,
  trimRight: () => trimRight2,
  validate: () => validate
});
function assert(value, options2 = {}) {
  const { strict = false } = options2;
  if (!value)
    throw new InvalidHexTypeError(value);
  if (typeof value !== "string")
    throw new InvalidHexTypeError(value);
  if (strict) {
    if (!/^0x[0-9a-fA-F]*$/.test(value))
      throw new InvalidHexValueError(value);
  }
  if (!value.startsWith("0x"))
    throw new InvalidHexValueError(value);
}
__name(assert, "assert");
function concat(...values) {
  return `0x${values.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
__name(concat, "concat");
function from2(value) {
  if (value instanceof Uint8Array)
    return fromBytes(value);
  if (Array.isArray(value))
    return fromBytes(new Uint8Array(value));
  return value;
}
__name(from2, "from2");
function fromBoolean(value, options2 = {}) {
  const hex3 = `0x${Number(value)}`;
  if (typeof options2.size === "number") {
    assertSize2(hex3, options2.size);
    return padLeft(hex3, options2.size);
  }
  return hex3;
}
__name(fromBoolean, "fromBoolean");
function fromBytes(value, options2 = {}) {
  let string = "";
  for (let i2 = 0; i2 < value.length; i2++)
    string += hexes3[value[i2]];
  const hex3 = `0x${string}`;
  if (typeof options2.size === "number") {
    assertSize2(hex3, options2.size);
    return padRight(hex3, options2.size);
  }
  return hex3;
}
__name(fromBytes, "fromBytes");
function fromNumber(value, options2 = {}) {
  const { signed: signed2, size: size3 } = options2;
  const value_ = BigInt(value);
  let maxValue;
  if (size3) {
    if (signed2)
      maxValue = (1n << BigInt(size3) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size3) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed2 ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size3,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed2 && value_ < 0 ? (1n << BigInt(size3 * 8)) + BigInt(value_) : value_).toString(16);
  const hex3 = `0x${stringValue}`;
  if (size3)
    return padLeft(hex3, size3);
  return hex3;
}
__name(fromNumber, "fromNumber");
function fromString(value, options2 = {}) {
  return fromBytes(encoder.encode(value), options2);
}
__name(fromString, "fromString");
function isEqual(hexA, hexB) {
  return equalBytes(fromHex(hexA), fromHex(hexB));
}
__name(isEqual, "isEqual");
function padLeft(value, size3) {
  return pad2(value, { dir: "left", size: size3 });
}
__name(padLeft, "padLeft");
function padRight(value, size3) {
  return pad2(value, { dir: "right", size: size3 });
}
__name(padRight, "padRight");
function random2(length) {
  return fromBytes(random(length));
}
__name(random2, "random2");
function slice(value, start, end, options2 = {}) {
  const { strict } = options2;
  assertStartOffset2(value, start);
  const value_ = `0x${value.replace("0x", "").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
  if (strict)
    assertEndOffset2(value_, start, end);
  return value_;
}
__name(slice, "slice");
function size2(value) {
  return Math.ceil((value.length - 2) / 2);
}
__name(size2, "size2");
function trimLeft(value) {
  return trim2(value, { dir: "left" });
}
__name(trimLeft, "trimLeft");
function trimRight2(value) {
  return trim2(value, { dir: "right" });
}
__name(trimRight2, "trimRight2");
function toBigInt(hex3, options2 = {}) {
  const { signed: signed2 } = options2;
  if (options2.size)
    assertSize2(hex3, options2.size);
  const value = BigInt(hex3);
  if (!signed2)
    return value;
  const size3 = (hex3.length - 2) / 2;
  const max_unsigned = (1n << BigInt(size3) * 8n) - 1n;
  const max_signed = max_unsigned >> 1n;
  if (value <= max_signed)
    return value;
  return value - max_unsigned - 1n;
}
__name(toBigInt, "toBigInt");
function toBoolean(hex3, options2 = {}) {
  if (options2.size)
    assertSize2(hex3, options2.size);
  const hex_ = trimLeft(hex3);
  if (hex_ === "0x")
    return false;
  if (hex_ === "0x1")
    return true;
  throw new InvalidHexBooleanError(hex3);
}
__name(toBoolean, "toBoolean");
function toBytes2(hex3, options2 = {}) {
  return fromHex(hex3, options2);
}
__name(toBytes2, "toBytes2");
function toNumber(hex3, options2 = {}) {
  const { signed: signed2, size: size3 } = options2;
  if (!signed2 && !size3)
    return Number(hex3);
  return Number(toBigInt(hex3, options2));
}
__name(toNumber, "toNumber");
function toString(hex3, options2 = {}) {
  const { size: size3 } = options2;
  let bytes = fromHex(hex3);
  if (size3) {
    assertSize(bytes, size3);
    bytes = trimRight(bytes);
  }
  return new TextDecoder().decode(bytes);
}
__name(toString, "toString");
function validate(value, options2 = {}) {
  const { strict = false } = options2;
  try {
    assert(value, { strict });
    return true;
  } catch {
    return false;
  }
}
__name(validate, "validate");
var encoder;
var hexes3;
var IntegerOutOfRangeError;
var InvalidHexBooleanError;
var InvalidHexTypeError;
var InvalidHexValueError;
var InvalidLengthError;
var SizeOverflowError2;
var SliceOffsetOutOfBoundsError2;
var SizeExceedsPaddingSizeError2;
var init_Hex = __esm({
  "../node_modules/ox/_esm/core/Hex.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_utils3();
    init_Bytes();
    init_Errors();
    init_Json();
    init_bytes();
    init_hex();
    encoder = /* @__PURE__ */ new TextEncoder();
    hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i2) => i2.toString(16).padStart(2, "0"));
    __name2(assert, "assert");
    assert.parseError = (error) => error;
    __name2(concat, "concat");
    concat.parseError = (error) => error;
    __name2(from2, "from");
    from2.parseError = (error) => error;
    __name2(fromBoolean, "fromBoolean");
    fromBoolean.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromBytes, "fromBytes");
    fromBytes.parseError = (error) => error;
    __name2(fromNumber, "fromNumber");
    fromNumber.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromString, "fromString");
    fromString.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(isEqual, "isEqual");
    isEqual.parseError = (error) => error;
    __name2(padLeft, "padLeft");
    padLeft.parseError = (error) => error;
    __name2(padRight, "padRight");
    padRight.parseError = (error) => error;
    __name2(random2, "random");
    random2.parseError = (error) => error;
    __name2(slice, "slice");
    slice.parseError = (error) => error;
    __name2(size2, "size");
    size2.parseError = (error) => error;
    __name2(trimLeft, "trimLeft");
    trimLeft.parseError = (error) => error;
    __name2(trimRight2, "trimRight");
    trimRight2.parseError = (error) => error;
    __name2(toBigInt, "toBigInt");
    toBigInt.parseError = (error) => error;
    __name2(toBoolean, "toBoolean");
    toBoolean.parseError = (error) => error;
    __name2(toBytes2, "toBytes");
    toBytes2.parseError = (error) => error;
    __name2(toNumber, "toNumber");
    toNumber.parseError = (error) => error;
    __name2(toString, "toString");
    toString.parseError = (error) => error;
    __name2(validate, "validate");
    validate.parseError = (error) => error;
    IntegerOutOfRangeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ max, min, signed: signed2, size: size3, value }) {
        super(`Number \`${value}\` is not in safe${size3 ? ` ${size3 * 8}-bit` : ""}${signed2 ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.IntegerOutOfRangeError"
        });
      }
    }, "IntegerOutOfRangeError");
    __name2(IntegerOutOfRangeError, "IntegerOutOfRangeError");
    InvalidHexBooleanError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(hex3) {
        super(`Hex value \`"${hex3}"\` is not a valid boolean.`, {
          metaMessages: [
            'The hex value must be `"0x0"` (false) or `"0x1"` (true).'
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.InvalidHexBooleanError"
        });
      }
    }, "InvalidHexBooleanError");
    __name2(InvalidHexBooleanError, "InvalidHexBooleanError");
    InvalidHexTypeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(value) {
        super(`Value \`${typeof value === "object" ? stringify(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
          metaMessages: ['Hex types must be represented as `"0x${string}"`.']
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.InvalidHexTypeError"
        });
      }
    }, "InvalidHexTypeError");
    __name2(InvalidHexTypeError, "InvalidHexTypeError");
    InvalidHexValueError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(value) {
        super(`Value \`${value}\` is an invalid hex value.`, {
          metaMessages: [
            'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.InvalidHexValueError"
        });
      }
    }, "InvalidHexValueError");
    __name2(InvalidHexValueError, "InvalidHexValueError");
    InvalidLengthError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(value) {
        super(`Hex value \`"${value}"\` is an odd length (${value.length - 2} nibbles).`, {
          metaMessages: ["It must be an even length."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.InvalidLengthError"
        });
      }
    }, "InvalidLengthError");
    __name2(InvalidLengthError, "InvalidLengthError");
    SizeOverflowError2 = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.SizeOverflowError"
        });
      }
    }, "SizeOverflowError2");
    __name2(SizeOverflowError2, "SizeOverflowError");
    SliceOffsetOutOfBoundsError2 = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ offset, position, size: size3 }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size3}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.SliceOffsetOutOfBoundsError"
        });
      }
    }, "SliceOffsetOutOfBoundsError2");
    __name2(SliceOffsetOutOfBoundsError2, "SliceOffsetOutOfBoundsError");
    SizeExceedsPaddingSizeError2 = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ size: size3, targetSize, type: type6 }) {
        super(`${type6.charAt(0).toUpperCase()}${type6.slice(1).toLowerCase()} size (\`${size3}\`) exceeds padding size (\`${targetSize}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Hex.SizeExceedsPaddingSizeError"
        });
      }
    }, "SizeExceedsPaddingSizeError2");
    __name2(SizeExceedsPaddingSizeError2, "SizeExceedsPaddingSizeError");
  }
});
var Bytes_exports = {};
__export(Bytes_exports, {
  InvalidBytesBooleanError: () => InvalidBytesBooleanError,
  InvalidBytesTypeError: () => InvalidBytesTypeError,
  SizeExceedsPaddingSizeError: () => SizeExceedsPaddingSizeError,
  SizeOverflowError: () => SizeOverflowError,
  SliceOffsetOutOfBoundsError: () => SliceOffsetOutOfBoundsError,
  assert: () => assert2,
  concat: () => concat2,
  from: () => from3,
  fromArray: () => fromArray,
  fromBoolean: () => fromBoolean2,
  fromHex: () => fromHex,
  fromNumber: () => fromNumber2,
  fromString: () => fromString2,
  isEqual: () => isEqual2,
  padLeft: () => padLeft2,
  padRight: () => padRight2,
  random: () => random,
  size: () => size,
  slice: () => slice2,
  toBigInt: () => toBigInt2,
  toBoolean: () => toBoolean2,
  toHex: () => toHex,
  toNumber: () => toNumber2,
  toString: () => toString2,
  trimLeft: () => trimLeft2,
  trimRight: () => trimRight,
  validate: () => validate2
});
function assert2(value) {
  if (value instanceof Uint8Array)
    return;
  if (!value)
    throw new InvalidBytesTypeError(value);
  if (typeof value !== "object")
    throw new InvalidBytesTypeError(value);
  if (!("BYTES_PER_ELEMENT" in value))
    throw new InvalidBytesTypeError(value);
  if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== "Uint8Array")
    throw new InvalidBytesTypeError(value);
}
__name(assert2, "assert2");
function concat2(...values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  for (let i2 = 0, index = 0; i2 < values.length; i2++) {
    const arr = values[i2];
    result.set(arr, index);
    index += arr.length;
  }
  return result;
}
__name(concat2, "concat2");
function from3(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex(value);
  return fromArray(value);
}
__name(from3, "from3");
function fromArray(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
__name(fromArray, "fromArray");
function fromBoolean2(value, options2 = {}) {
  const { size: size3 } = options2;
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof size3 === "number") {
    assertSize(bytes, size3);
    return padLeft2(bytes, size3);
  }
  return bytes;
}
__name(fromBoolean2, "fromBoolean2");
function fromHex(value, options2 = {}) {
  const { size: size3 } = options2;
  let hex3 = value;
  if (size3) {
    assertSize2(value, size3);
    hex3 = padRight(value, size3);
  }
  let hexString = hex3.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j2 = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError2(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
__name(fromHex, "fromHex");
function fromNumber2(value, options2) {
  const hex3 = fromNumber(value, options2);
  return fromHex(hex3);
}
__name(fromNumber2, "fromNumber2");
function fromString2(value, options2 = {}) {
  const { size: size3 } = options2;
  const bytes = encoder2.encode(value);
  if (typeof size3 === "number") {
    assertSize(bytes, size3);
    return padRight2(bytes, size3);
  }
  return bytes;
}
__name(fromString2, "fromString2");
function isEqual2(bytesA, bytesB) {
  return equalBytes(bytesA, bytesB);
}
__name(isEqual2, "isEqual2");
function padLeft2(value, size3) {
  return pad(value, { dir: "left", size: size3 });
}
__name(padLeft2, "padLeft2");
function padRight2(value, size3) {
  return pad(value, { dir: "right", size: size3 });
}
__name(padRight2, "padRight2");
function random(length) {
  return crypto.getRandomValues(new Uint8Array(length));
}
__name(random, "random");
function size(value) {
  return value.length;
}
__name(size, "size");
function slice2(value, start, end, options2 = {}) {
  const { strict } = options2;
  assertStartOffset(value, start);
  const value_ = value.slice(start, end);
  if (strict)
    assertEndOffset(value_, start, end);
  return value_;
}
__name(slice2, "slice2");
function toBigInt2(bytes, options2 = {}) {
  const { size: size3 } = options2;
  if (typeof size3 !== "undefined")
    assertSize(bytes, size3);
  const hex3 = fromBytes(bytes, options2);
  return toBigInt(hex3, options2);
}
__name(toBigInt2, "toBigInt2");
function toBoolean2(bytes, options2 = {}) {
  const { size: size3 } = options2;
  let bytes_ = bytes;
  if (typeof size3 !== "undefined") {
    assertSize(bytes_, size3);
    bytes_ = trimLeft2(bytes_);
  }
  if (bytes_.length > 1 || bytes_[0] > 1)
    throw new InvalidBytesBooleanError(bytes_);
  return Boolean(bytes_[0]);
}
__name(toBoolean2, "toBoolean2");
function toHex(value, options2 = {}) {
  return fromBytes(value, options2);
}
__name(toHex, "toHex");
function toNumber2(bytes, options2 = {}) {
  const { size: size3 } = options2;
  if (typeof size3 !== "undefined")
    assertSize(bytes, size3);
  const hex3 = fromBytes(bytes, options2);
  return toNumber(hex3, options2);
}
__name(toNumber2, "toNumber2");
function toString2(bytes, options2 = {}) {
  const { size: size3 } = options2;
  let bytes_ = bytes;
  if (typeof size3 !== "undefined") {
    assertSize(bytes_, size3);
    bytes_ = trimRight(bytes_);
  }
  return decoder.decode(bytes_);
}
__name(toString2, "toString2");
function trimLeft2(value) {
  return trim(value, { dir: "left" });
}
__name(trimLeft2, "trimLeft2");
function trimRight(value) {
  return trim(value, { dir: "right" });
}
__name(trimRight, "trimRight");
function validate2(value) {
  try {
    assert2(value);
    return true;
  } catch {
    return false;
  }
}
__name(validate2, "validate2");
var decoder;
var encoder2;
var InvalidBytesBooleanError;
var InvalidBytesTypeError;
var SizeOverflowError;
var SliceOffsetOutOfBoundsError;
var SizeExceedsPaddingSizeError;
var init_Bytes = __esm({
  "../node_modules/ox/_esm/core/Bytes.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_utils3();
    init_Errors();
    init_Hex();
    init_Json();
    init_bytes();
    init_hex();
    decoder = /* @__PURE__ */ new TextDecoder();
    encoder2 = /* @__PURE__ */ new TextEncoder();
    __name2(assert2, "assert");
    assert2.parseError = (error) => error;
    __name2(concat2, "concat");
    concat2.parseError = (error) => error;
    __name2(from3, "from");
    from3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromArray, "fromArray");
    fromArray.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromBoolean2, "fromBoolean");
    fromBoolean2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromHex, "fromHex");
    fromHex.parseError = (error) => error;
    __name2(fromNumber2, "fromNumber");
    fromNumber2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromString2, "fromString");
    fromString2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(isEqual2, "isEqual");
    isEqual2.parseError = (error) => error;
    __name2(padLeft2, "padLeft");
    padLeft2.parseError = (error) => error;
    __name2(padRight2, "padRight");
    padRight2.parseError = (error) => error;
    __name2(random, "random");
    random.parseError = (error) => error;
    __name2(size, "size");
    size.parseError = (error) => error;
    __name2(slice2, "slice");
    slice2.parseError = (error) => error;
    __name2(toBigInt2, "toBigInt");
    toBigInt2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toBoolean2, "toBoolean");
    toBoolean2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toHex, "toHex");
    toHex.parseError = (error) => error;
    __name2(toNumber2, "toNumber");
    toNumber2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toString2, "toString");
    toString2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(trimLeft2, "trimLeft");
    trimLeft2.parseError = (error) => error;
    __name2(trimRight, "trimRight");
    trimRight.parseError = (error) => error;
    __name2(validate2, "validate");
    validate2.parseError = (error) => error;
    InvalidBytesBooleanError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(bytes) {
        super(`Bytes value \`${bytes}\` is not a valid boolean.`, {
          metaMessages: [
            "The bytes array must contain a single byte of either a `0` or `1` value."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Bytes.InvalidBytesBooleanError"
        });
      }
    }, "InvalidBytesBooleanError");
    __name2(InvalidBytesBooleanError, "InvalidBytesBooleanError");
    InvalidBytesTypeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(value) {
        super(`Value \`${typeof value === "object" ? stringify(value) : value}\` of type \`${typeof value}\` is an invalid Bytes value.`, {
          metaMessages: ["Bytes values must be of type `Bytes`."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Bytes.InvalidBytesTypeError"
        });
      }
    }, "InvalidBytesTypeError");
    __name2(InvalidBytesTypeError, "InvalidBytesTypeError");
    SizeOverflowError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Bytes.SizeOverflowError"
        });
      }
    }, "SizeOverflowError");
    __name2(SizeOverflowError, "SizeOverflowError");
    SliceOffsetOutOfBoundsError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ offset, position, size: size3 }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size3}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Bytes.SliceOffsetOutOfBoundsError"
        });
      }
    }, "SliceOffsetOutOfBoundsError");
    __name2(SliceOffsetOutOfBoundsError, "SliceOffsetOutOfBoundsError");
    SizeExceedsPaddingSizeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ size: size3, targetSize, type: type6 }) {
        super(`${type6.charAt(0).toUpperCase()}${type6.slice(1).toLowerCase()} size (\`${size3}\`) exceeds padding size (\`${targetSize}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Bytes.SizeExceedsPaddingSizeError"
        });
      }
    }, "SizeExceedsPaddingSizeError");
    __name2(SizeExceedsPaddingSizeError, "SizeExceedsPaddingSizeError");
  }
});
var Hash_exports = {};
__export(Hash_exports, {
  keccak256: () => keccak256,
  ripemd160: () => ripemd1603,
  sha256: () => sha2563,
  validate: () => validate3
});
function keccak256(value, options2 = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options2;
  const bytes = keccak_256(from3(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes(bytes);
}
__name(keccak256, "keccak256");
function ripemd1603(value, options2 = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options2;
  const bytes = ripemd1602(from3(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes(bytes);
}
__name(ripemd1603, "ripemd1603");
function sha2563(value, options2 = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options2;
  const bytes = sha2562(from3(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes(bytes);
}
__name(sha2563, "sha2563");
function validate3(value) {
  return validate(value) && size2(value) === 32;
}
__name(validate3, "validate3");
var init_Hash = __esm({
  "../node_modules/ox/_esm/core/Hash.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_ripemd160();
    init_sha3();
    init_sha256();
    init_Bytes();
    init_Hex();
    __name2(keccak256, "keccak256");
    keccak256.parseError = (error) => error;
    __name2(ripemd1603, "ripemd160");
    ripemd1603.parseError = (error) => error;
    __name2(sha2563, "sha256");
    sha2563.parseError = (error) => error;
    __name2(validate3, "validate");
    validate3.parseError = (error) => error;
  }
});
var LruMap;
var init_lru = __esm({
  "../node_modules/ox/_esm/core/internal/lru.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    LruMap = /* @__PURE__ */ __name(class extends Map {
      constructor(size3) {
        super();
        Object.defineProperty(this, "maxSize", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.maxSize = size3;
      }
      get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== void 0) {
          this.delete(key);
          super.set(key, value);
        }
        return value;
      }
      set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
          const firstKey = this.keys().next().value;
          if (firstKey)
            this.delete(firstKey);
        }
        return this;
      }
    }, "LruMap");
    __name2(LruMap, "LruMap");
  }
});
var caches;
var checksum;
var init_Caches = __esm({
  "../node_modules/ox/_esm/core/Caches.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_lru();
    caches = {
      checksum: /* @__PURE__ */ new LruMap(8192)
    };
    checksum = caches.checksum;
  }
});
function assert3(publicKey, options2 = {}) {
  const { compressed } = options2;
  const { prefix, x: x2, y: y2 } = publicKey;
  if (compressed === false || typeof x2 === "bigint" && typeof y2 === "bigint") {
    if (prefix !== 4)
      throw new InvalidPrefixError({
        prefix,
        cause: new InvalidUncompressedPrefixError()
      });
    return;
  }
  if (compressed === true || typeof x2 === "bigint" && typeof y2 === "undefined") {
    if (prefix !== 3 && prefix !== 2)
      throw new InvalidPrefixError({
        prefix,
        cause: new InvalidCompressedPrefixError()
      });
    return;
  }
  throw new InvalidError({ publicKey });
}
__name(assert3, "assert3");
function compress(publicKey) {
  const { x: x2, y: y2 } = publicKey;
  return {
    prefix: y2 % 2n === 0n ? 2 : 3,
    x: x2
  };
}
__name(compress, "compress");
function from4(value) {
  const publicKey = (() => {
    if (validate(value))
      return fromHex2(value);
    if (validate2(value))
      return fromBytes2(value);
    const { prefix, x: x2, y: y2 } = value;
    if (typeof x2 === "bigint" && typeof y2 === "bigint")
      return { prefix: prefix ?? 4, x: x2, y: y2 };
    return { prefix, x: x2 };
  })();
  assert3(publicKey);
  return publicKey;
}
__name(from4, "from4");
function fromBytes2(publicKey) {
  return fromHex2(fromBytes(publicKey));
}
__name(fromBytes2, "fromBytes2");
function fromHex2(publicKey) {
  if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68)
    throw new InvalidSerializedSizeError({ publicKey });
  if (publicKey.length === 130) {
    const x3 = BigInt(slice(publicKey, 0, 32));
    const y2 = BigInt(slice(publicKey, 32, 64));
    return {
      prefix: 4,
      x: x3,
      y: y2
    };
  }
  if (publicKey.length === 132) {
    const prefix2 = Number(slice(publicKey, 0, 1));
    const x3 = BigInt(slice(publicKey, 1, 33));
    const y2 = BigInt(slice(publicKey, 33, 65));
    return {
      prefix: prefix2,
      x: x3,
      y: y2
    };
  }
  const prefix = Number(slice(publicKey, 0, 1));
  const x2 = BigInt(slice(publicKey, 1, 33));
  return {
    prefix,
    x: x2
  };
}
__name(fromHex2, "fromHex2");
function toBytes3(publicKey, options2 = {}) {
  return fromHex(toHex2(publicKey, options2));
}
__name(toBytes3, "toBytes3");
function toHex2(publicKey, options2 = {}) {
  assert3(publicKey);
  const { prefix, x: x2, y: y2 } = publicKey;
  const { includePrefix = true } = options2;
  const publicKey_ = concat(
    includePrefix ? fromNumber(prefix, { size: 1 }) : "0x",
    fromNumber(x2, { size: 32 }),
    // If the public key is not compressed, add the y coordinate.
    typeof y2 === "bigint" ? fromNumber(y2, { size: 32 }) : "0x"
  );
  return publicKey_;
}
__name(toHex2, "toHex2");
var InvalidError;
var InvalidPrefixError;
var InvalidCompressedPrefixError;
var InvalidUncompressedPrefixError;
var InvalidSerializedSizeError;
var init_PublicKey = __esm({
  "../node_modules/ox/_esm/core/PublicKey.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Errors();
    init_Hex();
    init_Json();
    __name2(assert3, "assert");
    __name2(compress, "compress");
    compress.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from4, "from");
    from4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromBytes2, "fromBytes");
    fromBytes2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromHex2, "fromHex");
    fromHex2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toBytes3, "toBytes");
    toBytes3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toHex2, "toHex");
    toHex2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    InvalidError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ publicKey }) {
        super(`Value \`${stringify(publicKey)}\` is not a valid public key.`, {
          metaMessages: [
            "Public key must contain:",
            "- an `x` and `prefix` value (compressed)",
            "- an `x`, `y`, and `prefix` value (uncompressed)"
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "PublicKey.InvalidError"
        });
      }
    }, "InvalidError");
    __name2(InvalidError, "InvalidError");
    InvalidPrefixError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ prefix, cause }) {
        super(`Prefix "${prefix}" is invalid.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "PublicKey.InvalidPrefixError"
        });
      }
    }, "InvalidPrefixError");
    __name2(InvalidPrefixError, "InvalidPrefixError");
    InvalidCompressedPrefixError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("Prefix must be 2 or 3 for compressed public keys.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "PublicKey.InvalidCompressedPrefixError"
        });
      }
    }, "InvalidCompressedPrefixError");
    __name2(InvalidCompressedPrefixError, "InvalidCompressedPrefixError");
    InvalidUncompressedPrefixError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("Prefix must be 4 for uncompressed public keys.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "PublicKey.InvalidUncompressedPrefixError"
        });
      }
    }, "InvalidUncompressedPrefixError");
    __name2(InvalidUncompressedPrefixError, "InvalidUncompressedPrefixError");
    InvalidSerializedSizeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ publicKey }) {
        super(`Value \`${publicKey}\` is an invalid public key size.`, {
          metaMessages: [
            "Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",
            `Received ${size2(from2(publicKey))} bytes.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "PublicKey.InvalidSerializedSizeError"
        });
      }
    }, "InvalidSerializedSizeError");
    __name2(InvalidSerializedSizeError, "InvalidSerializedSizeError");
  }
});
function assert4(value, options2 = {}) {
  const { strict = true } = options2;
  if (!addressRegex.test(value))
    throw new InvalidAddressError({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
__name(assert4, "assert4");
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert4(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash7 = keccak256(fromString2(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hash7[i2 >> 1] >> 4 >= 8 && characters[i2]) {
      characters[i2] = characters[i2].toUpperCase();
    }
    if ((hash7[i2 >> 1] & 15) >= 8 && characters[i2 + 1]) {
      characters[i2 + 1] = characters[i2 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
__name(checksum2, "checksum2");
function from5(address, options2 = {}) {
  const { checksum: checksumVal = false } = options2;
  assert4(address);
  if (checksumVal)
    return checksum2(address);
  return address;
}
__name(from5, "from5");
function fromPublicKey(publicKey, options2 = {}) {
  const address = keccak256(`0x${toHex2(publicKey).slice(4)}`).substring(26);
  return from5(`0x${address}`, options2);
}
__name(fromPublicKey, "fromPublicKey");
function isEqual3(addressA, addressB) {
  assert4(addressA, { strict: false });
  assert4(addressB, { strict: false });
  return addressA.toLowerCase() === addressB.toLowerCase();
}
__name(isEqual3, "isEqual3");
function validate4(address, options2 = {}) {
  const { strict = true } = options2 ?? {};
  try {
    assert4(address, { strict });
    return true;
  } catch {
    return false;
  }
}
__name(validate4, "validate4");
var addressRegex;
var InvalidAddressError;
var InvalidInputError;
var InvalidChecksumError;
var init_Address = __esm({
  "../node_modules/ox/_esm/core/Address.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Caches();
    init_Errors();
    init_Hash();
    init_PublicKey();
    addressRegex = /^0x[a-fA-F0-9]{40}$/;
    __name2(assert4, "assert");
    assert4.parseError = (error) => error;
    __name2(checksum2, "checksum");
    checksum2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from5, "from");
    from5.parseError = (error) => error;
    __name2(fromPublicKey, "fromPublicKey");
    fromPublicKey.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(isEqual3, "isEqual");
    isEqual3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate4, "validate");
    InvalidAddressError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ address, cause }) {
        super(`Address "${address}" is invalid.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Address.InvalidAddressError"
        });
      }
    }, "InvalidAddressError");
    __name2(InvalidAddressError, "InvalidAddressError");
    InvalidInputError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("Address is not a 20 byte (40 hexadecimal character) value.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Address.InvalidInputError"
        });
      }
    }, "InvalidInputError");
    __name2(InvalidInputError, "InvalidInputError");
    InvalidChecksumError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("Address does not match its checksum counterpart.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Address.InvalidChecksumError"
        });
      }
    }, "InvalidChecksumError");
    __name2(InvalidChecksumError, "InvalidChecksumError");
  }
});
function normalizeSignature(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i2 = 0; i2 < signature.length; i2++) {
    const char = signature[i2];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", "error", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i2 - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError2("Unable to normalize signature.");
  return result;
}
__name(normalizeSignature, "normalizeSignature");
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return validate4(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index) => {
          return isArgOfType(Object.values(arg)[index], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x2) => isArgOfType(x2, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
__name(isArgOfType, "isArgOfType");
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return validate4(args[parameterIndex], {
          strict: false
        });
      if (types.includes("address") && types.includes("bytes"))
        return validate4(args[parameterIndex], {
          strict: false
        });
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}
__name(getAmbiguousTypes, "getAmbiguousTypes");
var init_abiItem2 = __esm({
  "../node_modules/ox/_esm/core/internal/abiItem.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Address();
    init_Errors();
    __name2(normalizeSignature, "normalizeSignature");
    __name2(isArgOfType, "isArgOfType");
    __name2(getAmbiguousTypes, "getAmbiguousTypes");
  }
});
function format2(abiItem) {
  return formatAbiItem(abiItem);
}
__name(format2, "format2");
function from6(abiItem, options2 = {}) {
  const { prepare = true } = options2;
  const item = (() => {
    if (Array.isArray(abiItem))
      return parseAbiItem(abiItem);
    if (typeof abiItem === "string")
      return parseAbiItem(abiItem);
    return abiItem;
  })();
  return {
    ...item,
    ...prepare ? { hash: getSignatureHash(item) } : {}
  };
}
__name(from6, "from6");
function fromAbi(abi, name, options2) {
  const { args = [], prepare = true } = options2 ?? {};
  const isSelector = validate(name, { strict: false });
  const abiItems = abi.filter((abiItem2) => {
    if (isSelector) {
      if (abiItem2.type === "function" || abiItem2.type === "error")
        return getSelector(abiItem2) === slice(name, 0, 4);
      if (abiItem2.type === "event")
        return getSignatureHash(abiItem2) === name;
      return false;
    }
    return "name" in abiItem2 && abiItem2.name === name;
  });
  if (abiItems.length === 0)
    throw new NotFoundError({ name });
  if (abiItems.length === 1)
    return {
      ...abiItems[0],
      ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}
    };
  let matchedAbiItem = void 0;
  for (const abiItem2 of abiItems) {
    if (!("inputs" in abiItem2))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem2.inputs || abiItem2.inputs.length === 0)
        return {
          ...abiItem2,
          ...prepare ? { hash: getSignatureHash(abiItem2) } : {}
        };
      continue;
    }
    if (!abiItem2.inputs)
      continue;
    if (abiItem2.inputs.length === 0)
      continue;
    if (abiItem2.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index) => {
      const abiParameter = "inputs" in abiItem2 && abiItem2.inputs[index];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem2.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AmbiguityError({
            abiItem: abiItem2,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem2;
    }
  }
  const abiItem = (() => {
    if (matchedAbiItem)
      return matchedAbiItem;
    const [abiItem2, ...overloads] = abiItems;
    return { ...abiItem2, overloads };
  })();
  if (!abiItem)
    throw new NotFoundError({ name });
  return {
    ...abiItem,
    ...prepare ? { hash: getSignatureHash(abiItem) } : {}
  };
}
__name(fromAbi, "fromAbi");
function getSelector(abiItem) {
  return slice(getSignatureHash(abiItem), 0, 4);
}
__name(getSelector, "getSelector");
function getSignature(abiItem) {
  const signature = (() => {
    if (typeof abiItem === "string")
      return abiItem;
    return formatAbiItem(abiItem);
  })();
  return normalizeSignature(signature);
}
__name(getSignature, "getSignature");
function getSignatureHash(abiItem) {
  if (typeof abiItem !== "string" && "hash" in abiItem && abiItem.hash)
    return abiItem.hash;
  return keccak256(fromString(getSignature(abiItem)));
}
__name(getSignatureHash, "getSignatureHash");
var AmbiguityError;
var NotFoundError;
var init_AbiItem = __esm({
  "../node_modules/ox/_esm/core/AbiItem.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_exports();
    init_Errors();
    init_Hash();
    init_Hex();
    init_abiItem2();
    __name2(format2, "format");
    format2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from6, "from");
    from6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromAbi, "fromAbi");
    fromAbi.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSelector, "getSelector");
    getSelector.parseError = (error) => error;
    __name2(getSignature, "getSignature");
    getSignature.parseError = (error) => error;
    __name2(getSignatureHash, "getSignatureHash");
    getSignatureHash.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    AmbiguityError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(x2, y2) {
        super("Found ambiguous types in overloaded ABI Items.", {
          metaMessages: [
            // TODO: abitype to add support for signature-formatted ABI items.
            `\`${x2.type}\` in \`${normalizeSignature(formatAbiItem(x2.abiItem))}\`, and`,
            `\`${y2.type}\` in \`${normalizeSignature(formatAbiItem(y2.abiItem))}\``,
            "",
            "These types encode differently and cannot be distinguished at runtime.",
            "Remove one of the ambiguous items in the ABI."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiItem.AmbiguityError"
        });
      }
    }, "AmbiguityError");
    __name2(AmbiguityError, "AmbiguityError");
    NotFoundError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ name, data, type: type6 = "item" }) {
        const selector = (() => {
          if (name)
            return ` with name "${name}"`;
          if (data)
            return ` with data "${data}"`;
          return "";
        })();
        super(`ABI ${type6}${selector} not found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiItem.NotFoundError"
        });
      }
    }, "NotFoundError");
    __name2(NotFoundError, "NotFoundError");
  }
});
var arrayRegex;
var bytesRegex2;
var integerRegex2;
var maxInt8;
var maxInt16;
var maxInt24;
var maxInt32;
var maxInt40;
var maxInt48;
var maxInt56;
var maxInt64;
var maxInt72;
var maxInt80;
var maxInt88;
var maxInt96;
var maxInt104;
var maxInt112;
var maxInt120;
var maxInt128;
var maxInt136;
var maxInt144;
var maxInt152;
var maxInt160;
var maxInt168;
var maxInt176;
var maxInt184;
var maxInt192;
var maxInt200;
var maxInt208;
var maxInt216;
var maxInt224;
var maxInt232;
var maxInt240;
var maxInt248;
var maxInt256;
var minInt8;
var minInt16;
var minInt24;
var minInt32;
var minInt40;
var minInt48;
var minInt56;
var minInt64;
var minInt72;
var minInt80;
var minInt88;
var minInt96;
var minInt104;
var minInt112;
var minInt120;
var minInt128;
var minInt136;
var minInt144;
var minInt152;
var minInt160;
var minInt168;
var minInt176;
var minInt184;
var minInt192;
var minInt200;
var minInt208;
var minInt216;
var minInt224;
var minInt232;
var minInt240;
var minInt248;
var minInt256;
var maxUint8;
var maxUint16;
var maxUint24;
var maxUint32;
var maxUint40;
var maxUint48;
var maxUint56;
var maxUint64;
var maxUint72;
var maxUint80;
var maxUint88;
var maxUint96;
var maxUint104;
var maxUint112;
var maxUint120;
var maxUint128;
var maxUint136;
var maxUint144;
var maxUint152;
var maxUint160;
var maxUint168;
var maxUint176;
var maxUint184;
var maxUint192;
var maxUint200;
var maxUint208;
var maxUint216;
var maxUint224;
var maxUint232;
var maxUint240;
var maxUint248;
var maxUint256;
var init_Solidity = __esm({
  "../node_modules/ox/_esm/core/Solidity.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    arrayRegex = /^(.*)\[([0-9]*)\]$/;
    bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    maxInt8 = 2n ** (8n - 1n) - 1n;
    maxInt16 = 2n ** (16n - 1n) - 1n;
    maxInt24 = 2n ** (24n - 1n) - 1n;
    maxInt32 = 2n ** (32n - 1n) - 1n;
    maxInt40 = 2n ** (40n - 1n) - 1n;
    maxInt48 = 2n ** (48n - 1n) - 1n;
    maxInt56 = 2n ** (56n - 1n) - 1n;
    maxInt64 = 2n ** (64n - 1n) - 1n;
    maxInt72 = 2n ** (72n - 1n) - 1n;
    maxInt80 = 2n ** (80n - 1n) - 1n;
    maxInt88 = 2n ** (88n - 1n) - 1n;
    maxInt96 = 2n ** (96n - 1n) - 1n;
    maxInt104 = 2n ** (104n - 1n) - 1n;
    maxInt112 = 2n ** (112n - 1n) - 1n;
    maxInt120 = 2n ** (120n - 1n) - 1n;
    maxInt128 = 2n ** (128n - 1n) - 1n;
    maxInt136 = 2n ** (136n - 1n) - 1n;
    maxInt144 = 2n ** (144n - 1n) - 1n;
    maxInt152 = 2n ** (152n - 1n) - 1n;
    maxInt160 = 2n ** (160n - 1n) - 1n;
    maxInt168 = 2n ** (168n - 1n) - 1n;
    maxInt176 = 2n ** (176n - 1n) - 1n;
    maxInt184 = 2n ** (184n - 1n) - 1n;
    maxInt192 = 2n ** (192n - 1n) - 1n;
    maxInt200 = 2n ** (200n - 1n) - 1n;
    maxInt208 = 2n ** (208n - 1n) - 1n;
    maxInt216 = 2n ** (216n - 1n) - 1n;
    maxInt224 = 2n ** (224n - 1n) - 1n;
    maxInt232 = 2n ** (232n - 1n) - 1n;
    maxInt240 = 2n ** (240n - 1n) - 1n;
    maxInt248 = 2n ** (248n - 1n) - 1n;
    maxInt256 = 2n ** (256n - 1n) - 1n;
    minInt8 = -(2n ** (8n - 1n));
    minInt16 = -(2n ** (16n - 1n));
    minInt24 = -(2n ** (24n - 1n));
    minInt32 = -(2n ** (32n - 1n));
    minInt40 = -(2n ** (40n - 1n));
    minInt48 = -(2n ** (48n - 1n));
    minInt56 = -(2n ** (56n - 1n));
    minInt64 = -(2n ** (64n - 1n));
    minInt72 = -(2n ** (72n - 1n));
    minInt80 = -(2n ** (80n - 1n));
    minInt88 = -(2n ** (88n - 1n));
    minInt96 = -(2n ** (96n - 1n));
    minInt104 = -(2n ** (104n - 1n));
    minInt112 = -(2n ** (112n - 1n));
    minInt120 = -(2n ** (120n - 1n));
    minInt128 = -(2n ** (128n - 1n));
    minInt136 = -(2n ** (136n - 1n));
    minInt144 = -(2n ** (144n - 1n));
    minInt152 = -(2n ** (152n - 1n));
    minInt160 = -(2n ** (160n - 1n));
    minInt168 = -(2n ** (168n - 1n));
    minInt176 = -(2n ** (176n - 1n));
    minInt184 = -(2n ** (184n - 1n));
    minInt192 = -(2n ** (192n - 1n));
    minInt200 = -(2n ** (200n - 1n));
    minInt208 = -(2n ** (208n - 1n));
    minInt216 = -(2n ** (216n - 1n));
    minInt224 = -(2n ** (224n - 1n));
    minInt232 = -(2n ** (232n - 1n));
    minInt240 = -(2n ** (240n - 1n));
    minInt248 = -(2n ** (248n - 1n));
    minInt256 = -(2n ** (256n - 1n));
    maxUint8 = 2n ** 8n - 1n;
    maxUint16 = 2n ** 16n - 1n;
    maxUint24 = 2n ** 24n - 1n;
    maxUint32 = 2n ** 32n - 1n;
    maxUint40 = 2n ** 40n - 1n;
    maxUint48 = 2n ** 48n - 1n;
    maxUint56 = 2n ** 56n - 1n;
    maxUint64 = 2n ** 64n - 1n;
    maxUint72 = 2n ** 72n - 1n;
    maxUint80 = 2n ** 80n - 1n;
    maxUint88 = 2n ** 88n - 1n;
    maxUint96 = 2n ** 96n - 1n;
    maxUint104 = 2n ** 104n - 1n;
    maxUint112 = 2n ** 112n - 1n;
    maxUint120 = 2n ** 120n - 1n;
    maxUint128 = 2n ** 128n - 1n;
    maxUint136 = 2n ** 136n - 1n;
    maxUint144 = 2n ** 144n - 1n;
    maxUint152 = 2n ** 152n - 1n;
    maxUint160 = 2n ** 160n - 1n;
    maxUint168 = 2n ** 168n - 1n;
    maxUint176 = 2n ** 176n - 1n;
    maxUint184 = 2n ** 184n - 1n;
    maxUint192 = 2n ** 192n - 1n;
    maxUint200 = 2n ** 200n - 1n;
    maxUint208 = 2n ** 208n - 1n;
    maxUint216 = 2n ** 216n - 1n;
    maxUint224 = 2n ** 224n - 1n;
    maxUint232 = 2n ** 232n - 1n;
    maxUint240 = 2n ** 240n - 1n;
    maxUint248 = 2n ** 248n - 1n;
    maxUint256 = 2n ** 256n - 1n;
  }
});
function decodeParameter(cursor, param, { staticPosition }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type6] = arrayComponents;
    return decodeArray(cursor, { ...param, type: type6 }, { length, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, { staticPosition });
  if (param.type === "address")
    return decodeAddress(cursor);
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidTypeError(param.type);
}
__name(decodeParameter, "decodeParameter");
function decodeAddress(cursor) {
  const value = cursor.readBytes(32);
  return [fromBytes(slice2(value, -20)), 32];
}
__name(decodeAddress, "decodeAddress");
function decodeArray(cursor, param, { length, staticPosition }) {
  if (!length) {
    const offset = toNumber2(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = toNumber2(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      cursor.setPosition(startOfData + (dynamicChild ? i2 * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(param)) {
    const offset = toNumber2(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const value2 = [];
    for (let i2 = 0; i2 < length; ++i2) {
      cursor.setPosition(start + i2 * 32);
      const [data] = decodeParameter(cursor, param, {
        staticPosition: start
      });
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let i2 = 0; i2 < length; ++i2) {
    const [data, consumed_] = decodeParameter(cursor, param, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data);
  }
  return [value, consumed];
}
__name(decodeArray, "decodeArray");
function decodeBool(cursor) {
  return [toBoolean2(cursor.readBytes(32), { size: 32 }), 32];
}
__name(decodeBool, "decodeBool");
function decodeBytes(cursor, param, { staticPosition }) {
  const [_, size3] = param.type.split("bytes");
  if (!size3) {
    const offset = toNumber2(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset);
    const length = toNumber2(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [fromBytes(data), 32];
  }
  const value = fromBytes(cursor.readBytes(Number.parseInt(size3), 32));
  return [value, 32];
}
__name(decodeBytes, "decodeBytes");
function decodeNumber(cursor, param) {
  const signed2 = param.type.startsWith("int");
  const size3 = Number.parseInt(param.type.split("int")[1] || "256");
  const value = cursor.readBytes(32);
  return [
    size3 > 48 ? toBigInt2(value, { signed: signed2 }) : toNumber2(value, { signed: signed2 }),
    32
  ];
}
__name(decodeNumber, "decodeNumber");
function decodeTuple(cursor, param, { staticPosition }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = toNumber2(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    for (let i2 = 0; i2 < param.components.length; ++i2) {
      const component = param.components[i2];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition: start
      });
      consumed += consumed_;
      value[hasUnnamedChild ? i2 : component?.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let i2 = 0; i2 < param.components.length; ++i2) {
    const component = param.components[i2];
    const [data, consumed_] = decodeParameter(cursor, component, {
      staticPosition
    });
    value[hasUnnamedChild ? i2 : component?.name] = data;
    consumed += consumed_;
  }
  return [value, consumed];
}
__name(decodeTuple, "decodeTuple");
function decodeString(cursor, { staticPosition }) {
  const offset = toNumber2(cursor.readBytes(32));
  const start = staticPosition + offset;
  cursor.setPosition(start);
  const length = toNumber2(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value = toString2(trimLeft2(data));
  cursor.setPosition(staticPosition + 32);
  return [value, 32];
}
__name(decodeString, "decodeString");
function prepareParameters({ parameters, values }) {
  const preparedParameters = [];
  for (let i2 = 0; i2 < parameters.length; i2++) {
    preparedParameters.push(prepareParameter({ parameter: parameters[i2], value: values[i2] }));
  }
  return preparedParameters;
}
__name(prepareParameters, "prepareParameters");
function prepareParameter({ parameter: parameter_, value }) {
  const parameter = parameter_;
  const arrayComponents = getArrayComponents(parameter.type);
  if (arrayComponents) {
    const [length, type6] = arrayComponents;
    return encodeArray(value, {
      length,
      parameter: {
        ...parameter,
        type: type6
      }
    });
  }
  if (parameter.type === "tuple") {
    return encodeTuple(value, {
      parameter
    });
  }
  if (parameter.type === "address") {
    return encodeAddress(value);
  }
  if (parameter.type === "bool") {
    return encodeBoolean(value);
  }
  if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
    const signed2 = parameter.type.startsWith("int");
    return encodeNumber(value, { signed: signed2 });
  }
  if (parameter.type.startsWith("bytes")) {
    return encodeBytes(value, { type: parameter.type });
  }
  if (parameter.type === "string") {
    return encodeString(value);
  }
  throw new InvalidTypeError(parameter.type);
}
__name(prepareParameter, "prepareParameter");
function encode(preparedParameters) {
  let staticSize = 0;
  for (let i2 = 0; i2 < preparedParameters.length; i2++) {
    const { dynamic, encoded } = preparedParameters[i2];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size2(encoded);
  }
  const staticParameters = [];
  const dynamicParameters = [];
  let dynamicSize = 0;
  for (let i2 = 0; i2 < preparedParameters.length; i2++) {
    const { dynamic, encoded } = preparedParameters[i2];
    if (dynamic) {
      staticParameters.push(fromNumber(staticSize + dynamicSize, { size: 32 }));
      dynamicParameters.push(encoded);
      dynamicSize += size2(encoded);
    } else {
      staticParameters.push(encoded);
    }
  }
  return concat(...staticParameters, ...dynamicParameters);
}
__name(encode, "encode");
function encodeAddress(value) {
  assert4(value, { strict: false });
  return {
    dynamic: false,
    encoded: padLeft(value.toLowerCase())
  };
}
__name(encodeAddress, "encodeAddress");
function encodeArray(value, { length, parameter }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new ArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${parameter.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParameters = [];
  for (let i2 = 0; i2 < value.length; i2++) {
    const preparedParam = prepareParameter({ parameter, value: value[i2] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParameters.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encode(preparedParameters);
    if (dynamic) {
      const length2 = fromNumber(preparedParameters.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParameters.length > 0 ? concat(length2, data) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(...preparedParameters.map(({ encoded }) => encoded))
  };
}
__name(encodeArray, "encodeArray");
function encodeBytes(value, { type: type6 }) {
  const [, parametersize] = type6.split("bytes");
  const bytesSize = size2(value);
  if (!parametersize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
    return {
      dynamic: true,
      encoded: concat(padLeft(fromNumber(bytesSize, { size: 32 })), value_)
    };
  }
  if (bytesSize !== Number.parseInt(parametersize))
    throw new BytesSizeMismatchError({
      expectedSize: Number.parseInt(parametersize),
      value
    });
  return { dynamic: false, encoded: padRight(value) };
}
__name(encodeBytes, "encodeBytes");
function encodeBoolean(value) {
  if (typeof value !== "boolean")
    throw new BaseError2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padLeft(fromBoolean(value)) };
}
__name(encodeBoolean, "encodeBoolean");
function encodeNumber(value, { signed: signed2 }) {
  return {
    dynamic: false,
    encoded: fromNumber(value, {
      size: 32,
      signed: signed2
    })
  };
}
__name(encodeNumber, "encodeNumber");
function encodeString(value) {
  const hexValue = fromString(value);
  const partsLength = Math.ceil(size2(hexValue) / 32);
  const parts = [];
  for (let i2 = 0; i2 < partsLength; i2++) {
    parts.push(padRight(slice(hexValue, i2 * 32, (i2 + 1) * 32)));
  }
  return {
    dynamic: true,
    encoded: concat(padRight(fromNumber(size2(hexValue), { size: 32 })), ...parts)
  };
}
__name(encodeString, "encodeString");
function encodeTuple(value, { parameter }) {
  let dynamic = false;
  const preparedParameters = [];
  for (let i2 = 0; i2 < parameter.components.length; i2++) {
    const param_ = parameter.components[i2];
    const index = Array.isArray(value) ? i2 : param_.name;
    const preparedParam = prepareParameter({
      parameter: param_,
      value: value[index]
    });
    preparedParameters.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encode(preparedParameters) : concat(...preparedParameters.map(({ encoded }) => encoded))
  };
}
__name(encodeTuple, "encodeTuple");
function getArrayComponents(type6) {
  const matches = type6.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
__name(getArrayComponents, "getArrayComponents");
function hasDynamicChild(param) {
  const { type: type6 } = param;
  if (type6 === "string")
    return true;
  if (type6 === "bytes")
    return true;
  if (type6.endsWith("[]"))
    return true;
  if (type6 === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({
    ...param,
    type: arrayComponents[1]
  }))
    return true;
  return false;
}
__name(hasDynamicChild, "hasDynamicChild");
var sizeOfLength;
var sizeOfOffset;
var init_abiParameters = __esm({
  "../node_modules/ox/_esm/core/internal/abiParameters.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_AbiParameters();
    init_Address();
    init_Bytes();
    init_Errors();
    init_Hex();
    __name2(decodeParameter, "decodeParameter");
    sizeOfLength = 32;
    sizeOfOffset = 32;
    __name2(decodeAddress, "decodeAddress");
    __name2(decodeArray, "decodeArray");
    __name2(decodeBool, "decodeBool");
    __name2(decodeBytes, "decodeBytes");
    __name2(decodeNumber, "decodeNumber");
    __name2(decodeTuple, "decodeTuple");
    __name2(decodeString, "decodeString");
    __name2(prepareParameters, "prepareParameters");
    __name2(prepareParameter, "prepareParameter");
    __name2(encode, "encode");
    __name2(encodeAddress, "encodeAddress");
    __name2(encodeArray, "encodeArray");
    __name2(encodeBytes, "encodeBytes");
    __name2(encodeBoolean, "encodeBoolean");
    __name2(encodeNumber, "encodeNumber");
    __name2(encodeString, "encodeString");
    __name2(encodeTuple, "encodeTuple");
    __name2(getArrayComponents, "getArrayComponents");
    __name2(hasDynamicChild, "hasDynamicChild");
  }
});
function create(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
__name(create, "create");
var staticCursor;
var NegativeOffsetError;
var PositionOutOfBoundsError;
var RecursiveReadLimitExceededError;
var init_cursor = __esm({
  "../node_modules/ox/_esm/core/internal/cursor.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Errors();
    staticCursor = {
      bytes: new Uint8Array(),
      dataView: new DataView(new ArrayBuffer(0)),
      position: 0,
      positionReadCount: /* @__PURE__ */ new Map(),
      recursiveReadCount: 0,
      recursiveReadLimit: Number.POSITIVE_INFINITY,
      assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit)
          throw new RecursiveReadLimitExceededError({
            count: this.recursiveReadCount + 1,
            limit: this.recursiveReadLimit
          });
      },
      assertPosition(position) {
        if (position < 0 || position > this.bytes.length - 1)
          throw new PositionOutOfBoundsError({
            length: this.bytes.length,
            position
          });
      },
      decrementPosition(offset) {
        if (offset < 0)
          throw new NegativeOffsetError({ offset });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
      },
      getReadCount(position) {
        return this.positionReadCount.get(position || this.position) || 0;
      },
      incrementPosition(offset) {
        if (offset < 0)
          throw new NegativeOffsetError({ offset });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
      },
      inspectByte(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectBytes(length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
      },
      inspectUint8(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectUint16(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
      },
      inspectUint24(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
      },
      inspectUint32(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
      },
      pushByte(byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
      },
      pushBytes(bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
      },
      pushUint8(value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
      },
      pushUint16(value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
      },
      pushUint24(value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & ~4294967040);
        this.position += 3;
      },
      pushUint32(value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
      },
      readByte() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectByte();
        this.position++;
        return value;
      },
      readBytes(length, size3) {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectBytes(length);
        this.position += size3 ?? length;
        return value;
      },
      readUint8() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint8();
        this.position += 1;
        return value;
      },
      readUint16() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint16();
        this.position += 2;
        return value;
      },
      readUint24() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint24();
        this.position += 3;
        return value;
      },
      readUint32() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint32();
        this.position += 4;
        return value;
      },
      get remaining() {
        return this.bytes.length - this.position;
      },
      setPosition(position) {
        const oldPosition = this.position;
        this.assertPosition(position);
        this.position = position;
        return () => this.position = oldPosition;
      },
      _touch() {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
          return;
        const count3 = this.getReadCount();
        this.positionReadCount.set(this.position, count3 + 1);
        if (count3 > 0)
          this.recursiveReadCount++;
      }
    };
    __name2(create, "create");
    NegativeOffsetError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ offset }) {
        super(`Offset \`${offset}\` cannot be negative.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Cursor.NegativeOffsetError"
        });
      }
    }, "NegativeOffsetError");
    __name2(NegativeOffsetError, "NegativeOffsetError");
    PositionOutOfBoundsError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ length, position }) {
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Cursor.PositionOutOfBoundsError"
        });
      }
    }, "PositionOutOfBoundsError");
    __name2(PositionOutOfBoundsError, "PositionOutOfBoundsError");
    RecursiveReadLimitExceededError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ count: count3, limit }) {
        super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count3}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Cursor.RecursiveReadLimitExceededError"
        });
      }
    }, "RecursiveReadLimitExceededError");
    __name2(RecursiveReadLimitExceededError, "RecursiveReadLimitExceededError");
  }
});
var AbiParameters_exports = {};
__export(AbiParameters_exports, {
  ArrayLengthMismatchError: () => ArrayLengthMismatchError,
  BytesSizeMismatchError: () => BytesSizeMismatchError,
  DataSizeTooSmallError: () => DataSizeTooSmallError,
  InvalidArrayError: () => InvalidArrayError,
  InvalidTypeError: () => InvalidTypeError,
  LengthMismatchError: () => LengthMismatchError,
  ZeroDataError: () => ZeroDataError,
  decode: () => decode,
  encode: () => encode2,
  encodePacked: () => encodePacked,
  format: () => format3,
  from: () => from7
});
function decode(parameters, data, options2 = {}) {
  const { as = "Array" } = options2;
  const bytes = typeof data === "string" ? fromHex(data) : data;
  const cursor = create(bytes);
  if (size(bytes) === 0 && parameters.length > 0)
    throw new ZeroDataError();
  if (size(bytes) && size(bytes) < 32)
    throw new DataSizeTooSmallError({
      data: typeof data === "string" ? data : fromBytes(data),
      parameters,
      size: size(bytes)
    });
  let consumed = 0;
  const values = as === "Array" ? [] : {};
  for (let i2 = 0; i2 < parameters.length; ++i2) {
    const param = parameters[i2];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, param, {
      staticPosition: 0
    });
    consumed += consumed_;
    if (as === "Array")
      values.push(data2);
    else
      values[param.name ?? i2] = data2;
  }
  return values;
}
__name(decode, "decode");
function encode2(parameters, values) {
  if (parameters.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: parameters.length,
      givenLength: values.length
    });
  const preparedParameters = prepareParameters({
    parameters,
    values
  });
  const data = encode(preparedParameters);
  if (data.length === 0)
    return "0x";
  return data;
}
__name(encode2, "encode2");
function encodePacked(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i2 = 0; i2 < types.length; i2++) {
    const type6 = types[i2];
    const value = values[i2];
    data.push(encodePacked.encode(type6, value));
  }
  return concat(...data);
}
__name(encodePacked, "encodePacked");
function format3(parameters) {
  return formatAbiParameters(parameters);
}
__name(format3, "format3");
function from7(parameters) {
  if (Array.isArray(parameters) && typeof parameters[0] === "string")
    return parseAbiParameters(parameters);
  if (typeof parameters === "string")
    return parseAbiParameters(parameters);
  return parameters;
}
__name(from7, "from7");
var DataSizeTooSmallError;
var ZeroDataError;
var ArrayLengthMismatchError;
var BytesSizeMismatchError;
var LengthMismatchError;
var InvalidArrayError;
var InvalidTypeError;
var init_AbiParameters = __esm({
  "../node_modules/ox/_esm/core/AbiParameters.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_exports();
    init_Address();
    init_Bytes();
    init_Errors();
    init_Hex();
    init_Solidity();
    init_abiParameters();
    init_cursor();
    __name2(decode, "decode");
    decode.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(encode2, "encode");
    encode2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(encodePacked, "encodePacked");
    (function(encodePacked2) {
      function encode9(type6, value, isArray = false) {
        if (type6 === "address") {
          const address = value;
          assert4(address);
          return padLeft(address.toLowerCase(), isArray ? 32 : 0);
        }
        if (type6 === "string")
          return fromString(value);
        if (type6 === "bytes")
          return value;
        if (type6 === "bool")
          return padLeft(fromBoolean(value), isArray ? 32 : 1);
        const intMatch = type6.match(integerRegex2);
        if (intMatch) {
          const [_type, baseType, bits = "256"] = intMatch;
          const size3 = Number.parseInt(bits) / 8;
          return fromNumber(value, {
            size: isArray ? 32 : size3,
            signed: baseType === "int"
          });
        }
        const bytesMatch = type6.match(bytesRegex2);
        if (bytesMatch) {
          const [_type, size3] = bytesMatch;
          if (Number.parseInt(size3) !== (value.length - 2) / 2)
            throw new BytesSizeMismatchError({
              expectedSize: Number.parseInt(size3),
              value
            });
          return padRight(value, isArray ? 32 : 0);
        }
        const arrayMatch = type6.match(arrayRegex);
        if (arrayMatch && Array.isArray(value)) {
          const [_type, childType] = arrayMatch;
          const data = [];
          for (let i2 = 0; i2 < value.length; i2++) {
            data.push(encode9(childType, value[i2], true));
          }
          if (data.length === 0)
            return "0x";
          return concat(...data);
        }
        throw new InvalidTypeError(type6);
      }
      __name(encode9, "encode9");
      __name2(encode9, "encode");
      encodePacked2.encode = encode9;
    })(encodePacked || (encodePacked = {}));
    encodePacked.parseError = (error) => error;
    __name2(format3, "format");
    format3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from7, "from");
    from7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    DataSizeTooSmallError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ data, parameters, size: size3 }) {
        super(`Data size of ${size3} bytes is too small for given parameters.`, {
          metaMessages: [
            `Params: (${formatAbiParameters(parameters)})`,
            `Data:   ${data} (${size3} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiParameters.DataSizeTooSmallError"
        });
      }
    }, "DataSizeTooSmallError");
    __name2(DataSizeTooSmallError, "DataSizeTooSmallError");
    ZeroDataError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiParameters.ZeroDataError"
        });
      }
    }, "ZeroDataError");
    __name2(ZeroDataError, "ZeroDataError");
    ArrayLengthMismatchError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ expectedLength, givenLength, type: type6 }) {
        super(`Array length mismatch for type \`${type6}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiParameters.ArrayLengthMismatchError"
        });
      }
    }, "ArrayLengthMismatchError");
    __name2(ArrayLengthMismatchError, "ArrayLengthMismatchError");
    BytesSizeMismatchError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${size2(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiParameters.BytesSizeMismatchError"
        });
      }
    }, "BytesSizeMismatchError");
    __name2(BytesSizeMismatchError, "BytesSizeMismatchError");
    LengthMismatchError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ expectedLength, givenLength }) {
        super([
          "ABI encoding parameters/values length mismatch.",
          `Expected length (parameters): ${expectedLength}`,
          `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiParameters.LengthMismatchError"
        });
      }
    }, "LengthMismatchError");
    __name2(LengthMismatchError, "LengthMismatchError");
    InvalidArrayError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(value) {
        super(`Value \`${value}\` is not a valid array.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiParameters.InvalidArrayError"
        });
      }
    }, "InvalidArrayError");
    __name2(InvalidArrayError, "InvalidArrayError");
    InvalidTypeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(type6) {
        super(`Type \`${type6}\` is not a valid ABI Type.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiParameters.InvalidTypeError"
        });
      }
    }, "InvalidTypeError");
    __name2(InvalidTypeError, "InvalidTypeError");
  }
});
function decode2(abiConstructor, options2) {
  const { bytecode } = options2;
  if (abiConstructor.inputs.length === 0)
    return void 0;
  const data = options2.data.replace(bytecode, "0x");
  return decode(abiConstructor.inputs, data);
}
__name(decode2, "decode2");
function encode3(abiConstructor, options2) {
  const { bytecode, args } = options2;
  return concat(bytecode, abiConstructor.inputs?.length && args?.length ? encode2(abiConstructor.inputs, args) : "0x");
}
__name(encode3, "encode3");
function format4(abiConstructor) {
  return formatAbiItem(abiConstructor);
}
__name(format4, "format4");
function from8(abiConstructor) {
  return from6(abiConstructor);
}
__name(from8, "from8");
function fromAbi2(abi) {
  const item = abi.find((item2) => item2.type === "constructor");
  if (!item)
    throw new NotFoundError({ name: "constructor" });
  return item;
}
__name(fromAbi2, "fromAbi2");
var init_AbiConstructor = __esm({
  "../node_modules/ox/_esm/core/AbiConstructor.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_exports();
    init_AbiItem();
    init_AbiParameters();
    init_Hex();
    __name2(decode2, "decode");
    decode2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(encode3, "encode");
    encode3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(format4, "format");
    format4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from8, "from");
    from8.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromAbi2, "fromAbi");
    fromAbi2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function encode4(abiError, ...args) {
  const selector = getSelector2(abiError);
  const data = args.length > 0 ? encode2(abiError.inputs, args[0]) : void 0;
  return data ? concat(selector, data) : selector;
}
__name(encode4, "encode4");
function format5(abiError) {
  return formatAbiItem(abiError);
}
__name(format5, "format5");
function from9(abiError, options2 = {}) {
  return from6(abiError, options2);
}
__name(from9, "from9");
function fromAbi3(abi, name, options2) {
  if (name === "Error")
    return solidityError;
  if (name === "Panic")
    return solidityPanic;
  if (validate(name, { strict: false })) {
    const selector = slice(name, 0, 4);
    if (selector === solidityErrorSelector)
      return solidityError;
    if (selector === solidityPanicSelector)
      return solidityPanic;
  }
  const item = fromAbi(abi, name, options2);
  if (item.type !== "error")
    throw new NotFoundError({ name, type: "error" });
  return item;
}
__name(fromAbi3, "fromAbi3");
function getSelector2(abiItem) {
  return getSelector(abiItem);
}
__name(getSelector2, "getSelector2");
var solidityError;
var solidityErrorSelector;
var solidityPanic;
var solidityPanicSelector;
var init_AbiError = __esm({
  "../node_modules/ox/_esm/core/AbiError.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_exports();
    init_AbiItem();
    init_AbiParameters();
    init_Hex();
    __name2(encode4, "encode");
    encode4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(format5, "format");
    format5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from9, "from");
    from9.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromAbi3, "fromAbi");
    fromAbi3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSelector2, "getSelector");
    getSelector2.parseError = (error) => error;
    solidityError = /* @__PURE__ */ from9({
      inputs: [
        {
          name: "message",
          type: "string"
        }
      ],
      name: "Error",
      type: "error"
    });
    solidityErrorSelector = "0x08c379a0";
    solidityPanic = /* @__PURE__ */ from9({
      inputs: [
        {
          name: "reason",
          type: "uint8"
        }
      ],
      name: "Panic",
      type: "error"
    });
    solidityPanicSelector = "0x4e487b71";
  }
});
function assertArgs(abiEvent, args, matchArgs) {
  if (!args || !matchArgs)
    throw new ArgsMismatchError({
      abiEvent,
      expected: args,
      given: matchArgs
    });
  function isEqual4(input, value, arg) {
    if (input.type === "address")
      return isEqual3(value, arg);
    if (input.type === "string")
      return keccak256(fromString2(value)) === arg;
    if (input.type === "bytes")
      return keccak256(value) === arg;
    return value === arg;
  }
  __name(isEqual4, "isEqual4");
  __name2(isEqual4, "isEqual");
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    for (const [index, value] of matchArgs.entries()) {
      if (value === null || value === void 0)
        continue;
      const input = abiEvent.inputs[index];
      if (!input)
        throw new InputNotFoundError({
          abiEvent,
          name: `${index}`
        });
      const value_ = Array.isArray(value) ? value : [value];
      let equal = false;
      for (const value2 of value_) {
        if (isEqual4(input, value2, args[index]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    for (const [key, value] of Object.entries(matchArgs)) {
      if (value === null || value === void 0)
        continue;
      const input = abiEvent.inputs.find((input2) => input2.name === key);
      if (!input)
        throw new InputNotFoundError({ abiEvent, name: key });
      const value_ = Array.isArray(value) ? value : [value];
      let equal = false;
      for (const value2 of value_) {
        if (isEqual4(input, value2, args[key]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
}
__name(assertArgs, "assertArgs");
function decode3(abiEvent, log) {
  const { data, topics } = log;
  const [selector_, ...argTopics] = topics;
  const selector = getSelector3(abiEvent);
  if (selector_ !== selector)
    throw new SelectorTopicMismatchError({
      abiEvent,
      actual: selector_,
      expected: selector
    });
  const { inputs } = abiEvent;
  const isUnnamed = inputs?.every((x2) => !("name" in x2 && x2.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x2) => "indexed" in x2 && x2.indexed);
  for (let i2 = 0; i2 < indexedInputs.length; i2++) {
    const param = indexedInputs[i2];
    const topic = argTopics[i2];
    if (!topic)
      throw new TopicsMismatchError({
        abiEvent,
        param
      });
    args[isUnnamed ? i2 : param.name || i2] = (() => {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return topic;
      const decoded = decode([param], topic) || [];
      return decoded[0];
    })();
  }
  const nonIndexedInputs = inputs.filter((x2) => !("indexed" in x2 && x2.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decode(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i2 = 0; i2 < nonIndexedInputs.length; i2++) {
              const index = inputs.indexOf(nonIndexedInputs[i2]);
              args[nonIndexedInputs[i2].name || index] = decodedData[i2];
            }
          }
        }
      } catch (err) {
        if (err instanceof DataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
          throw new DataMismatchError({
            abiEvent,
            data,
            parameters: nonIndexedInputs,
            size: size2(data)
          });
        throw err;
      }
    } else {
      throw new DataMismatchError({
        abiEvent,
        data: "0x",
        parameters: nonIndexedInputs,
        size: 0
      });
    }
  }
  return Object.values(args).length > 0 ? args : void 0;
}
__name(decode3, "decode3");
function encode5(abiEvent, ...[args]) {
  let topics = [];
  if (args && abiEvent.inputs) {
    const indexedInputs = abiEvent.inputs.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x2, i2) => args[x2.name ?? i2]) ?? [] : [];
    if (args_.length > 0) {
      const encode9 = /* @__PURE__ */ __name2((param, value) => {
        if (param.type === "string")
          return keccak256(fromString(value));
        if (param.type === "bytes")
          return keccak256(value);
        if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
          throw new FilterTypeNotSupportedError(param.type);
        return encode2([param], [value]);
      }, "encode");
      topics = indexedInputs?.map((param, i2) => {
        if (Array.isArray(args_[i2]))
          return args_[i2].map((_, j2) => encode9(param, args_[i2][j2]));
        return args_[i2] ? encode9(param, args_[i2]) : null;
      }) ?? [];
    }
  }
  const selector = (() => {
    if (abiEvent.hash)
      return abiEvent.hash;
    return getSelector3(abiEvent);
  })();
  return { topics: [selector, ...topics] };
}
__name(encode5, "encode5");
function format6(abiEvent) {
  return formatAbiItem(abiEvent);
}
__name(format6, "format6");
function from10(abiEvent, options2 = {}) {
  return from6(abiEvent, options2);
}
__name(from10, "from10");
function fromAbi4(abi, name, options2) {
  const item = fromAbi(abi, name, options2);
  if (item.type !== "event")
    throw new NotFoundError({ name, type: "event" });
  return item;
}
__name(fromAbi4, "fromAbi4");
function getSelector3(abiItem) {
  return getSignatureHash(abiItem);
}
__name(getSelector3, "getSelector3");
var ArgsMismatchError;
var InputNotFoundError;
var DataMismatchError;
var TopicsMismatchError;
var SelectorTopicMismatchError;
var FilterTypeNotSupportedError;
var init_AbiEvent = __esm({
  "../node_modules/ox/_esm/core/AbiEvent.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_exports();
    init_AbiItem();
    init_AbiParameters();
    init_Address();
    init_Bytes();
    init_Errors();
    init_Hash();
    init_Hex();
    init_cursor();
    init_errors2();
    __name2(assertArgs, "assertArgs");
    assertArgs.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(decode3, "decode");
    decode3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(encode5, "encode");
    encode5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(format6, "format");
    format6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from10, "from");
    from10.parseEvent = (Event) => (
      /* v8 ignore next */
      Event
    );
    __name2(fromAbi4, "fromAbi");
    fromAbi4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSelector3, "getSelector");
    getSelector3.parseError = (error) => error;
    ArgsMismatchError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ abiEvent, expected, given }) {
        super("Given arguments do not match the expected arguments.", {
          metaMessages: [
            `Event: ${format6(abiEvent)}`,
            `Expected Arguments: ${!expected ? "None" : ""}`,
            expected ? prettyPrint(expected) : void 0,
            `Given Arguments: ${!given ? "None" : ""}`,
            given ? prettyPrint(given) : void 0
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEvent.ArgsMismatchError"
        });
      }
    }, "ArgsMismatchError");
    __name2(ArgsMismatchError, "ArgsMismatchError");
    InputNotFoundError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ abiEvent, name }) {
        super(`Parameter "${name}" not found on \`${format6(abiEvent)}\`.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEvent.InputNotFoundError"
        });
      }
    }, "InputNotFoundError");
    __name2(InputNotFoundError, "InputNotFoundError");
    DataMismatchError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ abiEvent, data, parameters, size: size3 }) {
        super([
          `Data size of ${size3} bytes is too small for non-indexed event parameters.`
        ].join("\n"), {
          metaMessages: [
            `Non-indexed Parameters: (${format3(parameters)})`,
            `Data:   ${data} (${size3} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEvent.DataMismatchError"
        });
        Object.defineProperty(this, "abiEvent", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "parameters", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiEvent = abiEvent;
        this.data = data;
        this.parameters = parameters;
        this.size = size3;
      }
    }, "DataMismatchError");
    __name2(DataMismatchError, "DataMismatchError");
    TopicsMismatchError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ abiEvent, param }) {
        super([
          `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} for "${format6(abiEvent)}".`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEvent.TopicsMismatchError"
        });
        Object.defineProperty(this, "abiEvent", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiEvent = abiEvent;
      }
    }, "TopicsMismatchError");
    __name2(TopicsMismatchError, "TopicsMismatchError");
    SelectorTopicMismatchError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ abiEvent, actual, expected }) {
        super(`topics[0]="${actual}" does not match the expected topics[0]="${expected}".`, {
          metaMessages: [`Event: ${format6(abiEvent)}`, `Selector: ${expected}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEvent.SelectorTopicMismatchError"
        });
      }
    }, "SelectorTopicMismatchError");
    __name2(SelectorTopicMismatchError, "SelectorTopicMismatchError");
    FilterTypeNotSupportedError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(type6) {
        super(`Filter type "${type6}" is not supported.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEvent.FilterTypeNotSupportedError"
        });
      }
    }, "FilterTypeNotSupportedError");
    __name2(FilterTypeNotSupportedError, "FilterTypeNotSupportedError");
  }
});
function encodeData(abiFunction, ...args) {
  const { overloads } = abiFunction;
  const item = overloads ? fromAbi5([abiFunction, ...overloads], abiFunction.name, {
    args: args[0]
  }) : abiFunction;
  const selector = getSelector4(item);
  const data = args.length > 0 ? encode2(item.inputs, args[0]) : void 0;
  return data ? concat(selector, data) : selector;
}
__name(encodeData, "encodeData");
function format7(abiFunction) {
  return formatAbiItem(abiFunction);
}
__name(format7, "format7");
function from11(abiFunction, options2 = {}) {
  return from6(abiFunction, options2);
}
__name(from11, "from11");
function fromAbi5(abi, name, options2) {
  const item = fromAbi(abi, name, options2);
  if (item.type !== "function")
    throw new NotFoundError({ name, type: "function" });
  return item;
}
__name(fromAbi5, "fromAbi5");
function getSelector4(abiItem) {
  return getSelector(abiItem);
}
__name(getSelector4, "getSelector4");
var init_AbiFunction = __esm({
  "../node_modules/ox/_esm/core/AbiFunction.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_exports();
    init_AbiItem();
    init_AbiParameters();
    init_Hex();
    __name2(encodeData, "encodeData");
    encodeData.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(format7, "format");
    format7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from11, "from");
    from11.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromAbi5, "fromAbi");
    fromAbi5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSelector4, "getSelector");
    getSelector4.parseError = (error) => error;
  }
});
function fromTupleList(accessList) {
  const list = [];
  for (let i2 = 0; i2 < accessList.length; i2++) {
    const [address, storageKeys] = accessList[i2];
    if (address)
      assert4(address, { strict: false });
    list.push({
      address,
      storageKeys: storageKeys.map((key) => validate3(key) ? key : trimLeft(key))
    });
  }
  return list;
}
__name(fromTupleList, "fromTupleList");
function toTupleList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const tuple = [];
  for (const { address, storageKeys } of accessList) {
    for (let j2 = 0; j2 < storageKeys.length; j2++)
      if (size2(storageKeys[j2]) !== 32)
        throw new InvalidStorageKeySizeError({
          storageKey: storageKeys[j2]
        });
    if (address)
      assert4(address, { strict: false });
    tuple.push([address, storageKeys]);
  }
  return tuple;
}
__name(toTupleList, "toTupleList");
var InvalidStorageKeySizeError;
var init_AccessList = __esm({
  "../node_modules/ox/_esm/core/AccessList.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Address();
    init_Errors();
    init_Hash();
    init_Hex();
    __name2(fromTupleList, "fromTupleList");
    __name2(toTupleList, "toTupleList");
    InvalidStorageKeySizeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${size2(storageKey)} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AccessList.InvalidStorageKeySizeError"
        });
      }
    }, "InvalidStorageKeySizeError");
    __name2(InvalidStorageKeySizeError, "InvalidStorageKeySizeError");
  }
});
var init_AccountProof = __esm({
  "../node_modules/ox/_esm/core/AccountProof.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
async function decrypt(value, key, options2 = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options2;
  const encrypted = from3(value);
  const iv = encrypted.slice(0, ivLength);
  const data = encrypted.slice(ivLength);
  const decrypted = await globalThis.crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, key, from3(data));
  const result = new Uint8Array(decrypted);
  if (as === "Bytes")
    return result;
  return from2(result);
}
__name(decrypt, "decrypt");
async function encrypt(value, key, options2 = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options2;
  const iv = random(ivLength);
  const encrypted = await globalThis.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, key, from3(value));
  const result = concat2(iv, new Uint8Array(encrypted));
  if (as === "Bytes")
    return result;
  return from2(result);
}
__name(encrypt, "encrypt");
async function getKey(options2) {
  const { iterations = 9e5, password, salt = randomSalt(32) } = options2;
  const baseKey = await globalThis.crypto.subtle.importKey("raw", fromString2(password), { name: "PBKDF2" }, false, ["deriveBits", "deriveKey"]);
  const key = await globalThis.crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt,
    iterations,
    hash: "SHA-256"
  }, baseKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
  return key;
}
__name(getKey, "getKey");
function randomSalt(size3 = 32) {
  return random(size3);
}
__name(randomSalt, "randomSalt");
var ivLength;
var init_AesGcm = __esm({
  "../node_modules/ox/_esm/core/AesGcm.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Hex();
    ivLength = 16;
    __name2(decrypt, "decrypt");
    decrypt.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(encrypt, "encrypt");
    encrypt.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getKey, "getKey");
    getKey.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(randomSalt, "randomSalt");
    random.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function toBytes4(value) {
  return to(value, "Bytes");
}
__name(toBytes4, "toBytes4");
function toHex3(value) {
  return to(value, "Hex");
}
__name(toHex3, "toHex3");
function to(value, to3) {
  const to_ = to3 ?? (typeof value === "string" ? "Hex" : "Bytes");
  const bytes = (() => {
    if (typeof value === "string") {
      if (value.length > 3 && value.length % 2 !== 0)
        throw new InvalidLengthError(value);
      return fromHex(value);
    }
    return value;
  })();
  const cursor = create(bytes, {
    recursiveReadLimit: Number.POSITIVE_INFINITY
  });
  const result = decodeRlpCursor(cursor, to_);
  return result;
}
__name(to, "to");
function decodeRlpCursor(cursor, to3 = "Hex") {
  if (cursor.bytes.length === 0)
    return to3 === "Hex" ? fromBytes(cursor.bytes) : cursor.bytes;
  const prefix = cursor.readByte();
  if (prefix < 128)
    cursor.decrementPosition(1);
  if (prefix < 192) {
    const length2 = readLength(cursor, prefix, 128);
    const bytes = cursor.readBytes(length2);
    return to3 === "Hex" ? fromBytes(bytes) : bytes;
  }
  const length = readLength(cursor, prefix, 192);
  return readList(cursor, length, to3);
}
__name(decodeRlpCursor, "decodeRlpCursor");
function readLength(cursor, prefix, offset) {
  if (offset === 128 && prefix < 128)
    return 1;
  if (prefix <= offset + 55)
    return prefix - offset;
  if (prefix === offset + 55 + 1)
    return cursor.readUint8();
  if (prefix === offset + 55 + 2)
    return cursor.readUint16();
  if (prefix === offset + 55 + 3)
    return cursor.readUint24();
  if (prefix === offset + 55 + 4)
    return cursor.readUint32();
  throw new BaseError2("Invalid RLP prefix");
}
__name(readLength, "readLength");
function readList(cursor, length, to3) {
  const position = cursor.position;
  const value = [];
  while (cursor.position - position < length)
    value.push(decodeRlpCursor(cursor, to3));
  return value;
}
__name(readList, "readList");
function from12(value, options2) {
  const { as } = options2;
  const encodable = getEncodable(value);
  const cursor = create(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (as === "Hex")
    return fromBytes(cursor.bytes);
  return cursor.bytes;
}
__name(from12, "from12");
function fromBytes3(bytes, options2 = {}) {
  const { as = "Bytes" } = options2;
  return from12(bytes, { as });
}
__name(fromBytes3, "fromBytes3");
function fromHex3(hex3, options2 = {}) {
  const { as = "Hex" } = options2;
  return from12(hex3, { as });
}
__name(fromHex3, "fromHex3");
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x2) => getEncodable(x2)));
  return getEncodableBytes(bytes);
}
__name(getEncodable, "getEncodable");
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x2) => acc + x2.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode9 } of list) {
        encode9(cursor);
      }
    }
  };
}
__name(getEncodableList, "getEncodableList");
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? fromHex(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
__name(getEncodableBytes, "getEncodableBytes");
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError2("Length is too large.");
}
__name(getSizeOfLength, "getSizeOfLength");
var init_Rlp = __esm({
  "../node_modules/ox/_esm/core/Rlp.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Errors();
    init_Hex();
    init_cursor();
    __name2(toBytes4, "toBytes");
    toBytes4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toHex3, "toHex");
    toHex3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(to, "to");
    to.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(decodeRlpCursor, "decodeRlpCursor");
    __name2(readLength, "readLength");
    __name2(readList, "readList");
    __name2(from12, "from");
    from12.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromBytes3, "fromBytes");
    fromBytes3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromHex3, "fromHex");
    fromHex3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getEncodable, "getEncodable");
    __name2(getEncodableList, "getEncodableList");
    __name2(getEncodableBytes, "getEncodableBytes");
    __name2(getSizeOfLength, "getSizeOfLength");
  }
});
var HMAC;
var hmac;
var init_hmac = __esm({
  "../node_modules/@noble/hashes/esm/hmac.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_utils2();
    HMAC = /* @__PURE__ */ __name(class extends Hash {
      constructor(hash7, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash(hash7);
        const key = toBytes(_key);
        this.iHash = hash7.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad3 = new Uint8Array(blockLen);
        pad3.set(key.length > blockLen ? hash7.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad3.length; i2++)
          pad3[i2] ^= 54;
        this.iHash.update(pad3);
        this.oHash = hash7.create();
        for (let i2 = 0; i2 < pad3.length; i2++)
          pad3[i2] ^= 54 ^ 92;
        this.oHash.update(pad3);
        clean(pad3);
      }
      update(buf) {
        aexists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        aexists(this);
        abytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to3) {
        to3 || (to3 = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to3 = to3;
        to3.finished = finished;
        to3.destroyed = destroyed;
        to3.blockLen = blockLen;
        to3.outputLen = outputLen;
        to3.oHash = oHash._cloneInto(to3.oHash);
        to3.iHash = iHash._cloneInto(to3.iHash);
        return to3;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    }, "HMAC");
    __name2(HMAC, "HMAC");
    hmac = /* @__PURE__ */ __name2((hash7, key, message) => new HMAC(hash7, key).update(message).digest(), "hmac");
    hmac.create = (hash7, key) => new HMAC(hash7, key);
  }
});
function mod(a2, b2) {
  const result = a2 % b2;
  return result >= _0n3 ? result : b2 + result;
}
__name(mod, "mod");
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
__name(pow2, "pow2");
function invert(number2, modulo) {
  if (number2 === _0n3)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n3)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a2 = mod(number2, modulo);
  let b2 = modulo;
  let x2 = _0n3, y2 = _1n3, u2 = _1n3, v2 = _0n3;
  while (a2 !== _0n3) {
    const q = b2 / a2;
    const r3 = b2 % a2;
    const m2 = x2 - u2 * q;
    const n2 = y2 - v2 * q;
    b2 = a2, a2 = r3, x2 = u2, y2 = v2, u2 = m2, v2 = n2;
  }
  const gcd2 = b2;
  if (gcd2 !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
__name(invert, "invert");
function tonelliShanks(P2) {
  let Q = P2 - _1n3;
  let S2 = 0;
  while (Q % _2n2 === _0n3) {
    Q /= _2n2;
    S2++;
  }
  let Z = _2n2;
  const _Fp = Field(P2);
  while (Z < P2 && FpIsSquare(_Fp, Z)) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S2 === 1) {
    const p1div4 = (P2 + _1n3) / _4n;
    return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function tonelliFast(Fp3, n2) {
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    }, "tonelliFast"), "tonelliFast");
  }
  const Q1div2 = (Q + _1n3) / _2n2;
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function tonelliSlow(Fp3, n2) {
    if (!FpIsSquare(Fp3, n2))
      throw new Error("Cannot find square root");
    let r3 = S2;
    let g2 = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x2 = Fp3.pow(n2, Q1div2);
    let b2 = Fp3.pow(n2, Q);
    while (!Fp3.eql(b2, Fp3.ONE)) {
      if (Fp3.eql(b2, Fp3.ZERO))
        return Fp3.ZERO;
      let m2 = 1;
      for (let t2 = Fp3.sqr(b2); m2 < r3; m2++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge = Fp3.pow(g2, _1n3 << BigInt(r3 - m2 - 1));
      g2 = Fp3.sqr(ge);
      x2 = Fp3.mul(x2, ge);
      b2 = Fp3.mul(b2, g2);
      r3 = m2;
    }
    return x2;
  }, "tonelliSlow"), "tonelliSlow");
}
__name(tonelliShanks, "tonelliShanks");
function FpSqrt(P2) {
  if (P2 % _4n === _3n) {
    return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqrt3mod4(Fp3, n2) {
      const p1div4 = (P2 + _1n3) / _4n;
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    }, "sqrt3mod4"), "sqrt3mod4");
  }
  if (P2 % _8n === _5n) {
    return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function sqrt5mod8(Fp3, n2) {
      const n22 = Fp3.mul(n2, _2n2);
      const c1 = (P2 - _5n) / _8n;
      const v2 = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n2, v2);
      const i2 = Fp3.mul(Fp3.mul(nv, _2n2), v2);
      const root = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    }, "sqrt5mod8"), "sqrt5mod8");
  }
  if (P2 % _16n === _9n) {
  }
  return tonelliShanks(P2);
}
__name(FpSqrt, "FpSqrt");
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
__name(validateField, "validateField");
function FpPow(Fp3, num, power) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n3)
    return Fp3.ONE;
  if (power === _1n3)
    return num;
  let p2 = Fp3.ONE;
  let d2 = num;
  while (power > _0n3) {
    if (power & _1n3)
      p2 = Fp3.mul(p2, d2);
    d2 = Fp3.sqr(d2);
    power >>= _1n3;
  }
  return p2;
}
__name(FpPow, "FpPow");
function FpInvertBatch(Fp3, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp3.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i2) => {
    if (Fp3.is0(num))
      return acc;
    inverted[i2] = acc;
    return Fp3.mul(acc, num);
  }, Fp3.ONE);
  const invertedAcc = Fp3.inv(multipliedAcc);
  nums.reduceRight((acc, num, i2) => {
    if (Fp3.is0(num))
      return acc;
    inverted[i2] = Fp3.mul(acc, inverted[i2]);
    return Fp3.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
__name(FpInvertBatch, "FpInvertBatch");
function FpLegendre(Fp3, n2) {
  const legc = (Fp3.ORDER - _1n3) / _2n2;
  const powered = Fp3.pow(n2, legc);
  const yes = Fp3.eql(powered, Fp3.ONE);
  const zero = Fp3.eql(powered, Fp3.ZERO);
  const no = Fp3.eql(powered, Fp3.neg(Fp3.ONE));
  if (!yes && !zero && !no)
    throw new Error("Cannot find square root: probably non-prime P");
  return yes ? 1 : zero ? 0 : -1;
}
__name(FpLegendre, "FpLegendre");
function FpIsSquare(Fp3, n2) {
  const l2 = FpLegendre(Fp3, n2);
  return l2 === 0 || l2 === 1;
}
__name(FpIsSquare, "FpIsSquare");
function nLength(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
__name(nLength, "nLength");
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f2 = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f2, n2);
    }),
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a2, b2, c2) => c2 ? b2 : a2
  });
  return Object.freeze(f2);
}
__name(Field, "Field");
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
__name(getFieldBytesLength, "getFieldBytesLength");
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
__name(getMinHashLength, "getMinHashLength");
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
__name(mapHashToField, "mapHashToField");
var _0n3;
var _1n3;
var _2n2;
var _3n;
var _4n;
var _5n;
var _8n;
var _9n;
var _16n;
var FIELD_FIELDS;
var init_modular = __esm({
  "../node_modules/@noble/curves/esm/abstract/modular.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_utils2();
    init_utils3();
    _0n3 = BigInt(0);
    _1n3 = BigInt(1);
    _2n2 = /* @__PURE__ */ BigInt(2);
    _3n = /* @__PURE__ */ BigInt(3);
    _4n = /* @__PURE__ */ BigInt(4);
    _5n = /* @__PURE__ */ BigInt(5);
    _8n = /* @__PURE__ */ BigInt(8);
    _9n = /* @__PURE__ */ BigInt(9);
    _16n = /* @__PURE__ */ BigInt(16);
    __name2(mod, "mod");
    __name2(pow2, "pow2");
    __name2(invert, "invert");
    __name2(tonelliShanks, "tonelliShanks");
    __name2(FpSqrt, "FpSqrt");
    FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    __name2(validateField, "validateField");
    __name2(FpPow, "FpPow");
    __name2(FpInvertBatch, "FpInvertBatch");
    __name2(FpLegendre, "FpLegendre");
    __name2(FpIsSquare, "FpIsSquare");
    __name2(nLength, "nLength");
    __name2(Field, "Field");
    __name2(getFieldBytesLength, "getFieldBytesLength");
    __name2(getMinHashLength, "getMinHashLength");
    __name2(mapHashToField, "mapHashToField");
  }
});
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
__name(constTimeNegate, "constTimeNegate");
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
__name(validateW, "validateW");
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
__name(calcWOpts, "calcWOpts");
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n4;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
__name(calcOffsets, "calcOffsets");
function validateMSMPoints(points, c2) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p2, i2) => {
    if (!(p2 instanceof c2))
      throw new Error("invalid point at index " + i2);
  });
}
__name(validateMSMPoints, "validateMSMPoints");
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s2, i2) => {
    if (!field.isValid(s2))
      throw new Error("invalid scalar at index " + i2);
  });
}
__name(validateMSMScalars, "validateMSMScalars");
function getW(P2) {
  return pointWindowSizes.get(P2) || 1;
}
__name(getW, "getW");
function wNAF(c2, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n2, p2 = c2.ZERO) {
      let d2 = elm;
      while (n2 > _0n4) {
        if (n2 & _1n4)
          p2 = p2.add(d2);
        d2 = d2.double();
        n2 >>= _1n4;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p2 = elm;
      let base = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p2;
        points.push(base);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base = base.add(p2);
          points.push(base);
        }
        p2 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      let p2 = c2.ZERO;
      let f2 = c2.BASE;
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          f2 = f2.add(constTimeNegate(isNegF, precomputes[offsetF]));
        } else {
          p2 = p2.add(constTimeNegate(isNeg, precomputes[offset]));
        }
      }
      return { p: p2, f: f2 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n2, acc = c2.ZERO) {
      const wo = calcWOpts(W, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n2 === _0n4)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      return acc;
    },
    getPrecomputes(W, P2, transform) {
      let comp = pointPrecomputes.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W);
        if (W !== 1)
          pointPrecomputes.set(P2, transform(comp));
      }
      return comp;
    },
    wNAFCached(P2, n2, transform) {
      const W = getW(P2);
      return this.wNAF(W, this.getPrecomputes(W, P2, transform), n2);
    },
    wNAFCachedUnsafe(P2, n2, transform, prev) {
      const W = getW(P2);
      if (W === 1)
        return this.unsafeLadder(P2, n2, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P2, transform), n2, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P2, W) {
      validateW(W, bits);
      pointWindowSizes.set(P2, W);
      pointPrecomputes.delete(P2);
    }
  };
}
__name(wNAF, "wNAF");
function pippenger(c2, fieldN, points, scalars) {
  validateMSMPoints(points, c2);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c2.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero);
    for (let j2 = 0; j2 < scalars.length; j2++) {
      const scalar = scalars[j2];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j2]);
    }
    let resI = zero;
    for (let j2 = buckets.length - 1, sumI = zero; j2 > 0; j2--) {
      sumI = sumI.add(buckets[j2]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j2 = 0; j2 < windowSize; j2++)
        sum = sum.double();
  }
  return sum;
}
__name(pippenger, "pippenger");
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
__name(validateBasic, "validateBasic");
var _0n4;
var _1n4;
var pointPrecomputes;
var pointWindowSizes;
var init_curve = __esm({
  "../node_modules/@noble/curves/esm/abstract/curve.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_modular();
    init_utils3();
    _0n4 = BigInt(0);
    _1n4 = BigInt(1);
    __name2(constTimeNegate, "constTimeNegate");
    __name2(validateW, "validateW");
    __name2(calcWOpts, "calcWOpts");
    __name2(calcOffsets, "calcOffsets");
    __name2(validateMSMPoints, "validateMSMPoints");
    __name2(validateMSMScalars, "validateMSMScalars");
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    pointWindowSizes = /* @__PURE__ */ new WeakMap();
    __name2(getW, "getW");
    __name2(wNAF, "wNAF");
    __name2(pippenger, "pippenger");
    __name2(validateBasic, "validateBasic");
  }
});
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
__name(validateSigVerOpts, "validateSigVerOpts");
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a: a2 } = opts;
  if (endo) {
    if (!Fp3.eql(a2, Fp3.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
__name(validatePointOpts, "validatePointOpts");
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes10 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a2 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a2.x), Fp3.toBytes(a2.y));
  });
  const fromBytes8 = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x2 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp3.sqr(x2);
    const x3 = Fp3.mul(x22, x2);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x2, a2)), b2);
  }
  __name(weierstrassEquation, "weierstrassEquation");
  __name2(weierstrassEquation, "weierstrassEquation");
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n5, CURVE.n);
  }
  __name(isWithinCurveOrder, "isWithinCurveOrder");
  __name2(isWithinCurveOrder, "isWithinCurveOrder");
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod(num, N);
    aInRange("private key", num, _1n5, N);
    return num;
  }
  __name(normPrivateKeyToScalar, "normPrivateKeyToScalar");
  __name2(normPrivateKeyToScalar, "normPrivateKeyToScalar");
  function aprjpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  __name(aprjpoint, "aprjpoint");
  __name2(aprjpoint, "aprjpoint");
  const toAffineMemo = memoized((p2, iz) => {
    const { px: x2, py: y2, pz: z2 } = p2;
    if (Fp3.eql(z2, Fp3.ONE))
      return { x: x2, y: y2 };
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z2);
    const ax = Fp3.mul(x2, iz);
    const ay = Fp3.mul(y2, iz);
    const zz = Fp3.mul(z2, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p2) => {
    if (p2.is0()) {
      if (CURVE.allowInfinityPoint && !Fp3.is0(p2.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y: y2 } = p2.toAffine();
    if (!Fp3.isValid(x2) || !Fp3.isValid(y2))
      throw new Error("bad point: x or y not FE");
    const left = Fp3.sqr(y2);
    const right = weierstrassEquation(x2);
    if (!Fp3.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point3 {
    constructor(px2, py, pz) {
      if (px2 == null || !Fp3.isValid(px2))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py) || Fp3.is0(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
      this.px = px2;
      this.py = py;
      this.pz = pz;
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y2 } = p2 || {};
      if (!p2 || !Fp3.isValid(x2) || !Fp3.isValid(y2))
        throw new Error("invalid affine point");
      if (p2 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = /* @__PURE__ */ __name2((i2) => Fp3.eql(i2, Fp3.ZERO), "is0");
      if (is0(x2) && is0(y2))
        return Point3.ZERO;
      return new Point3(x2, y2, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = FpInvertBatch(Fp3, points.map((p2) => p2.pz));
      return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex3) {
      const P2 = Point3.fromAffine(fromBytes8(ensureBytes("pointHex", hex3)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point3, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp3.mul(b2, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a2, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a2, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a2, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n2);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a2, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a2, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, n2, Point3.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", sc, _0n5, N);
      const I = Point3.ZERO;
      if (sc === _0n5)
        return I;
      if (this.is0() || sc === _1n5)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point3.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d2 = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d2);
        if (k2 & _1n5)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n5, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f2 } = this.wNAF(scalar);
        point = p2;
        fake = f2;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a2, b2) {
      const G = Point3.BASE;
      const mul = /* @__PURE__ */ __name2((P2, a3) => a3 === _0n5 || a3 === _1n5 || !P2.equals(G) ? P2.multiplyUnsafe(a3) : P2.multiply(a3), "mul");
      const sum = mul(this, a2).add(mul(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes10(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  __name(Point3, "Point3");
  __name2(Point3, "Point");
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
__name(weierstrassPoints, "weierstrassPoints");
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
__name(validateOpts, "validateOpts");
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function modN(a2) {
    return mod(a2, CURVE_ORDER);
  }
  __name(modN, "modN");
  __name2(modN, "modN");
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  __name(invN, "invN");
  __name2(invN, "invN");
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a2 = point.toAffine();
      const x2 = Fp3.toBytes(a2.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp3.toBytes(a2.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!inRange(x2, _1n5, Fp3.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3;
        try {
          y3 = Fp3.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp3.neg(y3);
        return { x: x2, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x: x2, y: y2 };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteHex = /* @__PURE__ */ __name2((num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength)), "numToNByteHex");
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  __name(isBiggerThanHalfOrder, "isBiggerThanHalfOrder");
  __name2(isBiggerThanHalfOrder, "isBiggerThanHalfOrder");
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  __name(normalizeS, "normalizeS");
  __name2(normalizeS, "normalizeS");
  const slcNum = /* @__PURE__ */ __name2((b2, from27, to3) => bytesToNumberBE(b2.slice(from27, to3)), "slcNum");
  class Signature {
    constructor(r3, s2, recovery) {
      aInRange("r", r3, _1n5, CURVE_ORDER);
      aInRange("s", s2, _1n5, CURVE_ORDER);
      this.r = r3;
      this.s = s2;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex3) {
      const l2 = CURVE.nByteLength;
      hex3 = ensureBytes("compactSignature", hex3, l2 * 2);
      return new Signature(slcNum(hex3, 0, l2), slcNum(hex3, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex3) {
      const { r: r3, s: s2 } = DER.toSig(ensureBytes("DER", hex3));
      return new Signature(r3, s2);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r3, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r3 + CURVE.n : r3;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point3.fromHex(prefix + numToNByteHex(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig(this);
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteHex(this.r) + numToNByteHex(this.s);
    }
  }
  __name(Signature, "Signature");
  __name2(Signature, "Signature");
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey2(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  __name(getPublicKey2, "getPublicKey2");
  __name2(getPublicKey2, "getPublicKey");
  function isProbPub(item) {
    const arr = isBytes2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  __name(isProbPub, "isProbPub");
  __name2(isProbPub, "isProbPub");
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point3.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  __name(getSharedSecret, "getSharedSecret");
  __name2(getSharedSecret, "getSharedSecret");
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + CURVE.nBitLength, num, _0n5, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  __name(int2octets, "int2octets");
  __name2(int2octets, "int2octets");
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash7, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash7(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes2(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes2(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r3 = modN(q.x);
      if (r3 === _0n5)
        return;
      const s2 = modN(ik * modN(m2 + r3 * d2));
      if (s2 === _0n5)
        return;
      let recovery = (q.x === r3 ? 0 : 2) | Number(q.y & _1n5);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature(r3, normS, recovery);
    }
    __name(k2sig, "k2sig");
    __name2(k2sig, "k2sig");
    return { seed, k2sig };
  }
  __name(prepSig, "prepSig");
  __name2(prepSig, "prepSig");
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign6(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  __name(sign6, "sign6");
  __name2(sign6, "sign");
  Point3.BASE._setWindowSize(8);
  function verify6(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format: format9 } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format9 !== void 0 && format9 !== "compact" && format9 !== "der")
      throw new Error("format must be compact or der");
    const isHex = typeof sg === "string" || isBytes2(sg);
    const isObj = !isHex && !format9 && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P2;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex) {
        try {
          if (format9 !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format9 !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P2 = Point3.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r3, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is = invN(s2);
    const u1 = modN(h2 * is);
    const u2 = modN(r3 * is);
    const R = Point3.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v2 = modN(R.x);
    return v2 === r3;
  }
  __name(verify6, "verify6");
  __name2(verify6, "verify");
  return {
    CURVE,
    getPublicKey: getPublicKey2,
    getSharedSecret,
    sign: sign6,
    verify: verify6,
    ProjectivePoint: Point3,
    Signature,
    utils: utils2
  };
}
__name(weierstrass, "weierstrass");
function SWUFpSqrtRatio(Fp3, Z) {
  const q = Fp3.ORDER;
  let l2 = _0n5;
  for (let o2 = q - _1n5; o2 % _2n3 === _0n5; o2 /= _2n3)
    l2 += _1n5;
  const c1 = l2;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q - _1n5) / _2n_pow_c1;
  const c3 = (c2 - _1n5) / _2n3;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z, c2);
  const c7 = Fp3.pow(Z, (c2 + _1n5) / _2n3);
  let sqrtRatio = /* @__PURE__ */ __name2((u2, v2) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v2, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v2);
    let tv5 = Fp3.mul(u2, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v2);
    tv3 = Fp3.mul(tv5, u2);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n5; i2--) {
      let tv52 = i2 - _2n3;
      tv52 = _2n3 << tv52 - _1n5;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  }, "sqrtRatio");
  if (Fp3.ORDER % _4n2 === _3n2) {
    const c12 = (Fp3.ORDER - _3n2) / _4n2;
    const c22 = Fp3.sqrt(Fp3.neg(Z));
    sqrtRatio = /* @__PURE__ */ __name2((u2, v2) => {
      let tv1 = Fp3.sqr(v2);
      const tv2 = Fp3.mul(u2, v2);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y2 = Fp3.mul(y1, c22);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v2);
      const isQR = Fp3.eql(tv3, u2);
      let y3 = Fp3.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y3 };
    }, "sqrtRatio");
  }
  return sqrtRatio;
}
__name(SWUFpSqrtRatio, "SWUFpSqrtRatio");
function mapToCurveSimpleSWU(Fp3, opts) {
  validateField(Fp3);
  if (!Fp3.isValid(opts.A) || !Fp3.isValid(opts.B) || !Fp3.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, opts.Z);
  if (!Fp3.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u2) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x2, y2;
    tv1 = Fp3.sqr(u2);
    tv1 = Fp3.mul(tv1, opts.Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, opts.B);
    tv4 = Fp3.cmov(opts.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, opts.A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, opts.A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, opts.B);
    tv2 = Fp3.add(tv2, tv5);
    x2 = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y2 = Fp3.mul(tv1, u2);
    y2 = Fp3.mul(y2, value);
    x2 = Fp3.cmov(x2, tv3, isValid);
    y2 = Fp3.cmov(y2, value, isValid);
    const e1 = Fp3.isOdd(u2) === Fp3.isOdd(y2);
    y2 = Fp3.cmov(Fp3.neg(y2), y2, e1);
    const tv4_inv = FpInvertBatch(Fp3, [tv4], true)[0];
    x2 = Fp3.mul(x2, tv4_inv);
    return { x: x2, y: y2 };
  };
}
__name(mapToCurveSimpleSWU, "mapToCurveSimpleSWU");
var DERErr;
var DER;
var _0n5;
var _1n5;
var _2n3;
var _3n2;
var _4n2;
var init_weierstrass = __esm({
  "../node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_curve();
    init_modular();
    init_utils3();
    __name2(validateSigVerOpts, "validateSigVerOpts");
    __name2(validatePointOpts, "validatePointOpts");
    DERErr = /* @__PURE__ */ __name(class extends Error {
      constructor(m2 = "") {
        super(m2);
      }
    }, "DERErr");
    __name2(DERErr, "DERErr");
    DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E2 } = DER;
          if (tag < 0 || tag > 256)
            throw new E2("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E2("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = numberToHexUnpadded(dataLen);
          if (len.length / 2 & 128)
            throw new E2("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
          const t2 = numberToHexUnpadded(tag);
          return t2 + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E2 } = DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E2("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E2("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length = 0;
          if (!isLong)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E2("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E2("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E2("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E2("tlv.decode(long): zero leftmost byte");
            for (const b2 of lengthBytes)
              length = length << 8 | b2;
            pos += lenLen;
            if (length < 128)
              throw new E2("tlv.decode(long): not minimal encoding");
          }
          const v2 = data.subarray(pos, pos + length);
          if (v2.length !== length)
            throw new E2("tlv.decode: wrong value length");
          return { v: v2, l: data.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E2 } = DER;
          if (num < _0n5)
            throw new E2("integer: negative integers are not allowed");
          let hex3 = numberToHexUnpadded(num);
          if (Number.parseInt(hex3[0], 16) & 8)
            hex3 = "00" + hex3;
          if (hex3.length & 1)
            throw new E2("unexpected DER parsing assertion: unpadded hex");
          return hex3;
        },
        decode(data) {
          const { Err: E2 } = DER;
          if (data[0] & 128)
            throw new E2("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E2("invalid signature integer: unnecessary leading zero");
          return bytesToNumberBE(data);
        }
      },
      toSig(hex3) {
        const { Err: E2, _int: int2, _tlv: tlv } = DER;
        const data = ensureBytes("signature", hex3);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E2("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E2("invalid signature: left bytes after parsing");
        return { r: int2.decode(rBytes), s: int2.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int2 } = DER;
        const rs = tlv.encode(2, int2.encode(sig.r));
        const ss = tlv.encode(2, int2.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(48, seq);
      }
    };
    _0n5 = BigInt(0);
    _1n5 = BigInt(1);
    _2n3 = BigInt(2);
    _3n2 = BigInt(3);
    _4n2 = BigInt(4);
    __name2(weierstrassPoints, "weierstrassPoints");
    __name2(validateOpts, "validateOpts");
    __name2(weierstrass, "weierstrass");
    __name2(SWUFpSqrtRatio, "SWUFpSqrtRatio");
    __name2(mapToCurveSimpleSWU, "mapToCurveSimpleSWU");
  }
});
function getHash(hash7) {
  return {
    hash: hash7,
    hmac: (key, ...msgs) => hmac(hash7, key, concatBytes(...msgs)),
    randomBytes
  };
}
__name(getHash, "getHash");
function createCurve(curveDef, defHash) {
  const create4 = /* @__PURE__ */ __name2((hash7) => weierstrass({ ...curveDef, ...getHash(hash7) }), "create");
  return { ...create4(defHash), create: create4 };
}
__name(createCurve, "createCurve");
var init_shortw_utils = __esm({
  "../node_modules/@noble/curves/esm/_shortw_utils.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_hmac();
    init_utils2();
    init_weierstrass();
    __name2(getHash, "getHash");
    __name2(createCurve, "createCurve");
  }
});
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i2 = length - 1; i2 >= 0; i2--) {
    res[i2] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
__name(i2osp, "i2osp");
function strxor(a2, b2) {
  const arr = new Uint8Array(a2.length);
  for (let i2 = 0; i2 < a2.length; i2++) {
    arr[i2] = a2[i2] ^ b2[i2];
  }
  return arr;
}
__name(strxor, "strxor");
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
__name(anum, "anum");
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b2 = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b2[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b2[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b2[i2] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b2);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
__name(expand_message_xmd, "expand_message_xmd");
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
__name(expand_message_xof, "expand_message_xof");
function hash_to_field(msg, count3, options2) {
  validateObject(options2, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p2, k, m: m2, hash: hash7, expand, DST: _DST } = options2;
  abytes2(msg);
  anum(count3);
  const DST = typeof _DST === "string" ? utf8ToBytes2(_DST) : _DST;
  const log2p = p2.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count3 * m2 * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash7);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash7);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u2 = new Array(count3);
  for (let i2 = 0; i2 < count3; i2++) {
    const e2 = new Array(m2);
    for (let j2 = 0; j2 < m2; j2++) {
      const elm_offset = L * (j2 + i2 * m2);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e2[j2] = mod(os2ip(tv), p2);
    }
    u2[i2] = e2;
  }
  return u2;
}
__name(hash_to_field, "hash_to_field");
function isogenyMap(field, map) {
  const coeff = map.map((i2) => Array.from(i2).reverse());
  return (x2, y2) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x2), i2)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x2 = field.mul(xn, xd_inv);
    y2 = field.mul(y2, field.mul(yn, yd_inv));
    return { x: x2, y: y2 };
  };
}
__name(isogenyMap, "isogenyMap");
function createHasher2(Point3, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num) {
    return Point3.fromAffine(mapToCurve(num));
  }
  __name(map, "map");
  __name2(map, "map");
  function clear(initial) {
    const P2 = initial.clearCofactor();
    if (P2.equals(Point3.ZERO))
      return Point3.ZERO;
    P2.assertValidity();
    return P2;
  }
  __name(clear, "clear");
  __name2(clear, "clear");
  return {
    defaults,
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options2) {
      const u2 = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options2 });
      const u0 = map(u2[0]);
      const u1 = map(u2[1]);
      return clear(u0.add(u1));
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options2) {
      const u2 = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options2 });
      return clear(map(u2[0]));
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i2 of scalars)
        if (typeof i2 !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    }
  };
}
__name(createHasher2, "createHasher2");
var os2ip;
var init_hash_to_curve = __esm({
  "../node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_modular();
    init_utils3();
    os2ip = bytesToNumberBE;
    __name2(i2osp, "i2osp");
    __name2(strxor, "strxor");
    __name2(anum, "anum");
    __name2(expand_message_xmd, "expand_message_xmd");
    __name2(expand_message_xof, "expand_message_xof");
    __name2(hash_to_field, "hash_to_field");
    __name2(isogenyMap, "isogenyMap");
    __name2(createHasher2, "createHasher");
  }
});
function sqrtMod(y2) {
  const P2 = secp256k1P;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P2;
  const b3 = b2 * b2 * y2 % P2;
  const b6 = pow2(b3, _3n6, P2) * b3 % P2;
  const b9 = pow2(b6, _3n6, P2) * b3 % P2;
  const b11 = pow2(b9, _2n4, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n6, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n4, P2);
  if (!Fpk1.eql(Fpk1.sqr(root), y2))
    throw new Error("Cannot find square root");
  return root;
}
__name(sqrtMod, "sqrtMod");
var secp256k1P;
var secp256k1N;
var _1n6;
var _2n4;
var divNearest;
var Fpk1;
var secp256k1;
var _0n6;
var Point;
var init_secp256k1 = __esm({
  "../node_modules/@noble/curves/esm/secp256k1.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sha2();
    init_shortw_utils();
    init_modular();
    secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    _1n6 = BigInt(1);
    _2n4 = BigInt(2);
    divNearest = /* @__PURE__ */ __name2((a2, b2) => (a2 + b2 / _2n4) / b2, "divNearest");
    __name2(sqrtMod, "sqrtMod");
    Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    secp256k1 = createCurve({
      a: BigInt(0),
      b: BigInt(7),
      Fp: Fpk1,
      n: secp256k1N,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      endo: {
        // Endomorphism, see above
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n2 = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n2);
          const c2 = divNearest(-b1 * k, n2);
          let k1 = mod(k - c1 * a1 - c2 * a2, n2);
          let k2 = mod(-c1 * b1 - c2 * b2, n2);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n2 - k1;
          if (k2neg)
            k2 = n2 - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256);
    _0n6 = BigInt(0);
    Point = secp256k1.ProjectivePoint;
  }
});
function assert5(signature, options2 = {}) {
  const { recovered } = options2;
  if (typeof signature.r === "undefined")
    throw new MissingPropertiesError({ signature });
  if (typeof signature.s === "undefined")
    throw new MissingPropertiesError({ signature });
  if (recovered && typeof signature.yParity === "undefined")
    throw new MissingPropertiesError({ signature });
  if (signature.r < 0n || signature.r > maxUint256)
    throw new InvalidRError({ value: signature.r });
  if (signature.s < 0n || signature.s > maxUint256)
    throw new InvalidSError({ value: signature.s });
  if (typeof signature.yParity === "number" && signature.yParity !== 0 && signature.yParity !== 1)
    throw new InvalidYParityError({ value: signature.yParity });
}
__name(assert5, "assert5");
function fromBytes4(signature) {
  return fromHex4(fromBytes(signature));
}
__name(fromBytes4, "fromBytes4");
function fromHex4(signature) {
  if (signature.length !== 130 && signature.length !== 132)
    throw new InvalidSerializedSizeError2({ signature });
  const r3 = BigInt(slice(signature, 0, 32));
  const s2 = BigInt(slice(signature, 32, 64));
  const yParity = (() => {
    const yParity2 = Number(`0x${signature.slice(130)}`);
    if (Number.isNaN(yParity2))
      return void 0;
    try {
      return vToYParity(yParity2);
    } catch {
      throw new InvalidYParityError({ value: yParity2 });
    }
  })();
  if (typeof yParity === "undefined")
    return {
      r: r3,
      s: s2
    };
  return {
    r: r3,
    s: s2,
    yParity
  };
}
__name(fromHex4, "fromHex4");
function extract(value) {
  if (typeof value.r === "undefined")
    return void 0;
  if (typeof value.s === "undefined")
    return void 0;
  return from13(value);
}
__name(extract, "extract");
function from13(signature) {
  const signature_ = (() => {
    if (typeof signature === "string")
      return fromHex4(signature);
    if (signature instanceof Uint8Array)
      return fromBytes4(signature);
    if (typeof signature.r === "string")
      return fromRpc(signature);
    if (signature.v)
      return fromLegacy(signature);
    return {
      r: signature.r,
      s: signature.s,
      ...typeof signature.yParity !== "undefined" ? { yParity: signature.yParity } : {}
    };
  })();
  assert5(signature_);
  return signature_;
}
__name(from13, "from13");
function fromDerBytes(signature) {
  return fromDerHex(fromBytes(signature));
}
__name(fromDerBytes, "fromDerBytes");
function fromDerHex(signature) {
  const { r: r3, s: s2 } = secp256k1.Signature.fromDER(from2(signature).slice(2));
  return { r: r3, s: s2 };
}
__name(fromDerHex, "fromDerHex");
function fromLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    yParity: vToYParity(signature.v)
  };
}
__name(fromLegacy, "fromLegacy");
function fromRpc(signature) {
  const yParity = (() => {
    const v2 = signature.v ? Number(signature.v) : void 0;
    let yParity2 = signature.yParity ? Number(signature.yParity) : void 0;
    if (typeof v2 === "number" && typeof yParity2 !== "number")
      yParity2 = vToYParity(v2);
    if (typeof yParity2 !== "number")
      throw new InvalidYParityError({ value: signature.yParity });
    return yParity2;
  })();
  return {
    r: BigInt(signature.r),
    s: BigInt(signature.s),
    yParity
  };
}
__name(fromRpc, "fromRpc");
function fromTuple(tuple) {
  const [yParity, r3, s2] = tuple;
  return from13({
    r: r3 === "0x" ? 0n : BigInt(r3),
    s: s2 === "0x" ? 0n : BigInt(s2),
    yParity: yParity === "0x" ? 0 : Number(yParity)
  });
}
__name(fromTuple, "fromTuple");
function toBytes5(signature) {
  return fromHex(toHex4(signature));
}
__name(toBytes5, "toBytes5");
function toHex4(signature) {
  assert5(signature);
  const r3 = signature.r;
  const s2 = signature.s;
  const signature_ = concat(
    fromNumber(r3, { size: 32 }),
    fromNumber(s2, { size: 32 }),
    // If the signature is recovered, add the recovery byte to the signature.
    typeof signature.yParity === "number" ? fromNumber(signature.yParity, { size: 1 }) : "0x"
  );
  return signature_;
}
__name(toHex4, "toHex4");
function toDerBytes(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return sig.toDERRawBytes();
}
__name(toDerBytes, "toDerBytes");
function toDerHex(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return `0x${sig.toDERHex()}`;
}
__name(toDerHex, "toDerHex");
function toLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    v: yParityToV(signature.yParity)
  };
}
__name(toLegacy, "toLegacy");
function toRpc(signature) {
  const { r: r3, s: s2, yParity } = signature;
  return {
    r: fromNumber(r3, { size: 32 }),
    s: fromNumber(s2, { size: 32 }),
    yParity: yParity === 0 ? "0x0" : "0x1"
  };
}
__name(toRpc, "toRpc");
function toTuple(signature) {
  const { r: r3, s: s2, yParity } = signature;
  return [
    yParity ? "0x01" : "0x",
    r3 === 0n ? "0x" : trimLeft(fromNumber(r3)),
    s2 === 0n ? "0x" : trimLeft(fromNumber(s2))
  ];
}
__name(toTuple, "toTuple");
function vToYParity(v2) {
  if (v2 === 0 || v2 === 27)
    return 0;
  if (v2 === 1 || v2 === 28)
    return 1;
  if (v2 >= 35)
    return v2 % 2 === 0 ? 1 : 0;
  throw new InvalidVError({ value: v2 });
}
__name(vToYParity, "vToYParity");
function yParityToV(yParity) {
  if (yParity === 0)
    return 27;
  if (yParity === 1)
    return 28;
  throw new InvalidYParityError({ value: yParity });
}
__name(yParityToV, "yParityToV");
var InvalidSerializedSizeError2;
var MissingPropertiesError;
var InvalidRError;
var InvalidSError;
var InvalidYParityError;
var InvalidVError;
var init_Signature = __esm({
  "../node_modules/ox/_esm/core/Signature.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_secp256k1();
    init_Bytes();
    init_Errors();
    init_Hex();
    init_Json();
    init_Solidity();
    __name2(assert5, "assert");
    __name2(fromBytes4, "fromBytes");
    fromBytes4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromHex4, "fromHex");
    fromHex4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(extract, "extract");
    extract.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from13, "from");
    from13.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromDerBytes, "fromDerBytes");
    fromDerBytes.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromDerHex, "fromDerHex");
    fromDerHex.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromLegacy, "fromLegacy");
    fromLegacy.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromRpc, "fromRpc");
    fromRpc.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromTuple, "fromTuple");
    fromTuple.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toBytes5, "toBytes");
    toBytes5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toHex4, "toHex");
    toHex4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toDerBytes, "toDerBytes");
    toDerBytes.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toDerHex, "toDerHex");
    toDerHex.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toLegacy, "toLegacy");
    toLegacy.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc, "toRpc");
    toRpc.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toTuple, "toTuple");
    __name2(vToYParity, "vToYParity");
    vToYParity.parseError = (error) => error;
    __name2(yParityToV, "yParityToV");
    yParityToV.parseError = (error) => error;
    InvalidSerializedSizeError2 = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ signature }) {
        super(`Value \`${signature}\` is an invalid signature size.`, {
          metaMessages: [
            "Expected: 64 bytes or 65 bytes.",
            `Received ${size2(from2(signature))} bytes.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Signature.InvalidSerializedSizeError"
        });
      }
    }, "InvalidSerializedSizeError2");
    __name2(InvalidSerializedSizeError2, "InvalidSerializedSizeError");
    MissingPropertiesError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ signature }) {
        super(`Signature \`${stringify(signature)}\` is missing either an \`r\`, \`s\`, or \`yParity\` property.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Signature.MissingPropertiesError"
        });
      }
    }, "MissingPropertiesError");
    __name2(MissingPropertiesError, "MissingPropertiesError");
    InvalidRError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ value }) {
        super(`Value \`${value}\` is an invalid r value. r must be a positive integer less than 2^256.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Signature.InvalidRError"
        });
      }
    }, "InvalidRError");
    __name2(InvalidRError, "InvalidRError");
    InvalidSError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ value }) {
        super(`Value \`${value}\` is an invalid s value. s must be a positive integer less than 2^256.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Signature.InvalidSError"
        });
      }
    }, "InvalidSError");
    __name2(InvalidSError, "InvalidSError");
    InvalidYParityError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ value }) {
        super(`Value \`${value}\` is an invalid y-parity value. Y-parity must be 0 or 1.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Signature.InvalidYParityError"
        });
      }
    }, "InvalidYParityError");
    __name2(InvalidYParityError, "InvalidYParityError");
    InvalidVError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ value }) {
        super(`Value \`${value}\` is an invalid v value. v must be 27, 28 or >=35.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Signature.InvalidVError"
        });
      }
    }, "InvalidVError");
    __name2(InvalidVError, "InvalidVError");
  }
});
function from14(authorization, options2 = {}) {
  if (typeof authorization.chainId === "string")
    return fromRpc2(authorization);
  return { ...authorization, ...options2.signature };
}
__name(from14, "from14");
function fromRpc2(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract(authorization);
  return {
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  };
}
__name(fromRpc2, "fromRpc2");
function fromRpcList(authorizationList) {
  return authorizationList.map(fromRpc2);
}
__name(fromRpcList, "fromRpcList");
function fromTuple2(tuple) {
  const [chainId, address, nonce, yParity, r3, s2] = tuple;
  const signature = yParity && r3 && s2 ? fromTuple([yParity, r3, s2]) : void 0;
  return from14({
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  });
}
__name(fromTuple2, "fromTuple2");
function fromTupleList2(tupleList) {
  const list = [];
  for (const tuple of tupleList)
    list.push(fromTuple2(tuple));
  return list;
}
__name(fromTupleList2, "fromTupleList2");
function getSignPayload(authorization) {
  return hash(authorization);
}
__name(getSignPayload, "getSignPayload");
function hash(authorization) {
  return keccak256(concat("0x05", fromHex3(toTuple2(authorization))));
}
__name(hash, "hash");
function toRpc2(authorization) {
  const { address, chainId, nonce, ...signature } = authorization;
  return {
    address,
    chainId: fromNumber(chainId),
    nonce: fromNumber(nonce),
    ...toRpc(signature)
  };
}
__name(toRpc2, "toRpc2");
function toRpcList(authorizationList) {
  return authorizationList.map(toRpc2);
}
__name(toRpcList, "toRpcList");
function toTuple2(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract(authorization);
  return [
    chainId ? fromNumber(chainId) : "0x",
    address,
    nonce ? fromNumber(nonce) : "0x",
    ...signature ? toTuple(signature) : []
  ];
}
__name(toTuple2, "toTuple2");
function toTupleList2(list) {
  if (!list || list.length === 0)
    return [];
  const tupleList = [];
  for (const authorization of list)
    tupleList.push(toTuple2(authorization));
  return tupleList;
}
__name(toTupleList2, "toTupleList2");
var init_Authorization = __esm({
  "../node_modules/ox/_esm/core/Authorization.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hash();
    init_Hex();
    init_Rlp();
    init_Signature();
    __name2(from14, "from");
    from14.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromRpc2, "fromRpc");
    fromRpc2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromRpcList, "fromRpcList");
    fromRpcList.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromTuple2, "fromTuple");
    fromTuple2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromTupleList2, "fromTupleList");
    fromTupleList2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSignPayload, "getSignPayload");
    getSignPayload.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(hash, "hash");
    hash.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc2, "toRpc");
    toRpc2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpcList, "toRpcList");
    toRpcList.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toTuple2, "toTuple");
    toTuple2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toTupleList2, "toTupleList");
    toTupleList2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function from15(value) {
  let bytes = from3(value);
  let integer = (() => {
    let hex3 = value;
    if (value instanceof Uint8Array)
      hex3 = fromBytes(bytes);
    return BigInt(hex3);
  })();
  let result = "";
  while (integer > 0n) {
    const remainder = Number(integer % 58n);
    integer = integer / 58n;
    result = integerToAlphabet[remainder] + result;
  }
  while (bytes.length > 1 && bytes[0] === 0) {
    result = "1" + result;
    bytes = bytes.slice(1);
  }
  return result;
}
__name(from15, "from15");
var integerToAlphabet;
var alphabetToInteger;
var init_base58 = __esm({
  "../node_modules/ox/_esm/core/internal/base58.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Hex();
    integerToAlphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    alphabetToInteger = /* __PURE__ */
    Object.freeze({
      1: 0n,
      2: 1n,
      3: 2n,
      4: 3n,
      5: 4n,
      6: 5n,
      7: 6n,
      8: 7n,
      9: 8n,
      A: 9n,
      B: 10n,
      C: 11n,
      D: 12n,
      E: 13n,
      F: 14n,
      G: 15n,
      H: 16n,
      J: 17n,
      K: 18n,
      L: 19n,
      M: 20n,
      N: 21n,
      P: 22n,
      Q: 23n,
      R: 24n,
      S: 25n,
      T: 26n,
      U: 27n,
      V: 28n,
      W: 29n,
      X: 30n,
      Y: 31n,
      Z: 32n,
      a: 33n,
      b: 34n,
      c: 35n,
      d: 36n,
      e: 37n,
      f: 38n,
      g: 39n,
      h: 40n,
      i: 41n,
      j: 42n,
      k: 43n,
      m: 44n,
      n: 45n,
      o: 46n,
      p: 47n,
      q: 48n,
      r: 49n,
      s: 50n,
      t: 51n,
      u: 52n,
      v: 53n,
      w: 54n,
      x: 55n,
      y: 56n,
      z: 57n
    });
    __name2(from15, "from");
    from15.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function fromBytes5(value) {
  return from15(value);
}
__name(fromBytes5, "fromBytes5");
function fromHex5(value) {
  return from15(value);
}
__name(fromHex5, "fromHex5");
function fromString3(value) {
  return from15(fromString2(value));
}
__name(fromString3, "fromString3");
function toBytes6(value) {
  return fromHex(toHex5(value));
}
__name(toBytes6, "toBytes6");
function toHex5(value) {
  let integer = BigInt(0);
  let pad3 = 0;
  let checkPad = true;
  for (let i2 = 0; i2 < value.length; i2++) {
    const char = value[i2];
    if (checkPad && char === "1")
      pad3++;
    else
      checkPad = false;
    if (typeof alphabetToInteger[char] !== "bigint")
      throw new Error("invalid base58 character: " + char);
    integer = integer * 58n;
    integer = integer + alphabetToInteger[char];
  }
  if (!pad3)
    return `0x${integer.toString(16)}`;
  return `0x${"0".repeat(pad3 * 2)}${integer.toString(16)}`;
}
__name(toHex5, "toHex5");
function toString3(value) {
  return toString(toHex5(value));
}
__name(toString3, "toString3");
var init_Base58 = __esm({
  "../node_modules/ox/_esm/core/Base58.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Hex();
    init_base58();
    __name2(fromBytes5, "fromBytes");
    fromBytes5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromHex5, "fromHex");
    fromHex5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromString3, "fromString");
    fromString3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toBytes6, "toBytes");
    toBytes6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toHex5, "toHex");
    toHex5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toString3, "toString");
    toString3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function fromBytes6(value, options2 = {}) {
  const { pad: pad3 = true, url = false } = options2;
  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4);
  for (let i2 = 0, j2 = 0; j2 < value.length; i2 += 4, j2 += 3) {
    const y2 = (value[j2] << 16) + (value[j2 + 1] << 8) + (value[j2 + 2] | 0);
    encoded[i2] = integerToCharacter[y2 >> 18];
    encoded[i2 + 1] = integerToCharacter[y2 >> 12 & 63];
    encoded[i2 + 2] = integerToCharacter[y2 >> 6 & 63];
    encoded[i2 + 3] = integerToCharacter[y2 & 63];
  }
  const k = value.length % 3;
  const end = Math.floor(value.length / 3) * 4 + (k && k + 1);
  let base642 = decoder2.decode(new Uint8Array(encoded.buffer, 0, end));
  if (pad3 && k === 1)
    base642 += "==";
  if (pad3 && k === 2)
    base642 += "=";
  if (url)
    base642 = base642.replaceAll("+", "-").replaceAll("/", "_");
  return base642;
}
__name(fromBytes6, "fromBytes6");
function fromHex6(value, options2 = {}) {
  return fromBytes6(fromHex(value), options2);
}
__name(fromHex6, "fromHex6");
function fromString4(value, options2 = {}) {
  return fromBytes6(fromString2(value), options2);
}
__name(fromString4, "fromString4");
function toBytes7(value) {
  const base642 = value.replace(/=+$/, "");
  const size3 = base642.length;
  const decoded = new Uint8Array(size3 + 3);
  encoder3.encodeInto(base642 + "===", decoded);
  for (let i2 = 0, j2 = 0; i2 < base642.length; i2 += 4, j2 += 3) {
    const x2 = (characterToInteger[decoded[i2]] << 18) + (characterToInteger[decoded[i2 + 1]] << 12) + (characterToInteger[decoded[i2 + 2]] << 6) + characterToInteger[decoded[i2 + 3]];
    decoded[j2] = x2 >> 16;
    decoded[j2 + 1] = x2 >> 8 & 255;
    decoded[j2 + 2] = x2 & 255;
  }
  const decodedSize = (size3 >> 2) * 3 + (size3 % 4 && size3 % 4 - 1);
  return new Uint8Array(decoded.buffer, 0, decodedSize);
}
__name(toBytes7, "toBytes7");
function toHex6(value) {
  return fromBytes(toBytes7(value));
}
__name(toHex6, "toHex6");
function toString4(value) {
  return toString2(toBytes7(value));
}
__name(toString4, "toString4");
var encoder3;
var decoder2;
var integerToCharacter;
var characterToInteger;
var init_Base64 = __esm({
  "../node_modules/ox/_esm/core/Base64.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Hex();
    encoder3 = /* @__PURE__ */ new TextEncoder();
    decoder2 = /* @__PURE__ */ new TextDecoder();
    integerToCharacter = /* @__PURE__ */ Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a2, i2) => [i2, a2.charCodeAt(0)]));
    characterToInteger = {
      ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a2, i2) => [a2.charCodeAt(0), i2])),
      ["=".charCodeAt(0)]: 0,
      ["-".charCodeAt(0)]: 62,
      ["_".charCodeAt(0)]: 63
    };
    __name2(fromBytes6, "fromBytes");
    fromBytes6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromHex6, "fromHex");
    fromHex6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromString4, "fromString");
    fromString4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toBytes7, "toBytes");
    toBytes7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toHex6, "toHex");
    toHex6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toString4, "toString");
    toString4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function from16(value) {
  const { blobToKzgCommitment, computeBlobKzgProof } = value;
  return {
    blobToKzgCommitment,
    computeBlobKzgProof
  };
}
__name(from16, "from16");
var versionedHashVersion;
var init_Kzg = __esm({
  "../node_modules/ox/_esm/core/Kzg.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    versionedHashVersion = 1;
    __name2(from16, "from");
    from16.parseError = (error) => error;
  }
});
function commitmentsToVersionedHashes(commitments, options2 = {}) {
  const { version: version3 } = options2;
  const as = options2.as ?? (typeof commitments[0] === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash(commitment, {
      as,
      version: version3
    }));
  }
  return hashes;
}
__name(commitmentsToVersionedHashes, "commitmentsToVersionedHashes");
function commitmentToVersionedHash(commitment, options2 = {}) {
  const { version: version3 = 1 } = options2;
  const as = options2.as ?? (typeof commitment === "string" ? "Hex" : "Bytes");
  const versionedHash = sha2563(commitment, { as: "Bytes" });
  versionedHash.set([version3], 0);
  return as === "Bytes" ? versionedHash : fromBytes(versionedHash);
}
__name(commitmentToVersionedHash, "commitmentToVersionedHash");
function from17(data, options2 = {}) {
  const as = options2.as ?? (typeof data === "string" ? "Hex" : "Bytes");
  const data_ = typeof data === "string" ? fromHex(data) : data;
  const size_ = size(data_);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = create(new Uint8Array(bytesPerBlob));
    let size3 = 0;
    while (size3 < fieldElementsPerBlob) {
      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size3++;
      position += 31;
    }
    blobs.push(blob);
  }
  return as === "Bytes" ? blobs.map((x2) => x2.bytes) : blobs.map((x2) => fromBytes(x2.bytes));
}
__name(from17, "from17");
function sidecarsToVersionedHashes(sidecars, options2 = {}) {
  const { version: version3 } = options2;
  const as = options2.as ?? (typeof sidecars[0].blob === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const { commitment } of sidecars) {
    hashes.push(commitmentToVersionedHash(commitment, {
      as,
      version: version3
    }));
  }
  return hashes;
}
__name(sidecarsToVersionedHashes, "sidecarsToVersionedHashes");
function to2(blobs, to3) {
  const to_ = to3 ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x2) => fromHex(x2)) : blobs;
  const length = blobs_.reduce((length2, blob) => length2 + blob.length, 0);
  const data = create(new Uint8Array(length));
  let active = true;
  for (const blob of blobs_) {
    const cursor = create(blob);
    while (active && cursor.position < blob.length) {
      cursor.incrementPosition(1);
      let consume = 31;
      if (blob.length - cursor.position < 31)
        consume = blob.length - cursor.position;
      for (const _ in Array.from({ length: consume })) {
        const byte = cursor.readByte();
        const isTerminator = byte === 128 && !cursor.inspectBytes(cursor.remaining).includes(128);
        if (isTerminator) {
          active = false;
          break;
        }
        data.pushByte(byte);
      }
    }
  }
  const trimmedData = data.bytes.slice(0, data.position);
  return to_ === "Hex" ? fromBytes(trimmedData) : trimmedData;
}
__name(to2, "to2");
function toHex7(blobs) {
  return to2(blobs, "Hex");
}
__name(toHex7, "toHex7");
function toBytes8(blobs) {
  return to2(blobs, "Bytes");
}
__name(toBytes8, "toBytes8");
function toCommitments(blobs, options2) {
  const { kzg } = options2;
  const as = options2.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x2) => fromHex(x2)) : blobs;
  const commitments = [];
  for (const blob of blobs_)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return as === "Bytes" ? commitments : commitments.map((x2) => fromBytes(x2));
}
__name(toCommitments, "toCommitments");
function toProofs(blobs, options2) {
  const { kzg } = options2;
  const as = options2.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x2) => fromHex(x2)) : blobs;
  const commitments = typeof options2.commitments[0] === "string" ? options2.commitments.map((x2) => fromHex(x2)) : options2.commitments;
  const proofs = [];
  for (let i2 = 0; i2 < blobs_.length; i2++) {
    const blob = blobs_[i2];
    const commitment = commitments[i2];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return as === "Bytes" ? proofs : proofs.map((x2) => fromBytes(x2));
}
__name(toProofs, "toProofs");
function toSidecars(blobs, options2) {
  const { kzg } = options2;
  const commitments = options2.commitments ?? toCommitments(blobs, { kzg });
  const proofs = options2.proofs ?? toProofs(blobs, { commitments, kzg });
  const sidecars = [];
  for (let i2 = 0; i2 < blobs.length; i2++)
    sidecars.push({
      blob: blobs[i2],
      commitment: commitments[i2],
      proof: proofs[i2]
    });
  return sidecars;
}
__name(toSidecars, "toSidecars");
function toVersionedHashes(blobs, options2) {
  const commitments = toCommitments(blobs, options2);
  return commitmentsToVersionedHashes(commitments, options2);
}
__name(toVersionedHashes, "toVersionedHashes");
var blobsPerTransaction;
var bytesPerFieldElement;
var fieldElementsPerBlob;
var bytesPerBlob;
var maxBytesPerTransaction;
var BlobSizeTooLargeError;
var EmptyBlobError;
var EmptyBlobVersionedHashesError;
var InvalidVersionedHashSizeError;
var InvalidVersionedHashVersionError;
var init_Blobs = __esm({
  "../node_modules/ox/_esm/core/Blobs.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Errors();
    init_Hash();
    init_Hex();
    init_Kzg();
    init_cursor();
    blobsPerTransaction = 6;
    bytesPerFieldElement = 32;
    fieldElementsPerBlob = 4096;
    bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
    maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
    1 - // zero byte (0x00) appended to each field element.
    1 * fieldElementsPerBlob * blobsPerTransaction;
    __name2(commitmentsToVersionedHashes, "commitmentsToVersionedHashes");
    commitmentsToVersionedHashes.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(commitmentToVersionedHash, "commitmentToVersionedHash");
    commitmentToVersionedHash.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from17, "from");
    from17.parseError = (error) => error;
    __name2(sidecarsToVersionedHashes, "sidecarsToVersionedHashes");
    sidecarsToVersionedHashes.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(to2, "to");
    to2.parseError = (error) => error;
    __name2(toHex7, "toHex");
    toHex7.parseError = (error) => error;
    __name2(toBytes8, "toBytes");
    toBytes8.parseError = (error) => error;
    __name2(toCommitments, "toCommitments");
    toCommitments.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toProofs, "toProofs");
    toProofs.parseError = (error) => error;
    __name2(toSidecars, "toSidecars");
    toSidecars.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toVersionedHashes, "toVersionedHashes");
    toVersionedHashes.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    BlobSizeTooLargeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ maxSize, size: size3 }) {
        super("Blob size is too large.", {
          metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size3} bytes`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Blobs.BlobSizeTooLargeError"
        });
      }
    }, "BlobSizeTooLargeError");
    __name2(BlobSizeTooLargeError, "BlobSizeTooLargeError");
    EmptyBlobError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("Blob data must not be empty.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Blobs.EmptyBlobError"
        });
      }
    }, "EmptyBlobError");
    __name2(EmptyBlobError, "EmptyBlobError");
    EmptyBlobVersionedHashesError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("Blob versioned hashes must not be empty.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Blobs.EmptyBlobVersionedHashesError"
        });
      }
    }, "EmptyBlobVersionedHashesError");
    __name2(EmptyBlobVersionedHashesError, "EmptyBlobVersionedHashesError");
    InvalidVersionedHashSizeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ hash: hash7, size: size3 }) {
        super(`Versioned hash "${hash7}" size is invalid.`, {
          metaMessages: ["Expected: 32", `Received: ${size3}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Blobs.InvalidVersionedHashSizeError"
        });
      }
    }, "InvalidVersionedHashSizeError");
    __name2(InvalidVersionedHashSizeError, "InvalidVersionedHashSizeError");
    InvalidVersionedHashVersionError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ hash: hash7, version: version3 }) {
        super(`Versioned hash "${hash7}" version is invalid.`, {
          metaMessages: [
            `Expected: ${versionedHashVersion}`,
            `Received: ${version3}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Blobs.InvalidVersionedHashVersionError"
        });
      }
    }, "InvalidVersionedHashVersionError");
    __name2(InvalidVersionedHashVersionError, "InvalidVersionedHashVersionError");
  }
});
function fromRpc3(transaction, _options = {}) {
  if (!transaction)
    return null;
  const signature = extract(transaction);
  const transaction_ = {
    ...transaction,
    ...signature
  };
  transaction_.blockNumber = transaction.blockNumber ? BigInt(transaction.blockNumber) : null;
  transaction_.data = transaction.input;
  transaction_.gas = BigInt(transaction.gas ?? 0n);
  transaction_.nonce = BigInt(transaction.nonce ?? 0n);
  transaction_.transactionIndex = transaction.transactionIndex ? Number(transaction.transactionIndex) : null;
  transaction_.value = BigInt(transaction.value ?? 0n);
  if (transaction.authorizationList)
    transaction_.authorizationList = fromRpcList(transaction.authorizationList);
  if (transaction.chainId)
    transaction_.chainId = Number(transaction.chainId);
  if (transaction.gasPrice)
    transaction_.gasPrice = BigInt(transaction.gasPrice);
  if (transaction.maxFeePerBlobGas)
    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);
  if (transaction.maxFeePerGas)
    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);
  if (transaction.maxPriorityFeePerGas)
    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);
  if (transaction.type)
    transaction_.type = fromRpcType[transaction.type] ?? transaction.type;
  if (signature)
    transaction_.v = yParityToV(signature.yParity);
  return transaction_;
}
__name(fromRpc3, "fromRpc3");
function toRpc3(transaction, _options) {
  const rpc = {};
  rpc.blockHash = transaction.blockHash;
  rpc.blockNumber = typeof transaction.blockNumber === "bigint" ? fromNumber(transaction.blockNumber) : null;
  rpc.from = transaction.from;
  rpc.gas = fromNumber(transaction.gas ?? 0n);
  rpc.hash = transaction.hash;
  rpc.input = transaction.input;
  rpc.nonce = fromNumber(transaction.nonce ?? 0n);
  rpc.to = transaction.to;
  rpc.transactionIndex = transaction.transactionIndex ? fromNumber(transaction.transactionIndex) : null;
  rpc.type = toRpcType[transaction.type] ?? transaction.type;
  rpc.value = fromNumber(transaction.value ?? 0n);
  if (transaction.accessList)
    rpc.accessList = transaction.accessList;
  if (transaction.authorizationList)
    rpc.authorizationList = toRpcList(transaction.authorizationList);
  if (transaction.blobVersionedHashes)
    rpc.blobVersionedHashes = transaction.blobVersionedHashes;
  if (transaction.chainId)
    rpc.chainId = fromNumber(transaction.chainId);
  if (typeof transaction.gasPrice === "bigint")
    rpc.gasPrice = fromNumber(transaction.gasPrice);
  if (typeof transaction.maxFeePerBlobGas === "bigint")
    rpc.maxFeePerBlobGas = fromNumber(transaction.maxFeePerBlobGas);
  if (typeof transaction.maxFeePerGas === "bigint")
    rpc.maxFeePerGas = fromNumber(transaction.maxFeePerGas);
  if (typeof transaction.maxPriorityFeePerGas === "bigint")
    rpc.maxPriorityFeePerGas = fromNumber(transaction.maxPriorityFeePerGas);
  if (typeof transaction.r === "bigint")
    rpc.r = fromNumber(transaction.r, { size: 32 });
  if (typeof transaction.s === "bigint")
    rpc.s = fromNumber(transaction.s, { size: 32 });
  if (typeof transaction.v === "number")
    rpc.v = fromNumber(transaction.v, { size: 1 });
  if (typeof transaction.yParity === "number")
    rpc.yParity = transaction.yParity === 0 ? "0x0" : "0x1";
  return rpc;
}
__name(toRpc3, "toRpc3");
var toRpcType;
var fromRpcType;
var init_Transaction = __esm({
  "../node_modules/ox/_esm/core/Transaction.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Authorization();
    init_Hex();
    init_Signature();
    toRpcType = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2",
      eip4844: "0x3",
      eip7702: "0x4"
    };
    fromRpcType = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559",
      "0x3": "eip4844",
      "0x4": "eip7702"
    };
    __name2(fromRpc3, "fromRpc");
    fromRpc3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc3, "toRpc");
    toRpc3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function fromRpc4(withdrawal) {
  return {
    ...withdrawal,
    amount: BigInt(withdrawal.amount),
    index: Number(withdrawal.index),
    validatorIndex: Number(withdrawal.validatorIndex)
  };
}
__name(fromRpc4, "fromRpc4");
function toRpc4(withdrawal) {
  return {
    address: withdrawal.address,
    amount: fromNumber(withdrawal.amount),
    index: fromNumber(withdrawal.index),
    validatorIndex: fromNumber(withdrawal.validatorIndex)
  };
}
__name(toRpc4, "toRpc4");
var init_Withdrawal = __esm({
  "../node_modules/ox/_esm/core/Withdrawal.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    __name2(fromRpc4, "fromRpc");
    fromRpc4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc4, "toRpc");
    toRpc4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function toRpc5(block, _options = {}) {
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return toRpc3(transaction);
  });
  return {
    baseFeePerGas: typeof block.baseFeePerGas === "bigint" ? fromNumber(block.baseFeePerGas) : void 0,
    blobGasUsed: typeof block.blobGasUsed === "bigint" ? fromNumber(block.blobGasUsed) : void 0,
    excessBlobGas: typeof block.excessBlobGas === "bigint" ? fromNumber(block.excessBlobGas) : void 0,
    extraData: block.extraData,
    difficulty: typeof block.difficulty === "bigint" ? fromNumber(block.difficulty) : void 0,
    gasLimit: fromNumber(block.gasLimit),
    gasUsed: fromNumber(block.gasUsed),
    hash: block.hash,
    logsBloom: block.logsBloom,
    miner: block.miner,
    mixHash: block.mixHash,
    nonce: block.nonce,
    number: typeof block.number === "bigint" ? fromNumber(block.number) : null,
    parentBeaconBlockRoot: block.parentBeaconBlockRoot,
    parentHash: block.parentHash,
    receiptsRoot: block.receiptsRoot,
    sealFields: block.sealFields,
    sha3Uncles: block.sha3Uncles,
    size: fromNumber(block.size),
    stateRoot: block.stateRoot,
    timestamp: fromNumber(block.timestamp),
    totalDifficulty: typeof block.totalDifficulty === "bigint" ? fromNumber(block.totalDifficulty) : void 0,
    transactions,
    transactionsRoot: block.transactionsRoot,
    uncles: block.uncles,
    withdrawals: block.withdrawals?.map(toRpc4),
    withdrawalsRoot: block.withdrawalsRoot
  };
}
__name(toRpc5, "toRpc5");
function fromRpc5(block, _options = {}) {
  if (!block)
    return null;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return fromRpc3(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : void 0,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: BigInt(block.gasLimit ?? 0n),
    gasUsed: BigInt(block.gasUsed ?? 0n),
    number: block.number ? BigInt(block.number) : null,
    size: BigInt(block.size ?? 0n),
    stateRoot: block.stateRoot,
    timestamp: BigInt(block.timestamp ?? 0n),
    totalDifficulty: BigInt(block.totalDifficulty ?? 0n),
    transactions,
    withdrawals: block.withdrawals?.map(fromRpc4)
  };
}
__name(fromRpc5, "fromRpc5");
var init_Block = __esm({
  "../node_modules/ox/_esm/core/Block.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    init_Transaction();
    init_Withdrawal();
    __name2(toRpc5, "toRpc");
    toRpc5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromRpc5, "fromRpc");
    fromRpc5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function contains(bloom, input) {
  const filter2 = fromHex(bloom);
  const hash7 = keccak256(input, { as: "Bytes" });
  for (const i2 of [0, 2, 4]) {
    const bit = hash7[i2 + 1] + (hash7[i2] << 8) & 2047;
    if ((filter2[256 - 1 - Math.floor(bit / 8)] & 1 << bit % 8) === 0)
      return false;
  }
  return true;
}
__name(contains, "contains");
function validate5(value) {
  return validate(value) && size2(value) === 256;
}
__name(validate5, "validate5");
var init_Bloom = __esm({
  "../node_modules/ox/_esm/core/Bloom.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Bytes();
    init_Hash();
    init_Hex();
    __name2(contains, "contains");
    contains.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate5, "validate");
    validate5.parseError = (error) => error;
  }
});
function NAfDecomposition(a2) {
  const res = [];
  for (; a2 > _1n7; a2 >>= _1n7) {
    if ((a2 & _1n7) === _0n7)
      res.unshift(0);
    else if ((a2 & _3n3) === _3n3) {
      res.unshift(-1);
      a2 += _1n7;
    } else
      res.unshift(1);
  }
  return res;
}
__name(NAfDecomposition, "NAfDecomposition");
function bls(CURVE) {
  const { Fp: Fp3, Fr: Fr2, Fp2: Fp22, Fp6: Fp62, Fp12: Fp122 } = CURVE.fields;
  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;
  const TWIST = CURVE.params.twistType;
  const G1_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE.G1 });
  const G1 = Object.assign(G1_, createHasher2(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G1.htfDefaults
  }));
  const G2_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE.G2 });
  const G2 = Object.assign(G2_, createHasher2(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G2.htfDefaults
  }));
  let lineFunction;
  if (TWIST === "multiplicative") {
    lineFunction = /* @__PURE__ */ __name2((c0, c1, c2, f2, Px, Py) => Fp122.mul014(f2, c0, Fp22.mul(c1, Px), Fp22.mul(c2, Py)), "lineFunction");
  } else if (TWIST === "divisive") {
    lineFunction = /* @__PURE__ */ __name2((c0, c1, c2, f2, Px, Py) => Fp122.mul034(f2, Fp22.mul(c2, Py), Fp22.mul(c1, Px), c0), "lineFunction");
  } else
    throw new Error("bls: unknown twist type");
  const Fp2div2 = Fp22.div(Fp22.ONE, Fp22.mul(Fp22.ONE, _2n5));
  function pointDouble(ell, Rx, Ry, Rz) {
    const t0 = Fp22.sqr(Ry);
    const t1 = Fp22.sqr(Rz);
    const t2 = Fp22.mulByB(Fp22.mul(t1, _3n3));
    const t3 = Fp22.mul(t2, _3n3);
    const t4 = Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(Ry, Rz)), t1), t0);
    const c0 = Fp22.sub(t2, t0);
    const c1 = Fp22.mul(Fp22.sqr(Rx), _3n3);
    const c2 = Fp22.neg(t4);
    ell.push([c0, c1, c2]);
    Rx = Fp22.mul(Fp22.mul(Fp22.mul(Fp22.sub(t0, t3), Rx), Ry), Fp2div2);
    Ry = Fp22.sub(Fp22.sqr(Fp22.mul(Fp22.add(t0, t3), Fp2div2)), Fp22.mul(Fp22.sqr(t2), _3n3));
    Rz = Fp22.mul(t0, t4);
    return { Rx, Ry, Rz };
  }
  __name(pointDouble, "pointDouble");
  __name2(pointDouble, "pointDouble");
  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {
    const t0 = Fp22.sub(Ry, Fp22.mul(Qy, Rz));
    const t1 = Fp22.sub(Rx, Fp22.mul(Qx, Rz));
    const c0 = Fp22.sub(Fp22.mul(t0, Qx), Fp22.mul(t1, Qy));
    const c1 = Fp22.neg(t0);
    const c2 = t1;
    ell.push([c0, c1, c2]);
    const t2 = Fp22.sqr(t1);
    const t3 = Fp22.mul(t2, t1);
    const t4 = Fp22.mul(t2, Rx);
    const t5 = Fp22.add(Fp22.sub(t3, Fp22.mul(t4, _2n5)), Fp22.mul(Fp22.sqr(t0), Rz));
    Rx = Fp22.mul(t1, t5);
    Ry = Fp22.sub(Fp22.mul(Fp22.sub(t4, t5), t0), Fp22.mul(t3, Ry));
    Rz = Fp22.mul(Rz, t3);
    return { Rx, Ry, Rz };
  }
  __name(pointAdd, "pointAdd");
  __name2(pointAdd, "pointAdd");
  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);
  const calcPairingPrecomputes = memoized((point) => {
    const p2 = point;
    const { x: x2, y: y2 } = p2.toAffine();
    const Qx = x2, Qy = y2, negQy = Fp22.neg(y2);
    let Rx = Qx, Ry = Qy, Rz = Fp22.ONE;
    const ell = [];
    for (const bit of ATE_NAF) {
      const cur = [];
      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));
      if (bit)
        ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));
      ell.push(cur);
    }
    if (CURVE.postPrecompute) {
      const last = ell[ell.length - 1];
      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));
    }
    return ell;
  });
  function millerLoopBatch(pairs, withFinalExponent = false) {
    let f12 = Fp122.ONE;
    if (pairs.length) {
      const ellLen = pairs[0][0].length;
      for (let i2 = 0; i2 < ellLen; i2++) {
        f12 = Fp122.sqr(f12);
        for (const [ell, Px, Py] of pairs) {
          for (const [c0, c1, c2] of ell[i2])
            f12 = lineFunction(c0, c1, c2, f12, Px, Py);
        }
      }
    }
    if (BLS_X_IS_NEGATIVE)
      f12 = Fp122.conjugate(f12);
    return withFinalExponent ? Fp122.finalExponentiate(f12) : f12;
  }
  __name(millerLoopBatch, "millerLoopBatch");
  __name2(millerLoopBatch, "millerLoopBatch");
  function pairingBatch(pairs, withFinalExponent = true) {
    const res = [];
    G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));
    G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));
    for (const { g1, g2 } of pairs) {
      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))
        throw new Error("pairing is not available for ZERO point");
      g1.assertValidity();
      g2.assertValidity();
      const Qa = g1.toAffine();
      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);
    }
    return millerLoopBatch(res, withFinalExponent);
  }
  __name(pairingBatch, "pairingBatch");
  __name2(pairingBatch, "pairingBatch");
  function pairing(Q, P2, withFinalExponent = true) {
    return pairingBatch([{ g1: Q, g2: P2 }], withFinalExponent);
  }
  __name(pairing, "pairing");
  __name2(pairing, "pairing");
  const utils2 = {
    randomPrivateKey: () => {
      const length = getMinHashLength(Fr2.ORDER);
      return mapHashToField(CURVE.randomBytes(length), Fr2.ORDER);
    },
    calcPairingPrecomputes
  };
  const { ShortSignature } = CURVE.G1;
  const { Signature } = CURVE.G2;
  function normP1(point) {
    return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);
  }
  __name(normP1, "normP1");
  __name2(normP1, "normP1");
  function normP1Hash(point, htfOpts) {
    return point instanceof G1.ProjectivePoint ? point : G1.hashToCurve(ensureBytes("point", point), htfOpts);
  }
  __name(normP1Hash, "normP1Hash");
  __name2(normP1Hash, "normP1Hash");
  function normP2(point) {
    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);
  }
  __name(normP2, "normP2");
  __name2(normP2, "normP2");
  function normP2Hash(point, htfOpts) {
    return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve(ensureBytes("point", point), htfOpts);
  }
  __name(normP2Hash, "normP2Hash");
  __name2(normP2Hash, "normP2Hash");
  function getPublicKey2(privateKey) {
    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
  }
  __name(getPublicKey2, "getPublicKey2");
  __name2(getPublicKey2, "getPublicKey");
  function getPublicKeyForShortSignatures(privateKey) {
    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
  }
  __name(getPublicKeyForShortSignatures, "getPublicKeyForShortSignatures");
  __name2(getPublicKeyForShortSignatures, "getPublicKeyForShortSignatures");
  function sign6(message, privateKey, htfOpts) {
    const msgPoint = normP2Hash(message, htfOpts);
    msgPoint.assertValidity();
    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
    if (message instanceof G2.ProjectivePoint)
      return sigPoint;
    return Signature.toRawBytes(sigPoint);
  }
  __name(sign6, "sign6");
  __name2(sign6, "sign");
  function signShortSignature(message, privateKey, htfOpts) {
    const msgPoint = normP1Hash(message, htfOpts);
    msgPoint.assertValidity();
    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
    if (message instanceof G1.ProjectivePoint)
      return sigPoint;
    return ShortSignature.toRawBytes(sigPoint);
  }
  __name(signShortSignature, "signShortSignature");
  __name2(signShortSignature, "signShortSignature");
  function verify6(signature, message, publicKey, htfOpts) {
    const P2 = normP1(publicKey);
    const Hm = normP2Hash(message, htfOpts);
    const G = G1.ProjectivePoint.BASE;
    const S2 = normP2(signature);
    const exp = pairingBatch([
      { g1: P2.negate(), g2: Hm },
      // ePHM = pairing(P.negate(), Hm, false);
      { g1: G, g2: S2 }
      // eGS = pairing(G, S, false);
    ]);
    return Fp122.eql(exp, Fp122.ONE);
  }
  __name(verify6, "verify6");
  __name2(verify6, "verify");
  function verifyShortSignature(signature, message, publicKey, htfOpts) {
    const P2 = normP2(publicKey);
    const Hm = normP1Hash(message, htfOpts);
    const G = G2.ProjectivePoint.BASE;
    const S2 = normP1(signature);
    const exp = pairingBatch([
      { g1: Hm, g2: P2 },
      // eHmP = pairing(Hm, P, false);
      { g1: S2, g2: G.negate() }
      // eSG = pairing(S, G.negate(), false);
    ]);
    return Fp122.eql(exp, Fp122.ONE);
  }
  __name(verifyShortSignature, "verifyShortSignature");
  __name2(verifyShortSignature, "verifyShortSignature");
  function aNonEmpty(arr) {
    if (!Array.isArray(arr) || arr.length === 0)
      throw new Error("expected non-empty array");
  }
  __name(aNonEmpty, "aNonEmpty");
  __name2(aNonEmpty, "aNonEmpty");
  function aggregatePublicKeys(publicKeys) {
    aNonEmpty(publicKeys);
    const agg = publicKeys.map(normP1).reduce((sum, p2) => sum.add(p2), G1.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (publicKeys[0] instanceof G1.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return aggAffine.toRawBytes(true);
  }
  __name(aggregatePublicKeys, "aggregatePublicKeys");
  __name2(aggregatePublicKeys, "aggregatePublicKeys");
  function aggregateSignatures(signatures) {
    aNonEmpty(signatures);
    const agg = signatures.map(normP2).reduce((sum, s2) => sum.add(s2), G2.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (signatures[0] instanceof G2.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return Signature.toRawBytes(aggAffine);
  }
  __name(aggregateSignatures, "aggregateSignatures");
  __name2(aggregateSignatures, "aggregateSignatures");
  function aggregateShortSignatures(signatures) {
    aNonEmpty(signatures);
    const agg = signatures.map(normP1).reduce((sum, s2) => sum.add(s2), G1.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (signatures[0] instanceof G1.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return ShortSignature.toRawBytes(aggAffine);
  }
  __name(aggregateShortSignatures, "aggregateShortSignatures");
  __name2(aggregateShortSignatures, "aggregateShortSignatures");
  function verifyBatch(signature, messages, publicKeys, htfOpts) {
    aNonEmpty(messages);
    if (publicKeys.length !== messages.length)
      throw new Error("amount of public keys and messages should be equal");
    const sig = normP2(signature);
    const nMessages = messages.map((i2) => normP2Hash(i2, htfOpts));
    const nPublicKeys = publicKeys.map(normP1);
    const messagePubKeyMap = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < nPublicKeys.length; i2++) {
      const pub = nPublicKeys[i2];
      const msg = nMessages[i2];
      let keys = messagePubKeyMap.get(msg);
      if (keys === void 0) {
        keys = [];
        messagePubKeyMap.set(msg, keys);
      }
      keys.push(pub);
    }
    const paired = [];
    try {
      for (const [msg, keys] of messagePubKeyMap) {
        const groupPublicKey = keys.reduce((acc, msg2) => acc.add(msg2));
        paired.push({ g1: groupPublicKey, g2: msg });
      }
      paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });
      return Fp122.eql(pairingBatch(paired), Fp122.ONE);
    } catch {
      return false;
    }
  }
  __name(verifyBatch, "verifyBatch");
  __name2(verifyBatch, "verifyBatch");
  G1.ProjectivePoint.BASE._setWindowSize(4);
  return {
    getPublicKey: getPublicKey2,
    getPublicKeyForShortSignatures,
    sign: sign6,
    signShortSignature,
    verify: verify6,
    verifyBatch,
    verifyShortSignature,
    aggregatePublicKeys,
    aggregateSignatures,
    aggregateShortSignatures,
    millerLoopBatch,
    pairing,
    pairingBatch,
    G1,
    G2,
    Signature,
    ShortSignature,
    fields: {
      Fr: Fr2,
      Fp: Fp3,
      Fp2: Fp22,
      Fp6: Fp62,
      Fp12: Fp122
    },
    params: {
      ateLoopSize: CURVE.params.ateLoopSize,
      r: CURVE.params.r,
      G1b: CURVE.G1.b,
      G2b: CURVE.G2.b
    },
    utils: utils2
  };
}
__name(bls, "bls");
var _0n7;
var _1n7;
var _2n5;
var _3n3;
var init_bls = __esm({
  "../node_modules/@noble/curves/esm/abstract/bls.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_hash_to_curve();
    init_modular();
    init_utils3();
    init_weierstrass();
    _0n7 = BigInt(0);
    _1n7 = BigInt(1);
    _2n5 = BigInt(2);
    _3n3 = BigInt(3);
    __name2(NAfDecomposition, "NAfDecomposition");
    __name2(bls, "bls");
  }
});
function calcFrobeniusCoefficients(Fp3, nonResidue, modulus, degree, num = 1, divisor) {
  const _divisor = BigInt(divisor === void 0 ? degree : divisor);
  const towerModulus = modulus ** BigInt(degree);
  const res = [];
  for (let i2 = 0; i2 < num; i2++) {
    const a2 = BigInt(i2 + 1);
    const powers2 = [];
    for (let j2 = 0, qPower = _1n8; j2 < degree; j2++) {
      const power = (a2 * qPower - a2) / _divisor % towerModulus;
      powers2.push(Fp3.pow(nonResidue, power));
      qPower *= modulus;
    }
    res.push(powers2);
  }
  return res;
}
__name(calcFrobeniusCoefficients, "calcFrobeniusCoefficients");
function psiFrobenius(Fp3, Fp22, base) {
  const PSI_X = Fp22.pow(base, (Fp3.ORDER - _1n8) / _3n4);
  const PSI_Y = Fp22.pow(base, (Fp3.ORDER - _1n8) / _2n6);
  function psi(x2, y2) {
    const x22 = Fp22.mul(Fp22.frobeniusMap(x2, 1), PSI_X);
    const y22 = Fp22.mul(Fp22.frobeniusMap(y2, 1), PSI_Y);
    return [x22, y22];
  }
  __name(psi, "psi");
  __name2(psi, "psi");
  const PSI2_X = Fp22.pow(base, (Fp3.ORDER ** _2n6 - _1n8) / _3n4);
  const PSI2_Y = Fp22.pow(base, (Fp3.ORDER ** _2n6 - _1n8) / _2n6);
  if (!Fp22.eql(PSI2_Y, Fp22.neg(Fp22.ONE)))
    throw new Error("psiFrobenius: PSI2_Y!==-1");
  function psi2(x2, y2) {
    return [Fp22.mul(x2, PSI2_X), Fp22.neg(y2)];
  }
  __name(psi2, "psi2");
  __name2(psi2, "psi2");
  const mapAffine = /* @__PURE__ */ __name2((fn) => (c2, P2) => {
    const affine = P2.toAffine();
    const p2 = fn(affine.x, affine.y);
    return c2.fromAffine({ x: p2[0], y: p2[1] });
  }, "mapAffine");
  const G2psi3 = mapAffine(psi);
  const G2psi22 = mapAffine(psi2);
  return { psi, psi2, G2psi: G2psi3, G2psi2: G2psi22, PSI_X, PSI_Y, PSI2_X, PSI2_Y };
}
__name(psiFrobenius, "psiFrobenius");
function tower12(opts) {
  const { ORDER } = opts;
  const Fp3 = Field(ORDER);
  const FpNONRESIDUE = Fp3.create(opts.NONRESIDUE || BigInt(-1));
  const Fpdiv2 = Fp3.div(Fp3.ONE, _2n6);
  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp3, FpNONRESIDUE, Fp3.ORDER, 2)[0];
  const Fp2Add = /* @__PURE__ */ __name2(({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp3.add(c0, r0),
    c1: Fp3.add(c1, r1)
  }), "Fp2Add");
  const Fp2Subtract = /* @__PURE__ */ __name2(({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp3.sub(c0, r0),
    c1: Fp3.sub(c1, r1)
  }), "Fp2Subtract");
  const Fp2Multiply = /* @__PURE__ */ __name2(({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp3.mul(c0, rhs), c1: Fp3.mul(c1, rhs) };
    const { c0: r0, c1: r1 } = rhs;
    let t1 = Fp3.mul(c0, r0);
    let t2 = Fp3.mul(c1, r1);
    const o0 = Fp3.sub(t1, t2);
    const o1 = Fp3.sub(Fp3.mul(Fp3.add(c0, c1), Fp3.add(r0, r1)), Fp3.add(t1, t2));
    return { c0: o0, c1: o1 };
  }, "Fp2Multiply");
  const Fp2Square = /* @__PURE__ */ __name2(({ c0, c1 }) => {
    const a2 = Fp3.add(c0, c1);
    const b2 = Fp3.sub(c0, c1);
    const c2 = Fp3.add(c0, c0);
    return { c0: Fp3.mul(a2, b2), c1: Fp3.mul(c2, c1) };
  }, "Fp2Square");
  const Fp2fromBigTuple = /* @__PURE__ */ __name2((tuple) => {
    if (tuple.length !== 2)
      throw new Error("invalid tuple");
    const fps = tuple.map((n2) => Fp3.create(n2));
    return { c0: fps[0], c1: fps[1] };
  }, "Fp2fromBigTuple");
  const FP2_ORDER = ORDER * ORDER;
  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);
  const Fp22 = {
    ORDER: FP2_ORDER,
    isLE: Fp3.isLE,
    NONRESIDUE: Fp2Nonresidue,
    BITS: bitLen(FP2_ORDER),
    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),
    MASK: bitMask(bitLen(FP2_ORDER)),
    ZERO: { c0: Fp3.ZERO, c1: Fp3.ZERO },
    ONE: { c0: Fp3.ONE, c1: Fp3.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => typeof c0 === "bigint" && typeof c1 === "bigint",
    is0: ({ c0, c1 }) => Fp3.is0(c0) && Fp3.is0(c1),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp3.eql(c0, r0) && Fp3.eql(c1, r1),
    neg: ({ c0, c1 }) => ({ c0: Fp3.neg(c0), c1: Fp3.neg(c1) }),
    pow: (num, power) => FpPow(Fp22, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp22, nums),
    // Normalized
    add: Fp2Add,
    sub: Fp2Subtract,
    mul: Fp2Multiply,
    sqr: Fp2Square,
    // NonNormalized stuff
    addN: Fp2Add,
    subN: Fp2Subtract,
    mulN: Fp2Multiply,
    sqrN: Fp2Square,
    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
    div: (lhs, rhs) => Fp22.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp22.inv(rhs)),
    inv: ({ c0: a2, c1: b2 }) => {
      const factor = Fp3.inv(Fp3.create(a2 * a2 + b2 * b2));
      return { c0: Fp3.mul(factor, Fp3.create(a2)), c1: Fp3.mul(factor, Fp3.create(-b2)) };
    },
    sqrt: (num) => {
      if (opts.Fp2sqrt)
        return opts.Fp2sqrt(num);
      const { c0, c1 } = num;
      if (Fp3.is0(c1)) {
        if (FpLegendre(Fp3, c0) === 1)
          return Fp22.create({ c0: Fp3.sqrt(c0), c1: Fp3.ZERO });
        else
          return Fp22.create({ c0: Fp3.ZERO, c1: Fp3.sqrt(Fp3.div(c0, FpNONRESIDUE)) });
      }
      const a2 = Fp3.sqrt(Fp3.sub(Fp3.sqr(c0), Fp3.mul(Fp3.sqr(c1), FpNONRESIDUE)));
      let d2 = Fp3.mul(Fp3.add(a2, c0), Fpdiv2);
      const legendre = FpLegendre(Fp3, d2);
      if (legendre === -1)
        d2 = Fp3.sub(d2, a2);
      const a0 = Fp3.sqrt(d2);
      const candidateSqrt = Fp22.create({ c0: a0, c1: Fp3.div(Fp3.mul(c1, Fpdiv2), a0) });
      if (!Fp22.eql(Fp22.sqr(candidateSqrt), num))
        throw new Error("Cannot find square root");
      const x1 = candidateSqrt;
      const x2 = Fp22.neg(x1);
      const { re: re1, im: im1 } = Fp22.reim(x1);
      const { re: re2, im: im2 } = Fp22.reim(x2);
      if (im1 > im2 || im1 === im2 && re1 > re2)
        return x1;
      return x2;
    },
    // Same as sgn0_m_eq_2 in RFC 9380
    isOdd: (x2) => {
      const { re: x0, im: x1 } = Fp22.reim(x2);
      const sign_0 = x0 % _2n6;
      const zero_0 = x0 === _0n8;
      const sign_1 = x1 % _2n6;
      return BigInt(sign_0 || zero_0 && sign_1) == _1n8;
    },
    // Bytes util
    fromBytes(b2) {
      if (b2.length !== Fp22.BYTES)
        throw new Error("fromBytes invalid length=" + b2.length);
      return { c0: Fp3.fromBytes(b2.subarray(0, Fp3.BYTES)), c1: Fp3.fromBytes(b2.subarray(Fp3.BYTES)) };
    },
    toBytes: ({ c0, c1 }) => concatBytes2(Fp3.toBytes(c0), Fp3.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c2) => ({
      c0: Fp3.cmov(c0, r0, c2),
      c1: Fp3.cmov(c1, r1, c2)
    }),
    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),
    // multiply by u + 1
    mulByNonresidue: ({ c0, c1 }) => Fp22.mul({ c0, c1 }, Fp2Nonresidue),
    mulByB: opts.Fp2mulByB,
    fromBigTuple: Fp2fromBigTuple,
    frobeniusMap: ({ c0, c1 }, power) => ({
      c0,
      c1: Fp3.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])
    })
  };
  const Fp6Add = /* @__PURE__ */ __name2(({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r22 }) => ({
    c0: Fp22.add(c0, r0),
    c1: Fp22.add(c1, r1),
    c2: Fp22.add(c2, r22)
  }), "Fp6Add");
  const Fp6Subtract = /* @__PURE__ */ __name2(({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r22 }) => ({
    c0: Fp22.sub(c0, r0),
    c1: Fp22.sub(c1, r1),
    c2: Fp22.sub(c2, r22)
  }), "Fp6Subtract");
  const Fp6Multiply = /* @__PURE__ */ __name2(({ c0, c1, c2 }, rhs) => {
    if (typeof rhs === "bigint") {
      return {
        c0: Fp22.mul(c0, rhs),
        c1: Fp22.mul(c1, rhs),
        c2: Fp22.mul(c2, rhs)
      };
    }
    const { c0: r0, c1: r1, c2: r22 } = rhs;
    const t0 = Fp22.mul(c0, r0);
    const t1 = Fp22.mul(c1, r1);
    const t2 = Fp22.mul(c2, r22);
    return {
      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
      c0: Fp22.add(t0, Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), Fp22.add(r1, r22)), Fp22.add(t1, t2)))),
      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
      c1: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c1), Fp22.add(r0, r1)), Fp22.add(t0, t1)), Fp22.mulByNonresidue(t2)),
      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
      c2: Fp22.sub(Fp22.add(t1, Fp22.mul(Fp22.add(c0, c2), Fp22.add(r0, r22))), Fp22.add(t0, t2))
    };
  }, "Fp6Multiply");
  const Fp6Square = /* @__PURE__ */ __name2(({ c0, c1, c2 }) => {
    let t0 = Fp22.sqr(c0);
    let t1 = Fp22.mul(Fp22.mul(c0, c1), _2n6);
    let t3 = Fp22.mul(Fp22.mul(c1, c2), _2n6);
    let t4 = Fp22.sqr(c2);
    return {
      c0: Fp22.add(Fp22.mulByNonresidue(t3), t0),
      // T3 * (u + 1) + T0
      c1: Fp22.add(Fp22.mulByNonresidue(t4), t1),
      // T4 * (u + 1) + T1
      // T1 + (c0 - c1 + c2) + T3 - T0 - T4
      c2: Fp22.sub(Fp22.sub(Fp22.add(Fp22.add(t1, Fp22.sqr(Fp22.add(Fp22.sub(c0, c1), c2))), t3), t0), t4)
    };
  }, "Fp6Square");
  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp3.ORDER, 6, 2, 3);
  const Fp62 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp22.isLE,
    BITS: 3 * Fp22.BITS,
    BYTES: 3 * Fp22.BYTES,
    MASK: bitMask(3 * Fp22.BITS),
    ZERO: { c0: Fp22.ZERO, c1: Fp22.ZERO, c2: Fp22.ZERO },
    ONE: { c0: Fp22.ONE, c1: Fp22.ZERO, c2: Fp22.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1, c2 }) => Fp22.isValid(c0) && Fp22.isValid(c1) && Fp22.isValid(c2),
    is0: ({ c0, c1, c2 }) => Fp22.is0(c0) && Fp22.is0(c1) && Fp22.is0(c2),
    neg: ({ c0, c1, c2 }) => ({ c0: Fp22.neg(c0), c1: Fp22.neg(c1), c2: Fp22.neg(c2) }),
    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r22 }) => Fp22.eql(c0, r0) && Fp22.eql(c1, r1) && Fp22.eql(c2, r22),
    sqrt: notImplemented,
    // Do we need division by bigint at all? Should be done via order:
    div: (lhs, rhs) => Fp62.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp62.inv(rhs)),
    pow: (num, power) => FpPow(Fp62, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp62, nums),
    // Normalized
    add: Fp6Add,
    sub: Fp6Subtract,
    mul: Fp6Multiply,
    sqr: Fp6Square,
    // NonNormalized stuff
    addN: Fp6Add,
    subN: Fp6Subtract,
    mulN: Fp6Multiply,
    sqrN: Fp6Square,
    inv: ({ c0, c1, c2 }) => {
      let t0 = Fp22.sub(Fp22.sqr(c0), Fp22.mulByNonresidue(Fp22.mul(c2, c1)));
      let t1 = Fp22.sub(Fp22.mulByNonresidue(Fp22.sqr(c2)), Fp22.mul(c0, c1));
      let t2 = Fp22.sub(Fp22.sqr(c1), Fp22.mul(c0, c2));
      let t4 = Fp22.inv(Fp22.add(Fp22.mulByNonresidue(Fp22.add(Fp22.mul(c2, t1), Fp22.mul(c1, t2))), Fp22.mul(c0, t0)));
      return { c0: Fp22.mul(t4, t0), c1: Fp22.mul(t4, t1), c2: Fp22.mul(t4, t2) };
    },
    // Bytes utils
    fromBytes: (b2) => {
      if (b2.length !== Fp62.BYTES)
        throw new Error("fromBytes invalid length=" + b2.length);
      return {
        c0: Fp22.fromBytes(b2.subarray(0, Fp22.BYTES)),
        c1: Fp22.fromBytes(b2.subarray(Fp22.BYTES, 2 * Fp22.BYTES)),
        c2: Fp22.fromBytes(b2.subarray(2 * Fp22.BYTES))
      };
    },
    toBytes: ({ c0, c1, c2 }) => concatBytes2(Fp22.toBytes(c0), Fp22.toBytes(c1), Fp22.toBytes(c2)),
    cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r22 }, c3) => ({
      c0: Fp22.cmov(c0, r0, c3),
      c1: Fp22.cmov(c1, r1, c3),
      c2: Fp22.cmov(c2, r22, c3)
    }),
    fromBigSix: (t2) => {
      if (!Array.isArray(t2) || t2.length !== 6)
        throw new Error("invalid Fp6 usage");
      return {
        c0: Fp22.fromBigTuple(t2.slice(0, 2)),
        c1: Fp22.fromBigTuple(t2.slice(2, 4)),
        c2: Fp22.fromBigTuple(t2.slice(4, 6))
      };
    },
    frobeniusMap: ({ c0, c1, c2 }, power) => ({
      c0: Fp22.frobeniusMap(c0, power),
      c1: Fp22.mul(Fp22.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),
      c2: Fp22.mul(Fp22.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])
    }),
    mulByFp2: ({ c0, c1, c2 }, rhs) => ({
      c0: Fp22.mul(c0, rhs),
      c1: Fp22.mul(c1, rhs),
      c2: Fp22.mul(c2, rhs)
    }),
    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp22.mulByNonresidue(c2), c1: c0, c2: c1 }),
    // Sparse multiplication
    mul1: ({ c0, c1, c2 }, b1) => ({
      c0: Fp22.mulByNonresidue(Fp22.mul(c2, b1)),
      c1: Fp22.mul(c0, b1),
      c2: Fp22.mul(c1, b1)
    }),
    // Sparse multiplication
    mul01({ c0, c1, c2 }, b0, b1) {
      let t0 = Fp22.mul(c0, b0);
      let t1 = Fp22.mul(c1, b1);
      return {
        // ((c1 + c2) * b1 - T1) * (u + 1) + T0
        c0: Fp22.add(Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), b1), t1)), t0),
        // (b0 + b1) * (c0 + c1) - T0 - T1
        c1: Fp22.sub(Fp22.sub(Fp22.mul(Fp22.add(b0, b1), Fp22.add(c0, c1)), t0), t1),
        // (c0 + c2) * b0 - T0 + T1
        c2: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c2), b0), t0), t1)
      };
    }
  };
  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp3.ORDER, 12, 1, 6)[0];
  const Fp12Add = /* @__PURE__ */ __name2(({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.add(c0, r0),
    c1: Fp62.add(c1, r1)
  }), "Fp12Add");
  const Fp12Subtract = /* @__PURE__ */ __name2(({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.sub(c0, r0),
    c1: Fp62.sub(c1, r1)
  }), "Fp12Subtract");
  const Fp12Multiply = /* @__PURE__ */ __name2(({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp62.mul(c0, rhs), c1: Fp62.mul(c1, rhs) };
    let { c0: r0, c1: r1 } = rhs;
    let t1 = Fp62.mul(c0, r0);
    let t2 = Fp62.mul(c1, r1);
    return {
      c0: Fp62.add(t1, Fp62.mulByNonresidue(t2)),
      // T1 + T2 * v
      // (c0 + c1) * (r0 + r1) - (T1 + T2)
      c1: Fp62.sub(Fp62.mul(Fp62.add(c0, c1), Fp62.add(r0, r1)), Fp62.add(t1, t2))
    };
  }, "Fp12Multiply");
  const Fp12Square = /* @__PURE__ */ __name2(({ c0, c1 }) => {
    let ab = Fp62.mul(c0, c1);
    return {
      // (c1 * v + c0) * (c0 + c1) - AB - AB * v
      c0: Fp62.sub(Fp62.sub(Fp62.mul(Fp62.add(Fp62.mulByNonresidue(c1), c0), Fp62.add(c0, c1)), ab), Fp62.mulByNonresidue(ab)),
      c1: Fp62.add(ab, ab)
    };
  }, "Fp12Square");
  function Fp4Square2(a2, b2) {
    const a22 = Fp22.sqr(a2);
    const b22 = Fp22.sqr(b2);
    return {
      first: Fp22.add(Fp22.mulByNonresidue(b22), a22),
      // b * Nonresidue + a
      second: Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(a2, b2)), a22), b22)
      // (a + b) - a - b
    };
  }
  __name(Fp4Square2, "Fp4Square2");
  __name2(Fp4Square2, "Fp4Square");
  const Fp122 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp62.isLE,
    BITS: 2 * Fp62.BITS,
    BYTES: 2 * Fp62.BYTES,
    MASK: bitMask(2 * Fp62.BITS),
    ZERO: { c0: Fp62.ZERO, c1: Fp62.ZERO },
    ONE: { c0: Fp62.ONE, c1: Fp62.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => Fp62.isValid(c0) && Fp62.isValid(c1),
    is0: ({ c0, c1 }) => Fp62.is0(c0) && Fp62.is0(c1),
    neg: ({ c0, c1 }) => ({ c0: Fp62.neg(c0), c1: Fp62.neg(c1) }),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp62.eql(c0, r0) && Fp62.eql(c1, r1),
    sqrt: notImplemented,
    inv: ({ c0, c1 }) => {
      let t2 = Fp62.inv(Fp62.sub(Fp62.sqr(c0), Fp62.mulByNonresidue(Fp62.sqr(c1))));
      return { c0: Fp62.mul(c0, t2), c1: Fp62.neg(Fp62.mul(c1, t2)) };
    },
    div: (lhs, rhs) => Fp122.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp122.inv(rhs)),
    pow: (num, power) => FpPow(Fp122, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp122, nums),
    // Normalized
    add: Fp12Add,
    sub: Fp12Subtract,
    mul: Fp12Multiply,
    sqr: Fp12Square,
    // NonNormalized stuff
    addN: Fp12Add,
    subN: Fp12Subtract,
    mulN: Fp12Multiply,
    sqrN: Fp12Square,
    // Bytes utils
    fromBytes: (b2) => {
      if (b2.length !== Fp122.BYTES)
        throw new Error("fromBytes invalid length=" + b2.length);
      return {
        c0: Fp62.fromBytes(b2.subarray(0, Fp62.BYTES)),
        c1: Fp62.fromBytes(b2.subarray(Fp62.BYTES))
      };
    },
    toBytes: ({ c0, c1 }) => concatBytes2(Fp62.toBytes(c0), Fp62.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c2) => ({
      c0: Fp62.cmov(c0, r0, c2),
      c1: Fp62.cmov(c1, r1, c2)
    }),
    // Utils
    // toString() {
    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');
    // },
    // fromTuple(c: [Fp6, Fp6]) {
    //   return new Fp12(...c);
    // }
    fromBigTwelve: (t2) => ({
      c0: Fp62.fromBigSix(t2.slice(0, 6)),
      c1: Fp62.fromBigSix(t2.slice(6, 12))
    }),
    // Raises to q**i -th power
    frobeniusMap(lhs, power) {
      const { c0, c1, c2 } = Fp62.frobeniusMap(lhs.c1, power);
      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];
      return {
        c0: Fp62.frobeniusMap(lhs.c0, power),
        c1: Fp62.create({
          c0: Fp22.mul(c0, coeff),
          c1: Fp22.mul(c1, coeff),
          c2: Fp22.mul(c2, coeff)
        })
      };
    },
    mulByFp2: ({ c0, c1 }, rhs) => ({
      c0: Fp62.mulByFp2(c0, rhs),
      c1: Fp62.mulByFp2(c1, rhs)
    }),
    conjugate: ({ c0, c1 }) => ({ c0, c1: Fp62.neg(c1) }),
    // Sparse multiplication
    mul014: ({ c0, c1 }, o0, o1, o4) => {
      let t0 = Fp62.mul01(c0, o0, o1);
      let t1 = Fp62.mul1(c1, o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(t1), t0),
        // T1 * v + T0
        // (c1 + c0) * [o0, o1+o4] - T0 - T1
        c1: Fp62.sub(Fp62.sub(Fp62.mul01(Fp62.add(c1, c0), o0, Fp22.add(o1, o4)), t0), t1)
      };
    },
    mul034: ({ c0, c1 }, o0, o3, o4) => {
      const a2 = Fp62.create({
        c0: Fp22.mul(c0.c0, o0),
        c1: Fp22.mul(c0.c1, o0),
        c2: Fp22.mul(c0.c2, o0)
      });
      const b2 = Fp62.mul01(c1, o3, o4);
      const e2 = Fp62.mul01(Fp62.add(c0, c1), Fp22.add(o0, o3), o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(b2), a2),
        c1: Fp62.sub(e2, Fp62.add(a2, b2))
      };
    },
    // A cyclotomic group is a subgroup of Fp^n defined by
    //   G(p) = {  Fp : ^(p) = 1}
    // The result of any pairing is in a cyclotomic subgroup
    // https://eprint.iacr.org/2009/565.pdf
    _cyclotomicSquare: opts.Fp12cyclotomicSquare,
    _cyclotomicExp: opts.Fp12cyclotomicExp,
    // https://eprint.iacr.org/2010/354.pdf
    // https://eprint.iacr.org/2009/565.pdf
    finalExponentiate: opts.Fp12finalExponentiate
  };
  return { Fp: Fp3, Fp2: Fp22, Fp6: Fp62, Fp4Square: Fp4Square2, Fp12: Fp122 };
}
__name(tower12, "tower12");
var _0n8;
var _1n8;
var _2n6;
var _3n4;
var init_tower = __esm({
  "../node_modules/@noble/curves/esm/abstract/tower.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_modular();
    init_utils3();
    _0n8 = BigInt(0);
    _1n8 = BigInt(1);
    _2n6 = BigInt(2);
    _3n4 = BigInt(3);
    __name2(calcFrobeniusCoefficients, "calcFrobeniusCoefficients");
    __name2(psiFrobenius, "psiFrobenius");
    __name2(tower12, "tower12");
  }
});
function parseMask(bytes) {
  bytes = bytes.slice();
  const mask = bytes[0] & 224;
  const compressed = !!(mask >> 7 & 1);
  const infinity = !!(mask >> 6 & 1);
  const sort = !!(mask >> 5 & 1);
  bytes[0] &= 31;
  return { compressed, infinity, sort, value: bytes };
}
__name(parseMask, "parseMask");
function setMask(bytes, mask) {
  if (bytes[0] & 224)
    throw new Error("setMask: non-empty mask");
  if (mask.compressed)
    bytes[0] |= 128;
  if (mask.infinity)
    bytes[0] |= 64;
  if (mask.sort)
    bytes[0] |= 32;
  return bytes;
}
__name(setMask, "setMask");
function signatureG1ToRawBytes(point) {
  point.assertValidity();
  const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);
  const { x: x2, y: y2 } = point.toAffine();
  if (isZero)
    return COMPRESSED_ZERO.slice();
  const P2 = Fp.ORDER;
  const sort = Boolean(y2 * _2n7 / P2);
  return setMask(numberToBytesBE(x2, Fp.BYTES), { compressed: true, sort });
}
__name(signatureG1ToRawBytes, "signatureG1ToRawBytes");
function signatureG2ToRawBytes(point) {
  point.assertValidity();
  const len = Fp.BYTES;
  if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))
    return concatBytes2(COMPRESSED_ZERO, numberToBytesBE(_0n9, len));
  const { x: x2, y: y2 } = point.toAffine();
  const { re: x0, im: x1 } = Fp2.reim(x2);
  const { re: y0, im: y1 } = Fp2.reim(y2);
  const tmp = y1 > _0n9 ? y1 * _2n7 : y0 * _2n7;
  const sort = Boolean(tmp / Fp.ORDER & _1n9);
  const z2 = x0;
  return concatBytes2(setMask(numberToBytesBE(x1, len), { sort, compressed: true }), numberToBytesBE(z2, len));
}
__name(signatureG2ToRawBytes, "signatureG2ToRawBytes");
var _0n9;
var _1n9;
var _2n7;
var _3n5;
var _4n3;
var BLS_X;
var BLS_X_LEN;
var Fp;
var Fp2;
var Fp6;
var Fp4Square;
var Fp12;
var Fr;
var isogenyMapG2;
var isogenyMapG1;
var G2_SWU;
var G1_SWU;
var G2psi;
var G2psi2;
var htfDefaults;
var COMPRESSED_ZERO;
var bls12_381;
var init_bls12_381 = __esm({
  "../node_modules/@noble/curves/esm/bls12-381.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sha2();
    init_utils2();
    init_bls();
    init_modular();
    init_utils3();
    init_hash_to_curve();
    init_tower();
    init_weierstrass();
    _0n9 = BigInt(0);
    _1n9 = BigInt(1);
    _2n7 = BigInt(2);
    _3n5 = BigInt(3);
    _4n3 = BigInt(4);
    BLS_X = BigInt("0xd201000000010000");
    BLS_X_LEN = bitLen(BLS_X);
    ({ Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({
      // Order of Fp
      ORDER: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),
      // Finite extension field over irreducible polynominal.
      // Fp(u) / (u - ) where  = -1
      FP2_NONRESIDUE: [_1n9, _1n9],
      Fp2mulByB: ({ c0, c1 }) => {
        const t0 = Fp.mul(c0, _4n3);
        const t1 = Fp.mul(c1, _4n3);
        return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };
      },
      // Fp12
      // A cyclotomic group is a subgroup of Fp^n defined by
      //   G(p) = {  Fp : ^(p) = 1}
      // The result of any pairing is in a cyclotomic subgroup
      // https://eprint.iacr.org/2009/565.pdf
      Fp12cyclotomicSquare: ({ c0, c1 }) => {
        const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;
        const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;
        const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);
        const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);
        const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);
        const t9 = Fp2.mulByNonresidue(t8);
        return {
          c0: Fp6.create({
            c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n7), t3),
            // 2 * (T3 - c0c0)  + T3
            c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n7), t5),
            // 2 * (T5 - c0c1)  + T5
            c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n7), t7)
          }),
          // 2 * (T7 - c0c2)  + T7
          c1: Fp6.create({
            c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n7), t9),
            // 2 * (T9 + c1c0) + T9
            c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n7), t4),
            // 2 * (T4 + c1c1) + T4
            c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n7), t6)
          })
        };
      },
      Fp12cyclotomicExp(num, n2) {
        let z2 = Fp12.ONE;
        for (let i2 = BLS_X_LEN - 1; i2 >= 0; i2--) {
          z2 = Fp12._cyclotomicSquare(z2);
          if (bitGet(n2, i2))
            z2 = Fp12.mul(z2, num);
        }
        return z2;
      },
      // https://eprint.iacr.org/2010/354.pdf
      // https://eprint.iacr.org/2009/565.pdf
      Fp12finalExponentiate: (num) => {
        const x2 = BLS_X;
        const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);
        const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);
        const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x2));
        const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);
        const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x2));
        const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x2));
        const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x2)), Fp12._cyclotomicSquare(t2));
        const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x2));
        const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);
        const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);
        const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);
        const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);
        return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
      }
    }));
    Fr = Field(BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"));
    isogenyMapG2 = isogenyMap(Fp2, [
      // xNum
      [
        [
          "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6",
          "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"
        ],
        [
          "0x0",
          "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"
        ],
        [
          "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e",
          "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"
        ],
        [
          "0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1",
          "0x0"
        ]
      ],
      // xDen
      [
        [
          "0x0",
          "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"
        ],
        [
          "0xc",
          "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"
        ],
        ["0x1", "0x0"]
        // LAST 1
      ],
      // yNum
      [
        [
          "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706",
          "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"
        ],
        [
          "0x0",
          "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"
        ],
        [
          "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c",
          "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"
        ],
        [
          "0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10",
          "0x0"
        ]
      ],
      // yDen
      [
        [
          "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb",
          "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"
        ],
        [
          "0x0",
          "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"
        ],
        [
          "0x12",
          "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"
        ],
        ["0x1", "0x0"]
        // LAST 1
      ]
    ].map((i2) => i2.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));
    isogenyMapG1 = isogenyMap(Fp, [
      // xNum
      [
        "0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7",
        "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb",
        "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0",
        "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861",
        "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9",
        "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983",
        "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84",
        "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e",
        "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317",
        "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e",
        "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b",
        "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"
      ],
      // xDen
      [
        "0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c",
        "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff",
        "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19",
        "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8",
        "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e",
        "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5",
        "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a",
        "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e",
        "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641",
        "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a",
        "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33",
        "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696",
        "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6",
        "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb",
        "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb",
        "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0",
        "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2",
        "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29",
        "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587",
        "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30",
        "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132",
        "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e",
        "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8",
        "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133",
        "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b",
        "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"
      ],
      // yDen
      [
        "0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1",
        "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d",
        "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2",
        "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416",
        "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d",
        "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac",
        "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c",
        "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9",
        "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a",
        "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55",
        "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8",
        "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092",
        "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc",
        "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7",
        "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f",
        "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i2) => i2.map((j2) => BigInt(j2))));
    G2_SWU = mapToCurveSimpleSWU(Fp2, {
      A: Fp2.create({ c0: Fp.create(_0n9), c1: Fp.create(BigInt(240)) }),
      // A' = 240 * I
      B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }),
      // B' = 1012 * (1 + I)
      Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) })
      // Z: -(2 + I)
    });
    G1_SWU = mapToCurveSimpleSWU(Fp, {
      A: Fp.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),
      B: Fp.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),
      Z: Fp.create(BigInt(11))
    });
    ({ G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)));
    htfDefaults = Object.freeze({
      // DST: a domain separation tag
      // defined in section 2.2.5
      // Use utils.getDSTLabel(), utils.setDSTLabel(value)
      DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
      encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
      // p: the characteristic of F
      //    where F is a finite field of characteristic p and order q = p^m
      p: Fp.ORDER,
      // m: the extension degree of F, m >= 1
      //     where F is a finite field of characteristic p and order q = p^m
      m: 2,
      // k: the target security level for the suite in bits
      // defined in section 5.1
      k: 128,
      // option to use a message that has already been processed by
      // expand_message_xmd
      expand: "xmd",
      // Hash functions for: expand_message_xmd is appropriate for use with a
      // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
      // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
      hash: sha256
    });
    COMPRESSED_ZERO = setMask(Fp.toBytes(_0n9), { infinity: true, compressed: true });
    __name2(parseMask, "parseMask");
    __name2(setMask, "setMask");
    __name2(signatureG1ToRawBytes, "signatureG1ToRawBytes");
    __name2(signatureG2ToRawBytes, "signatureG2ToRawBytes");
    bls12_381 = bls({
      // Fields
      fields: {
        Fp,
        Fp2,
        Fp6,
        Fp12,
        Fr
      },
      // G1 is the order-q subgroup of E1(Fp) : y = x + 4, #E1(Fp) = h1q, where
      // characteristic; z + (z - z + 1)(z - 1)/3
      G1: {
        Fp,
        // cofactor; (z - 1)/3
        h: BigInt("0x396c8c005555e1568c00aaab0000aaab"),
        // generator's coordinates
        // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507
        // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569
        Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),
        Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1"),
        a: Fp.ZERO,
        b: _4n3,
        htfDefaults: { ...htfDefaults, m: 1, DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" },
        wrapPrivateKey: true,
        allowInfinityPoint: true,
        // Checks is the point resides in prime-order subgroup.
        // point.isTorsionFree() should return true for valid points
        // It returns false for shitty points.
        // https://eprint.iacr.org/2021/1130.pdf
        isTorsionFree: (c2, point) => {
          const cubicRootOfUnityModP = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe");
          const phi = new c2(Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);
          const xP = point.multiplyUnsafe(BLS_X).negate();
          const u2P = xP.multiplyUnsafe(BLS_X);
          return u2P.equals(phi);
        },
        // Clear cofactor of G1
        // https://eprint.iacr.org/2019/403
        clearCofactor: (_c, point) => {
          return point.multiplyUnsafe(BLS_X).add(point);
        },
        mapToCurve: (scalars) => {
          const { x: x2, y: y2 } = G1_SWU(Fp.create(scalars[0]));
          return isogenyMapG1(x2, y2);
        },
        fromBytes: (bytes) => {
          const { compressed, infinity, sort, value } = parseMask(bytes);
          if (value.length === 48 && compressed) {
            const P2 = Fp.ORDER;
            const compressedValue = bytesToNumberBE(value);
            const x2 = Fp.create(compressedValue & Fp.MASK);
            if (infinity) {
              if (x2 !== _0n9)
                throw new Error("G1: non-empty compressed point at infinity");
              return { x: _0n9, y: _0n9 };
            }
            const right = Fp.add(Fp.pow(x2, _3n5), Fp.create(bls12_381.params.G1b));
            let y2 = Fp.sqrt(right);
            if (!y2)
              throw new Error("invalid compressed G1 point");
            if (y2 * _2n7 / P2 !== BigInt(sort))
              y2 = Fp.neg(y2);
            return { x: Fp.create(x2), y: Fp.create(y2) };
          } else if (value.length === 96 && !compressed) {
            const x2 = bytesToNumberBE(value.subarray(0, Fp.BYTES));
            const y2 = bytesToNumberBE(value.subarray(Fp.BYTES));
            if (infinity) {
              if (x2 !== _0n9 || y2 !== _0n9)
                throw new Error("G1: non-empty point at infinity");
              return bls12_381.G1.ProjectivePoint.ZERO.toAffine();
            }
            return { x: Fp.create(x2), y: Fp.create(y2) };
          } else {
            throw new Error("invalid point G1, expected 48/96 bytes");
          }
        },
        toBytes: (c2, point, isCompressed) => {
          const isZero = point.equals(c2.ZERO);
          const { x: x2, y: y2 } = point.toAffine();
          if (isCompressed) {
            if (isZero)
              return COMPRESSED_ZERO.slice();
            const P2 = Fp.ORDER;
            const sort = Boolean(y2 * _2n7 / P2);
            return setMask(numberToBytesBE(x2, Fp.BYTES), { compressed: true, sort });
          } else {
            if (isZero) {
              const x3 = concatBytes2(new Uint8Array([64]), new Uint8Array(2 * Fp.BYTES - 1));
              return x3;
            } else {
              return concatBytes2(numberToBytesBE(x2, Fp.BYTES), numberToBytesBE(y2, Fp.BYTES));
            }
          }
        },
        ShortSignature: {
          fromHex(hex3) {
            const { infinity, sort, value } = parseMask(ensureBytes("signatureHex", hex3, 48));
            const P2 = Fp.ORDER;
            const compressedValue = bytesToNumberBE(value);
            if (infinity)
              return bls12_381.G1.ProjectivePoint.ZERO;
            const x2 = Fp.create(compressedValue & Fp.MASK);
            const right = Fp.add(Fp.pow(x2, _3n5), Fp.create(bls12_381.params.G1b));
            let y2 = Fp.sqrt(right);
            if (!y2)
              throw new Error("invalid compressed G1 point");
            const aflag = BigInt(sort);
            if (y2 * _2n7 / P2 !== aflag)
              y2 = Fp.neg(y2);
            const point = bls12_381.G1.ProjectivePoint.fromAffine({ x: x2, y: y2 });
            point.assertValidity();
            return point;
          },
          toRawBytes(point) {
            return signatureG1ToRawBytes(point);
          },
          toHex(point) {
            return bytesToHex2(signatureG1ToRawBytes(point));
          }
        }
      },
      // G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),
      // where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where
      // G - 1
      // h2q
      G2: {
        Fp: Fp2,
        // cofactor
        h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),
        Gx: Fp2.fromBigTuple([
          BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),
          BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")
        ]),
        // y =
        // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,
        // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905
        Gy: Fp2.fromBigTuple([
          BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),
          BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")
        ]),
        a: Fp2.ZERO,
        b: Fp2.fromBigTuple([_4n3, _4n3]),
        hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),
        htfDefaults: { ...htfDefaults },
        wrapPrivateKey: true,
        allowInfinityPoint: true,
        mapToCurve: (scalars) => {
          const { x: x2, y: y2 } = G2_SWU(Fp2.fromBigTuple(scalars));
          return isogenyMapG2(x2, y2);
        },
        // Checks is the point resides in prime-order subgroup.
        // point.isTorsionFree() should return true for valid points
        // It returns false for shitty points.
        // https://eprint.iacr.org/2021/1130.pdf
        isTorsionFree: (c2, P2) => {
          return P2.multiplyUnsafe(BLS_X).negate().equals(G2psi(c2, P2));
        },
        // Maps the point into the prime-order subgroup G2.
        // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11
        // https://eprint.iacr.org/2017/419.pdf
        // prettier-ignore
        clearCofactor: (c2, P2) => {
          const x2 = BLS_X;
          let t1 = P2.multiplyUnsafe(x2).negate();
          let t2 = G2psi(c2, P2);
          let t3 = P2.double();
          t3 = G2psi2(c2, t3);
          t3 = t3.subtract(t2);
          t2 = t1.add(t2);
          t2 = t2.multiplyUnsafe(x2).negate();
          t3 = t3.add(t2);
          t3 = t3.subtract(t1);
          const Q = t3.subtract(P2);
          return Q;
        },
        fromBytes: (bytes) => {
          const { compressed, infinity, sort, value } = parseMask(bytes);
          if (!compressed && !infinity && sort || // 00100000
          !compressed && infinity && sort || // 01100000
          sort && infinity && compressed) {
            throw new Error("invalid encoding flag: " + (bytes[0] & 224));
          }
          const L = Fp.BYTES;
          const slc = /* @__PURE__ */ __name2((b2, from27, to3) => bytesToNumberBE(b2.slice(from27, to3)), "slc");
          if (value.length === 96 && compressed) {
            const b2 = bls12_381.params.G2b;
            const P2 = Fp.ORDER;
            if (infinity) {
              if (value.reduce((p2, c2) => p2 !== 0 ? c2 + 1 : c2, 0) > 0) {
                throw new Error("invalid compressed G2 point");
              }
              return { x: Fp2.ZERO, y: Fp2.ZERO };
            }
            const x_1 = slc(value, 0, L);
            const x_0 = slc(value, L, 2 * L);
            const x2 = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });
            const right = Fp2.add(Fp2.pow(x2, _3n5), b2);
            let y2 = Fp2.sqrt(right);
            const Y_bit = y2.c1 === _0n9 ? y2.c0 * _2n7 / P2 : y2.c1 * _2n7 / P2 ? _1n9 : _0n9;
            y2 = sort && Y_bit > 0 ? y2 : Fp2.neg(y2);
            return { x: x2, y: y2 };
          } else if (value.length === 192 && !compressed) {
            if (infinity) {
              if (value.reduce((p2, c2) => p2 !== 0 ? c2 + 1 : c2, 0) > 0) {
                throw new Error("invalid uncompressed G2 point");
              }
              return { x: Fp2.ZERO, y: Fp2.ZERO };
            }
            const x1 = slc(value, 0, L);
            const x0 = slc(value, L, 2 * L);
            const y1 = slc(value, 2 * L, 3 * L);
            const y0 = slc(value, 3 * L, 4 * L);
            return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };
          } else {
            throw new Error("invalid point G2, expected 96/192 bytes");
          }
        },
        toBytes: (c2, point, isCompressed) => {
          const { BYTES: len, ORDER: P2 } = Fp;
          const isZero = point.equals(c2.ZERO);
          const { x: x2, y: y2 } = point.toAffine();
          if (isCompressed) {
            if (isZero)
              return concatBytes2(COMPRESSED_ZERO, numberToBytesBE(_0n9, len));
            const flag = Boolean(y2.c1 === _0n9 ? y2.c0 * _2n7 / P2 : y2.c1 * _2n7 / P2);
            return concatBytes2(setMask(numberToBytesBE(x2.c1, len), { compressed: true, sort: flag }), numberToBytesBE(x2.c0, len));
          } else {
            if (isZero)
              return concatBytes2(new Uint8Array([64]), new Uint8Array(4 * len - 1));
            const { re: x0, im: x1 } = Fp2.reim(x2);
            const { re: y0, im: y1 } = Fp2.reim(y2);
            return concatBytes2(numberToBytesBE(x1, len), numberToBytesBE(x0, len), numberToBytesBE(y1, len), numberToBytesBE(y0, len));
          }
        },
        Signature: {
          // TODO: Optimize, it's very slow because of sqrt.
          fromHex(hex3) {
            const { infinity, sort, value } = parseMask(ensureBytes("signatureHex", hex3));
            const P2 = Fp.ORDER;
            const half = value.length / 2;
            if (half !== 48 && half !== 96)
              throw new Error("invalid compressed signature length, must be 96 or 192");
            const z1 = bytesToNumberBE(value.slice(0, half));
            const z2 = bytesToNumberBE(value.slice(half));
            if (infinity)
              return bls12_381.G2.ProjectivePoint.ZERO;
            const x1 = Fp.create(z1 & Fp.MASK);
            const x2 = Fp.create(z2);
            const x3 = Fp2.create({ c0: x2, c1: x1 });
            const y2 = Fp2.add(Fp2.pow(x3, _3n5), bls12_381.params.G2b);
            let y3 = Fp2.sqrt(y2);
            if (!y3)
              throw new Error("Failed to find a square root");
            const { re: y0, im: y1 } = Fp2.reim(y3);
            const aflag1 = BigInt(sort);
            const isGreater = y1 > _0n9 && y1 * _2n7 / P2 !== aflag1;
            const isZero = y1 === _0n9 && y0 * _2n7 / P2 !== aflag1;
            if (isGreater || isZero)
              y3 = Fp2.neg(y3);
            const point = bls12_381.G2.ProjectivePoint.fromAffine({ x: x3, y: y3 });
            point.assertValidity();
            return point;
          },
          toRawBytes(point) {
            return signatureG2ToRawBytes(point);
          },
          toHex(point) {
            return bytesToHex2(signatureG2ToRawBytes(point));
          }
        }
      },
      params: {
        ateLoopSize: BLS_X,
        // The BLS parameter x for BLS12-381
        r: Fr.ORDER,
        // order; z  z + 1; CURVE.n from other curves
        xNegative: true,
        twistType: "multiplicative"
      },
      htfDefaults,
      hash: sha256,
      randomBytes
    });
  }
});
function aggregate(points) {
  const group = typeof points[0]?.x === "bigint" ? bls12_381.G1 : bls12_381.G2;
  const point = points.reduce((acc, point2) => acc.add(new group.ProjectivePoint(point2.x, point2.y, point2.z)), group.ProjectivePoint.ZERO);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
__name(aggregate, "aggregate");
function sign(options2) {
  const { payload, privateKey, suite, size: size3 = "short-key:long-sig" } = options2;
  const payloadGroup = size3 === "short-key:long-sig" ? bls12_381.G2 : bls12_381.G1;
  const payloadPoint = payloadGroup.hashToCurve(from3(payload), suite ? { DST: fromString2(suite) } : void 0);
  const privateKeyGroup = size3 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));
  return {
    x: signature.px,
    y: signature.py,
    z: signature.pz
  };
}
__name(sign, "sign");
function verify(options2) {
  const { payload, suite } = options2;
  const publicKey = options2.publicKey;
  const signature = options2.signature;
  const isShortSig = typeof signature.x === "bigint";
  const group = isShortSig ? bls12_381.G1 : bls12_381.G2;
  const payloadPoint = group.hashToCurve(from3(payload), suite ? { DST: fromString2(suite) } : void 0);
  const shortSigPairing = /* @__PURE__ */ __name2(() => bls12_381.pairingBatch([
    {
      g1: payloadPoint,
      g2: new bls12_381.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z)
    },
    {
      g1: new bls12_381.G1.ProjectivePoint(signature.x, signature.y, signature.z),
      g2: bls12_381.G2.ProjectivePoint.BASE.negate()
    }
  ]), "shortSigPairing");
  const longSigPairing = /* @__PURE__ */ __name2(() => bls12_381.pairingBatch([
    {
      g1: new bls12_381.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),
      g2: payloadPoint
    },
    {
      g1: bls12_381.G1.ProjectivePoint.BASE,
      g2: new bls12_381.G2.ProjectivePoint(signature.x, signature.y, signature.z)
    }
  ]), "longSigPairing");
  return bls12_381.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), bls12_381.fields.Fp12.ONE);
}
__name(verify, "verify");
var init_Bls = __esm({
  "../node_modules/ox/_esm/core/Bls.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_bls12_381();
    init_Bytes();
    __name2(aggregate, "aggregate");
    aggregate.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(sign, "sign");
    sign.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(verify, "verify");
    verify.parseError = (error) => error;
  }
});
function toBytes9(point) {
  const group = typeof point.z === "bigint" ? bls12_381.G1 : bls12_381.G2;
  return new group.ProjectivePoint(point.x, point.y, point.z).toRawBytes();
}
__name(toBytes9, "toBytes9");
function toHex8(point) {
  return fromBytes(toBytes9(point));
}
__name(toHex8, "toHex8");
function fromBytes7(bytes) {
  const group = bytes.length === 48 ? bls12_381.G1 : bls12_381.G2;
  const point = group.ProjectivePoint.fromHex(bytes);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
__name(fromBytes7, "fromBytes7");
function fromHex7(hex3, group) {
  return fromBytes7(toBytes2(hex3), group);
}
__name(fromHex7, "fromHex7");
var init_BlsPoint = __esm({
  "../node_modules/ox/_esm/core/BlsPoint.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_bls12_381();
    init_Hex();
    __name2(toBytes9, "toBytes");
    toBytes9.parseError = (error) => error;
    __name2(toHex8, "toHex");
    toHex8.parseError = (error) => error;
    __name2(fromBytes7, "fromBytes");
    fromBytes7.parseError = (error) => error;
    __name2(fromHex7, "fromHex");
    fromHex7.parseError = (error) => error;
  }
});
function from18(options2) {
  if (options2.salt)
    return fromCreate2(options2);
  return fromCreate(options2);
}
__name(from18, "from18");
function fromCreate(options2) {
  const from27 = fromHex(from5(options2.from));
  let nonce = fromNumber2(options2.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return from5(`0x${keccak256(fromBytes3([from27, nonce], { as: "Hex" })).slice(26)}`);
}
__name(fromCreate, "fromCreate");
function fromCreate2(options2) {
  const from27 = fromHex(from5(options2.from));
  const salt = padLeft2(validate2(options2.salt) ? options2.salt : fromHex(options2.salt), 32);
  const bytecodeHash = (() => {
    if ("bytecodeHash" in options2) {
      if (validate2(options2.bytecodeHash))
        return options2.bytecodeHash;
      return fromHex(options2.bytecodeHash);
    }
    return keccak256(options2.bytecode, { as: "Bytes" });
  })();
  return from5(slice(keccak256(concat2(fromHex("0xff"), from27, salt, bytecodeHash), { as: "Hex" }), 12));
}
__name(fromCreate2, "fromCreate2");
var init_ContractAddress = __esm({
  "../node_modules/ox/_esm/core/ContractAddress.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Address();
    init_Bytes();
    init_Hash();
    init_Hex();
    init_Rlp();
    __name2(from18, "from");
    from18.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromCreate, "fromCreate");
    fromCreate.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromCreate2, "fromCreate2");
    fromCreate2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  __name(u16, "u16");
  __name2(u16, "u16");
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i2 = 1; i2 < symbol_count; i2++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  __name(read_bit, "read_bit");
  __name2(read_bit, "read_bit");
  const N = 31;
  const FULL = 2 ** N;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i2 = 0; i2 < N; i2++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a2 = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b2 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
__name(decode_arithmetic, "decode_arithmetic");
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
__name(read_payload, "read_payload");
function read_compressed_payload(s2) {
  return read_payload(decode_arithmetic(unsafe_atob(s2)));
}
__name(read_compressed_payload, "read_compressed_payload");
function unsafe_atob(s2) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i2) => lookup[c2.charCodeAt(0)] = i2);
  let n2 = s2.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i2 = 0, pos = 0, width = 0, carry = 0; i2 < n2; i2++) {
    carry = carry << 6 | lookup[s2.charCodeAt(i2)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
__name(unsafe_atob, "unsafe_atob");
function signed(i2) {
  return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
}
__name(signed, "signed");
function read_deltas(n2, next) {
  let v2 = Array(n2);
  for (let i2 = 0, x2 = 0; i2 < n2; i2++)
    v2[i2] = x2 += signed(next());
  return v2;
}
__name(read_deltas, "read_deltas");
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x2 = next();
    let n2 = next();
    if (!n2)
      break;
    prev += x2;
    for (let i2 = 0; i2 < n2; i2++) {
      ret.push(prev + i2);
    }
    prev += n2 + 1;
  }
  return ret;
}
__name(read_sorted, "read_sorted");
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v2 = read_sorted(next);
    if (v2.length)
      return v2;
  });
}
__name(read_sorted_arrays, "read_sorted_arrays");
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next));
  }
  return ret.flat();
}
__name(read_mapped, "read_mapped");
function read_array_while(next) {
  let v2 = [];
  while (true) {
    let x2 = next(v2.length);
    if (!x2)
      break;
    v2.push(x2);
  }
  return v2;
}
__name(read_array_while, "read_array_while");
function read_transposed(n2, w2, next) {
  let m2 = Array(n2).fill().map(() => []);
  for (let i2 = 0; i2 < w2; i2++) {
    read_deltas(n2, next).forEach((x2, j2) => m2[j2].push(x2));
  }
  return m2;
}
__name(read_transposed, "read_transposed");
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m2 = read_transposed(vN.length, 1 + w2, next);
  return m2.flatMap((v2, i2) => {
    let [x2, ...ys] = v2;
    return Array(vN[i2]).fill().map((_, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys.map((y2) => y2 + j_dy)];
    });
  });
}
__name(read_linear_table, "read_linear_table");
function read_replacement_table(w2, next) {
  let n2 = 1 + next();
  let m2 = read_transposed(n2, 1 + w2, next);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
__name(read_replacement_table, "read_replacement_table");
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode4([]), []);
  return ret;
  function decode4(Q) {
    let S2 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i2) => sorted[i2]);
      if (cps.length)
        return decode4(cps);
    });
    return { S: S2, B, Q };
  }
  __name(decode4, "decode4");
  __name2(decode4, "decode");
  function expand({ S: S2, B }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1])
      return;
    if (S2 & 2)
      saved = cps[cps.length - 1];
    if (S2 & 1)
      ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
  __name(expand, "expand");
  __name2(expand, "expand");
}
__name(read_trie, "read_trie");
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
__name(hex_cp, "hex_cp");
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
__name(quote_cp, "quote_cp");
function explode_cp(s2) {
  let cps = [];
  for (let pos = 0, len = s2.length; pos < len; ) {
    let cp = s2.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
__name(explode_cp, "explode_cp");
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i2 = 0; i2 < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i2, i2 += chunk)));
  }
  return buf.join("");
}
__name(str_from_cps, "str_from_cps");
function compare_arrays(a2, b2) {
  let n2 = a2.length;
  let c2 = n2 - b2.length;
  for (let i2 = 0; c2 == 0 && i2 < n2; i2++)
    c2 = a2[i2] - b2[i2];
  return c2;
}
__name(compare_arrays, "compare_arrays");
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
__name(unpack_cc, "unpack_cc");
function unpack_cp(packed) {
  return packed & 16777215;
}
__name(unpack_cp, "unpack_cp");
function init$1() {
  let r3 = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r3).flatMap((v2, i2) => v2.map((x2) => [x2, i2 + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r3));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r3)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a2, b2] = cps;
      let bucket = RECOMP.get(a2);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a2, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
__name(init$1, "init$1");
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
__name(is_hangul, "is_hangul");
function compose_pair(a2, b2) {
  if (a2 >= L0 && a2 < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a2 - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a2) && b2 > T0 && b2 < T1 && (a2 - S0) % T_COUNT == 0) {
    return a2 + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a2);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
__name(compose_pair, "compose_pair");
function decomposed(cps) {
  if (!SHIFTED_RANK)
    init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  __name(add2, "add2");
  __name2(add2, "add");
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0)
          add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i2 = 1; i2 < ret.length; i2++) {
      let cc = unpack_cc(ret[i2]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j2 = i2 - 1;
      while (true) {
        let tmp = ret[j2 + 1];
        ret[j2 + 1] = ret[j2];
        ret[j2] = tmp;
        if (!j2)
          break;
        prev_cc = unpack_cc(ret[--j2]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i2]);
    }
  }
  return ret;
}
__name(decomposed, "decomposed");
function composed_from_decomposed(v2) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v2) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
__name(composed_from_decomposed, "composed_from_decomposed");
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
__name(nfd, "nfd");
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
__name(nfc, "nfc");
function group_has_cp(g2, cp) {
  return g2.P.has(cp) || g2.Q.has(cp);
}
__name(group_has_cp, "group_has_cp");
function init() {
  if (MAPPED)
    return;
  let r3 = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = /* @__PURE__ */ __name2(() => read_sorted(r3), "read_sorted_array");
  const read_sorted_set = /* @__PURE__ */ __name2(() => new Set(read_sorted_array()), "read_sorted_set");
  const set_add_many = /* @__PURE__ */ __name2((set, v2) => v2.forEach((x2) => set.add(x2)), "set_add_many");
  MAPPED = new Map(read_mapped(r3));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i2) => CM[i2]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r3);
  let unrestricted = r3();
  const read_chunked = /* @__PURE__ */ __name2(() => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i2) => set_add_many(set, chunks[i2]));
    set_add_many(set, read_sorted_array());
    return set;
  }, "read_chunked");
  GROUPS = read_array_while((i2) => {
    let N = read_array_while(r3).map((x2) => x2 + 96);
    if (N.length) {
      let R = i2 >= unrestricted;
      N[0] -= 32;
      N = str_from_cps(N);
      if (R)
        N = `Restricted[${N}]`;
      let P2 = read_chunked();
      let Q = read_chunked();
      let M = !r3();
      return { N, P: P2, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a2, b2) => a2 - b2);
  wholes.forEach((cp, i2) => {
    let d2 = r3();
    let w2 = wholes[i2] = d2 ? wholes[i2 - d2] : { V: [], M: /* @__PURE__ */ new Map() };
    w2.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w2);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g2) => group_has_cp(g2, cp));
      let rec = recs.find(({ G }) => gs.some((g2) => G.has(g2)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x2) => Array_from(x2.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g2) => !G.has(g2)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = /* @__PURE__ */ __name2((cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp), "add_to_union");
  for (let g2 of GROUPS) {
    for (let cp of g2.P)
      add_to_union(cp);
    for (let cp of g2.Q)
      add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r3).map((v2) => Emoji.from(v2)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x2 of prev) {
      x2.V = cps;
    }
  }
}
__name(init, "init");
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
__name(quoted_cp, "quoted_cp");
function bidi_qq(s2) {
  return `"${s2}"\u200E`;
}
__name(bidi_qq, "bidi_qq");
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
__name(check_label_extension, "check_label_extension");
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i2 = cps.lastIndexOf(UNDERSCORE); i2 > 0; ) {
    if (cps[--i2] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
__name(check_leading_underscore, "check_leading_underscore");
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i2 = 1; i2 < n2; i2++) {
    cp = cps[i2];
    let match2 = FENCED.get(cp);
    if (match2) {
      if (last == i2)
        throw error_placement(`${prev} + ${match2}`);
      last = i2 + 1;
      prev = match2;
    }
  }
  if (last == n2)
    throw error_placement(`trailing ${prev}`);
}
__name(check_fenced, "check_fenced");
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("\u25CC");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i2 = 0; i2 < n2; i2++) {
    let cp = cps[i2];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i2)));
      buf.push(quoter(cp));
      prev = i2 + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
__name(safe_str_from_cps, "safe_str_from_cps");
function is_combining_mark(cp, only_nsm) {
  init();
  return only_nsm ? NSM.has(cp) : CM.has(cp);
}
__name(is_combining_mark, "is_combining_mark");
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
__name(should_escape, "should_escape");
function ens_normalize(name) {
  return flatten(split2(name, nfc, filter_fe0f));
}
__name(ens_normalize, "ens_normalize");
function split2(name, nf, ef) {
  if (!name)
    return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type6;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type6 = "ASCII";
      } else {
        let chars = tokens.flatMap((x2) => x2.is_emoji ? [] : x2);
        if (!chars.length) {
          type6 = "Emoji";
        } else {
          if (CM.has(norm[0]))
            throw error_placement("leading combining mark");
          for (let i2 = 1; i2 < token_count; i2++) {
            let cps = tokens[i2];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i2 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g2] = determine_group(unique);
          check_group(g2, chars);
          check_whole(g2, unique);
          type6 = g2.N;
        }
      }
      info.type = type6;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
__name(split2, "split2");
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g2) => set.has(g2)) : Array_from(set);
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g2 of maker) {
      if (shared.every((cp) => group_has_cp(g2, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g2.N}`);
      }
    }
  }
}
__name(check_whole, "check_whole");
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g2) => group_has_cp(g2, cp));
    if (!gs.length) {
      if (!GROUPS.some((g2) => group_has_cp(g2, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
}
__name(determine_group, "determine_group");
function flatten(split3) {
  return split3.map(({ input, error, output }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split3.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
__name(flatten, "flatten");
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
__name(error_disallowed, "error_disallowed");
function error_group_member(g2, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g3) => g3.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g2.N} + ${quoted}`);
}
__name(error_group_member, "error_group_member");
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
__name(error_placement, "error_placement");
function check_group(g2, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g2, cp)) {
      throw error_group_member(g2, cp);
    }
  }
  if (g2.M) {
    let decomposed2 = nfd(cps);
    for (let i2 = 1, e2 = decomposed2.length; i2 < e2; i2++) {
      if (NSM.has(decomposed2[i2])) {
        let j2 = i2 + 1;
        for (let cp; j2 < e2 && NSM.has(cp = decomposed2[j2]); j2++) {
          for (let k = i2; k < j2; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j2 - i2 > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i2 - 1, j2)))} (${j2 - i2}/${NSM_MAX})`);
        }
        i2 = j2;
      }
    }
  }
}
__name(check_group, "check_group");
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
__name(tokens_from_str, "tokens_from_str");
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
__name(filter_fe0f, "filter_fe0f");
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node)
      break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
__name(consume_emoji_reversed, "consume_emoji_reversed");
var COMPRESSED$1;
var FENCED;
var NSM_MAX;
var COMPRESSED;
var S0;
var L0;
var V0;
var T0;
var L_COUNT;
var V_COUNT;
var T_COUNT;
var N_COUNT;
var S_COUNT;
var S1;
var L1;
var V1;
var T1;
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
var HYPHEN;
var STOP_CH;
var FE0F;
var UNIQUE_PH;
var Array_from;
var Emoji;
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;
var init_dist = __esm({
  "../node_modules/@adraffy/ens-normalize/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    COMPRESSED$1 = "AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28";
    FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
    NSM_MAX = 4;
    __name2(decode_arithmetic, "decode_arithmetic");
    __name2(read_payload, "read_payload");
    __name2(read_compressed_payload, "read_compressed_payload");
    __name2(unsafe_atob, "unsafe_atob");
    __name2(signed, "signed");
    __name2(read_deltas, "read_deltas");
    __name2(read_sorted, "read_sorted");
    __name2(read_sorted_arrays, "read_sorted_arrays");
    __name2(read_mapped, "read_mapped");
    __name2(read_array_while, "read_array_while");
    __name2(read_transposed, "read_transposed");
    __name2(read_linear_table, "read_linear_table");
    __name2(read_replacement_table, "read_replacement_table");
    __name2(read_trie, "read_trie");
    __name2(hex_cp, "hex_cp");
    __name2(quote_cp, "quote_cp");
    __name2(explode_cp, "explode_cp");
    __name2(str_from_cps, "str_from_cps");
    __name2(compare_arrays, "compare_arrays");
    COMPRESSED = "AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA";
    S0 = 44032;
    L0 = 4352;
    V0 = 4449;
    T0 = 4519;
    L_COUNT = 19;
    V_COUNT = 21;
    T_COUNT = 28;
    N_COUNT = V_COUNT * T_COUNT;
    S_COUNT = L_COUNT * N_COUNT;
    S1 = S0 + S_COUNT;
    L1 = L0 + L_COUNT;
    V1 = V0 + V_COUNT;
    T1 = T0 + T_COUNT;
    __name2(unpack_cc, "unpack_cc");
    __name2(unpack_cp, "unpack_cp");
    __name2(init$1, "init$1");
    __name2(is_hangul, "is_hangul");
    __name2(compose_pair, "compose_pair");
    __name2(decomposed, "decomposed");
    __name2(composed_from_decomposed, "composed_from_decomposed");
    __name2(nfd, "nfd");
    __name2(nfc, "nfc");
    HYPHEN = 45;
    STOP_CH = ".";
    FE0F = 65039;
    UNIQUE_PH = 1;
    Array_from = /* @__PURE__ */ __name2((x2) => Array.from(x2), "Array_from");
    __name2(group_has_cp, "group_has_cp");
    Emoji = /* @__PURE__ */ __name(class extends Array {
      get is_emoji() {
        return true;
      }
      // free tagging system
    }, "Emoji");
    __name2(Emoji, "Emoji");
    __name2(init, "init");
    __name2(quoted_cp, "quoted_cp");
    __name2(bidi_qq, "bidi_qq");
    __name2(check_label_extension, "check_label_extension");
    __name2(check_leading_underscore, "check_leading_underscore");
    __name2(check_fenced, "check_fenced");
    __name2(safe_str_from_cps, "safe_str_from_cps");
    __name2(is_combining_mark, "is_combining_mark");
    __name2(should_escape, "should_escape");
    __name2(ens_normalize, "ens_normalize");
    __name2(split2, "split");
    __name2(check_whole, "check_whole");
    __name2(determine_group, "determine_group");
    __name2(flatten, "flatten");
    __name2(error_disallowed, "error_disallowed");
    __name2(error_group_member, "error_group_member");
    __name2(error_placement, "error_placement");
    __name2(check_group, "check_group");
    __name2(tokens_from_str, "tokens_from_str");
    __name2(filter_fe0f, "filter_fe0f");
    __name2(consume_emoji_reversed, "consume_emoji_reversed");
  }
});
function unwrapLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash7 = `0x${label.slice(1, 65)}`;
  if (!validate(hash7, { strict: true }))
    return null;
  return hash7;
}
__name(unwrapLabelhash, "unwrapLabelhash");
var init_ens = __esm({
  "../node_modules/ox/_esm/core/internal/ens.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    __name2(unwrapLabelhash, "unwrapLabelhash");
  }
});
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return fromBytes(result);
  return unwrapLabelhash(label) || keccak256(fromString(label));
}
__name(labelhash, "labelhash");
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return fromBytes(result);
  const labels = name.split(".");
  for (let i2 = labels.length - 1; i2 >= 0; i2 -= 1) {
    const hashFromEncodedLabel = unwrapLabelhash(labels[i2]);
    const hashed = hashFromEncodedLabel ? fromHex(hashFromEncodedLabel) : keccak256(fromString2(labels[i2]), { as: "Bytes" });
    result = keccak256(concat2(result, hashed), { as: "Bytes" });
  }
  return fromBytes(result);
}
__name(namehash, "namehash");
function normalize(name) {
  return ens_normalize(name);
}
__name(normalize, "normalize");
var init_Ens = __esm({
  "../node_modules/ox/_esm/core/Ens.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_dist();
    init_Bytes();
    init_Hash();
    init_Hex();
    init_ens();
    __name2(labelhash, "labelhash");
    labelhash.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(namehash, "namehash");
    namehash.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(normalize, "normalize");
    normalize.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function fromRpc6(filter2) {
  const { fromBlock, toBlock } = filter2;
  return {
    ...filter2,
    ...fromBlock && {
      fromBlock: validate(fromBlock, { strict: false }) ? BigInt(fromBlock) : fromBlock
    },
    ...toBlock && {
      toBlock: validate(toBlock, { strict: false }) ? BigInt(toBlock) : toBlock
    }
  };
}
__name(fromRpc6, "fromRpc6");
function toRpc6(filter2) {
  const { address, topics, fromBlock, toBlock } = filter2;
  return {
    ...address && { address },
    ...topics && { topics },
    ...typeof fromBlock !== "undefined" ? {
      fromBlock: typeof fromBlock === "bigint" ? fromNumber(fromBlock) : fromBlock
    } : {},
    ...typeof toBlock !== "undefined" ? {
      toBlock: typeof toBlock === "bigint" ? fromNumber(toBlock) : toBlock
    } : {}
  };
}
__name(toRpc6, "toRpc6");
var init_Filter = __esm({
  "../node_modules/ox/_esm/core/Filter.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    __name2(fromRpc6, "fromRpc");
    fromRpc6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc6, "toRpc");
    toRpc6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function isBytes3(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
__name(isBytes3, "isBytes3");
function abytes3(b2, ...lengths) {
  if (!isBytes3(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
__name(abytes3, "abytes3");
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
__name(isArrayOf, "isArrayOf");
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
__name(afn, "afn");
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
__name(astr, "astr");
function anumber2(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
__name(anumber2, "anumber2");
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
__name(aArr, "aArr");
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
__name(astrArr, "astrArr");
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
__name(anumArr, "anumArr");
function chain(...args) {
  const id3 = /* @__PURE__ */ __name2((a2) => a2, "id");
  const wrap = /* @__PURE__ */ __name2((a2, b2) => (c2) => a2(b2(c2)), "wrap");
  const encode9 = args.map((x2) => x2.encode).reduceRight(wrap, id3);
  const decode4 = args.map((x2) => x2.decode).reduce(wrap, id3);
  return { encode: encode9, decode: decode4 };
}
__name(chain, "chain");
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l2, i2) => [l2, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
__name(alphabet, "alphabet");
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from27) => {
      astrArr("join.decode", from27);
      return from27.join(separator);
    },
    decode: (to3) => {
      astr("join.decode", to3);
      return to3.split(separator);
    }
  };
}
__name(join, "join");
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
__name(padding, "padding");
function normalize2(fn) {
  afn(fn);
  return { encode: (from27) => from27, decode: (to3) => fn(to3) };
}
__name(normalize2, "normalize2");
function convertRadix(data, from27, to3) {
  if (from27 < 2)
    throw new Error(`convertRadix: invalid from=${from27}, base cannot be less than 2`);
  if (to3 < 2)
    throw new Error(`convertRadix: invalid to=${to3}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d2) => {
    anumber2(d2);
    if (d2 < 0 || d2 >= from27)
      throw new Error(`invalid integer: ${d2}`);
    return d2;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from27 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from27 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to3;
      carry = digitBase % to3;
      const rounded = Math.floor(div);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to3 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
__name(convertRadix, "convertRadix");
function convertRadix2(data, from27, to3, padding2) {
  aArr(data);
  if (from27 <= 0 || from27 > 32)
    throw new Error(`convertRadix2: wrong from=${from27}`);
  if (to3 <= 0 || to3 > 32)
    throw new Error(`convertRadix2: wrong to=${to3}`);
  if (radix2carry(from27, to3) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from27} to=${to3} carryBits=${radix2carry(from27, to3)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from27];
  const mask = powers[to3] - 1;
  const res = [];
  for (const n2 of data) {
    anumber2(n2);
    if (n2 >= max)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from27}`);
    carry = carry << from27 | n2;
    if (pos + from27 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from27}`);
    pos += from27;
    for (; pos >= to3; pos -= to3)
      res.push((carry >> pos - to3 & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to3 - pos & mask;
  if (!padding2 && pos >= from27)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
__name(convertRadix2, "convertRadix2");
function radix(num) {
  anumber2(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes3(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
__name(radix, "radix");
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes3(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
__name(radix2, "radix2");
function unsafeWrapper(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e2) {
    }
  };
}
__name(unsafeWrapper, "unsafeWrapper");
function checksum3(len, fn) {
  anumber2(len);
  afn(fn);
  return {
    encode(data) {
      if (!isBytes3(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes3(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn(payload).slice(0, len);
      for (let i2 = 0; i2 < len; i2++)
        if (newChecksum[i2] !== oldChecksum[i2])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
__name(checksum3, "checksum3");
function bech32Polymod(pre) {
  const b2 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b2 >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
__name(bech32Polymod, "bech32Polymod");
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c2 = prefix.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c2 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v2 of words)
    chk = bech32Polymod(chk) ^ v2;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
__name(bechChecksum, "bechChecksum");
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode9(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes3(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  __name(encode9, "encode9");
  __name2(encode9, "encode");
  function decode4(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  __name(decode4, "decode4");
  __name2(decode4, "decode");
  const decodeUnsafe = unsafeWrapper(decode4);
  function decodeToBytes(str) {
    const { prefix, words } = decode4(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  __name(decodeToBytes, "decodeToBytes");
  __name2(decodeToBytes, "decodeToBytes");
  function encodeFromBytes(prefix, bytes) {
    return encode9(prefix, toWords(bytes));
  }
  __name(encodeFromBytes, "encodeFromBytes");
  __name2(encodeFromBytes, "encodeFromBytes");
  return {
    encode: encode9,
    decode: decode4,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
__name(genBech32, "genBech32");
var gcd;
var radix2carry;
var powers;
var utils;
var base16;
var base32;
var base32nopad;
var base32hex;
var base32hexnopad;
var base32crockford;
var hasBase64Builtin;
var base64;
var base64nopad;
var base64url;
var base64urlnopad;
var genBase58;
var base58;
var base58flickr;
var base58xrp;
var createBase58check;
var BECH_ALPHABET;
var POLYMOD_GENERATORS;
var bech32;
var bech32m;
var hasHexBuiltin3;
var hexBuiltin;
var hex;
var init_esm = __esm({
  "../node_modules/@scure/base/lib/esm/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isBytes3, "isBytes");
    __name2(abytes3, "abytes");
    __name2(isArrayOf, "isArrayOf");
    __name2(afn, "afn");
    __name2(astr, "astr");
    __name2(anumber2, "anumber");
    __name2(aArr, "aArr");
    __name2(astrArr, "astrArr");
    __name2(anumArr, "anumArr");
    __name2(chain, "chain");
    __name2(alphabet, "alphabet");
    __name2(join, "join");
    __name2(padding, "padding");
    __name2(normalize2, "normalize");
    __name2(convertRadix, "convertRadix");
    gcd = /* @__PURE__ */ __name2((a2, b2) => b2 === 0 ? a2 : gcd(b2, a2 % b2), "gcd");
    radix2carry = /* @__NO_SIDE_EFFECTS__ */
    /* @__PURE__ */ __name2((from27, to3) => from27 + (to3 - gcd(from27, to3)), "radix2carry");
    powers = /* @__PURE__ */ (() => {
      let res = [];
      for (let i2 = 0; i2 < 40; i2++)
        res.push(2 ** i2);
      return res;
    })();
    __name2(convertRadix2, "convertRadix2");
    __name2(radix, "radix");
    __name2(radix2, "radix2");
    __name2(unsafeWrapper, "unsafeWrapper");
    __name2(checksum3, "checksum");
    utils = {
      alphabet,
      chain,
      checksum: checksum3,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding
    };
    base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
    base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
    base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
    base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
    base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
    base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize2((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
    base64 = hasBase64Builtin ? {
      encode(b2) {
        abytes3(b2);
        return b2.toBase64();
      },
      decode(s2) {
        astr("base64", s2);
        return Uint8Array.fromBase64(s2, { lastChunkHandling: "strict" });
      }
    } : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
    base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
    base64url = hasBase64Builtin ? {
      encode(b2) {
        abytes3(b2);
        return b2.toBase64({ alphabet: "base64url" });
      },
      decode(s2) {
        astr("base64", s2);
        return Uint8Array.fromBase64(s2, { alphabet: "base64url" });
      }
    } : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
    base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
    genBase58 = /* @__NO_SIDE_EFFECTS__ */
    /* @__PURE__ */ __name2((abc) => chain(radix(58), alphabet(abc), join("")), "genBase58");
    base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    createBase58check = /* @__PURE__ */ __name2((sha2564) => chain(checksum3(4, (data) => sha2564(sha2564(data))), base58), "createBase58check");
    BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
    POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    __name2(bech32Polymod, "bech32Polymod");
    __name2(bechChecksum, "bechChecksum");
    __name2(genBech32, "genBech32");
    bech32 = genBech32("bech32");
    bech32m = genBech32("bech32m");
    hasHexBuiltin3 = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
    hexBuiltin = {
      encode(data) {
        abytes3(data);
        return data.toHex();
      },
      decode(s2) {
        astr("hex", s2);
        return Uint8Array.fromHex(s2);
      }
    };
    hex = hasHexBuiltin3 ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize2((s2) => {
      if (typeof s2 !== "string" || s2.length % 2 !== 0)
        throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
      return s2.toLowerCase();
    }));
  }
});
function bytesToNumber(bytes) {
  abytes(bytes);
  const h2 = bytes.length === 0 ? "0" : bytesToHex(bytes);
  return BigInt("0x" + h2);
}
__name(bytesToNumber, "bytesToNumber");
function numberToBytes(num) {
  if (typeof num !== "bigint")
    throw new Error("bigint expected");
  return hexToBytes(num.toString(16).padStart(64, "0"));
}
__name(numberToBytes, "numberToBytes");
var Point2;
var base58check;
var MASTER_SECRET;
var BITCOIN_VERSIONS;
var HARDENED_OFFSET;
var hash160;
var fromU32;
var toU32;
var HDKey;
var init_esm2 = __esm({
  "../node_modules/@scure/bip32/lib/esm/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_modular();
    init_secp256k1();
    init_hmac();
    init_legacy();
    init_sha2();
    init_utils2();
    init_esm();
    Point2 = secp256k1.ProjectivePoint;
    base58check = createBase58check(sha256);
    __name2(bytesToNumber, "bytesToNumber");
    __name2(numberToBytes, "numberToBytes");
    MASTER_SECRET = utf8ToBytes("Bitcoin seed");
    BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
    HARDENED_OFFSET = 2147483648;
    hash160 = /* @__PURE__ */ __name2((data) => ripemd160(sha256(data)), "hash160");
    fromU32 = /* @__PURE__ */ __name2((data) => createView(data).getUint32(0, false), "fromU32");
    toU32 = /* @__PURE__ */ __name2((n2) => {
      if (!Number.isSafeInteger(n2) || n2 < 0 || n2 > 2 ** 32 - 1) {
        throw new Error("invalid number, should be from 0 to 2**32-1, got " + n2);
      }
      const buf = new Uint8Array(4);
      createView(buf).setUint32(0, n2, false);
      return buf;
    }, "toU32");
    HDKey = /* @__PURE__ */ __name(class {
      get fingerprint() {
        if (!this.pubHash) {
          throw new Error("No publicKey set!");
        }
        return fromU32(this.pubHash);
      }
      get identifier() {
        return this.pubHash;
      }
      get pubKeyHash() {
        return this.pubHash;
      }
      get privateKey() {
        return this.privKeyBytes || null;
      }
      get publicKey() {
        return this.pubKey || null;
      }
      get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("No private key");
        }
        return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
      }
      get publicExtendedKey() {
        if (!this.pubKey) {
          throw new Error("No public key");
        }
        return base58check.encode(this.serialize(this.versions.public, this.pubKey));
      }
      static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        abytes(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
          throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
        }
        const I = hmac(sha512, MASTER_SECRET, seed);
        return new HDKey({
          versions,
          chainCode: I.slice(32),
          privateKey: I.slice(0, 32)
        });
      }
      static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        const keyBuffer = base58check.decode(base58key);
        const keyView = createView(keyBuffer);
        const version3 = keyView.getUint32(0, false);
        const opt = {
          versions,
          depth: keyBuffer[4],
          parentFingerprint: keyView.getUint32(5, false),
          index: keyView.getUint32(9, false),
          chainCode: keyBuffer.slice(13, 45)
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version3 !== versions[isPriv ? "private" : "public"]) {
          throw new Error("Version mismatch");
        }
        if (isPriv) {
          return new HDKey({ ...opt, privateKey: key.slice(1) });
        } else {
          return new HDKey({ ...opt, publicKey: key });
        }
      }
      static fromJSON(json) {
        return HDKey.fromExtendedKey(json.xpriv);
      }
      constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== "object") {
          throw new Error("HDKey.constructor must not be called directly");
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode || null;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
          if (this.parentFingerprint || this.index) {
            throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
          }
        }
        if (opt.publicKey && opt.privateKey) {
          throw new Error("HDKey: publicKey and privateKey at same time.");
        }
        if (opt.privateKey) {
          if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
            throw new Error("Invalid private key");
          }
          this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
          this.privKeyBytes = numberToBytes(this.privKey);
          this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
        } else if (opt.publicKey) {
          this.pubKey = Point2.fromHex(opt.publicKey).toRawBytes(true);
        } else {
          throw new Error("HDKey: no public or private key provided");
        }
        this.pubHash = hash160(this.pubKey);
      }
      derive(path2) {
        if (!/^[mM]'?/.test(path2)) {
          throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path2)) {
          return this;
        }
        const parts = path2.replace(/^[mM]'?\//, "").split("/");
        let child = this;
        for (const c2 of parts) {
          const m2 = /^(\d+)('?)$/.exec(c2);
          const m1 = m2 && m2[1];
          if (!m2 || m2.length !== 3 || typeof m1 !== "string")
            throw new Error("invalid child index: " + c2);
          let idx = +m1;
          if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
            throw new Error("Invalid index");
          }
          if (m2[2] === "'") {
            idx += HARDENED_OFFSET;
          }
          child = child.deriveChild(idx);
        }
        return child;
      }
      deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
          throw new Error("No publicKey or chainCode set");
        }
        let data = toU32(index);
        if (index >= HARDENED_OFFSET) {
          const priv = this.privateKey;
          if (!priv) {
            throw new Error("Could not derive hardened child key");
          }
          data = concatBytes(new Uint8Array([0]), priv, data);
        } else {
          data = concatBytes(this.pubKey, data);
        }
        const I = hmac(sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
          throw new Error("Tweak bigger than curve order");
        }
        const opt = {
          versions: this.versions,
          chainCode,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint,
          index
        };
        try {
          if (this.privateKey) {
            const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
            if (!secp256k1.utils.isValidPrivateKey(added)) {
              throw new Error("The tweak was out of range or the resulted private key is invalid");
            }
            opt.privateKey = added;
          } else {
            const added = Point2.fromHex(this.pubKey).add(Point2.fromPrivateKey(childTweak));
            if (added.equals(Point2.ZERO)) {
              throw new Error("The tweak was equal to negative P, which made the result key invalid");
            }
            opt.publicKey = added.toRawBytes(true);
          }
          return new HDKey(opt);
        } catch (err) {
          return this.deriveChild(index + 1);
        }
      }
      sign(hash7) {
        if (!this.privateKey) {
          throw new Error("No privateKey set!");
        }
        abytes(hash7, 32);
        return secp256k1.sign(hash7, this.privKey).toCompactRawBytes();
      }
      verify(hash7, signature) {
        abytes(hash7, 32);
        abytes(signature, 64);
        if (!this.publicKey) {
          throw new Error("No publicKey set!");
        }
        let sig;
        try {
          sig = secp256k1.Signature.fromCompact(signature);
        } catch (error) {
          return false;
        }
        return secp256k1.verify(sig, hash7, this.publicKey);
      }
      wipePrivateData() {
        this.privKey = void 0;
        if (this.privKeyBytes) {
          this.privKeyBytes.fill(0);
          this.privKeyBytes = void 0;
        }
        return this;
      }
      toJSON() {
        return {
          xpriv: this.privateExtendedKey,
          xpub: this.publicExtendedKey
        };
      }
      serialize(version3, key) {
        if (!this.chainCode) {
          throw new Error("No chainCode set");
        }
        abytes(key, 33);
        return concatBytes(toU32(version3), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
      }
    }, "HDKey");
    __name2(HDKey, "HDKey");
  }
});
function getPublicKey(options2) {
  const { privateKey } = options2;
  const point = secp256k1.ProjectivePoint.fromPrivateKey(from2(privateKey).slice(2));
  return from4(point);
}
__name(getPublicKey, "getPublicKey");
function recoverAddress(options2) {
  return fromPublicKey(recoverPublicKey(options2));
}
__name(recoverAddress, "recoverAddress");
function recoverPublicKey(options2) {
  const { payload, signature } = options2;
  const { r: r3, s: s2, yParity } = signature;
  const signature_ = new secp256k1.Signature(BigInt(r3), BigInt(s2)).addRecoveryBit(yParity);
  const point = signature_.recoverPublicKey(from2(payload).substring(2));
  return from4(point);
}
__name(recoverPublicKey, "recoverPublicKey");
function sign2(options2) {
  const { hash: hash7, payload, privateKey } = options2;
  const { r: r3, s: s2, recovery } = secp256k1.sign(from3(payload), from3(privateKey), ...hash7 ? [{ prehash: true, lowS: true }] : []);
  return {
    r: r3,
    s: s2,
    yParity: recovery
  };
}
__name(sign2, "sign2");
function verify2(options2) {
  const { address, hash: hash7, payload, publicKey, signature } = options2;
  if (address)
    return isEqual3(address, recoverAddress({ payload, signature }));
  return secp256k1.verify(signature, from3(payload), toBytes3(publicKey), ...hash7 ? [{ prehash: true, lowS: true }] : []);
}
__name(verify2, "verify2");
var init_Secp256k1 = __esm({
  "../node_modules/ox/_esm/core/Secp256k1.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_secp256k1();
    init_Address();
    init_Bytes();
    init_Hex();
    init_PublicKey();
    __name2(getPublicKey, "getPublicKey");
    __name2(recoverAddress, "recoverAddress");
    recoverAddress.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(recoverPublicKey, "recoverPublicKey");
    recoverPublicKey.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(sign2, "sign");
    sign2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(verify2, "verify");
    verify2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function fromScure(key) {
  return {
    derive: (path2) => fromScure(key.derive(path2)),
    depth: key.depth,
    identifier: fromBytes(key.identifier),
    index: key.index,
    privateKey: fromBytes(key.privateKey),
    privateExtendedKey: key.privateExtendedKey,
    publicKey: getPublicKey({ privateKey: key.privateKey }),
    publicExtendedKey: key.publicExtendedKey,
    versions: key.versions
  };
}
__name(fromScure, "fromScure");
var init_hdKey = __esm({
  "../node_modules/ox/_esm/core/internal/hdKey.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    init_Secp256k1();
    __name2(fromScure, "fromScure");
  }
});
function fromExtendedKey(extendedKey) {
  const key = HDKey.fromExtendedKey(extendedKey);
  return fromScure(key);
}
__name(fromExtendedKey, "fromExtendedKey");
function fromJson(json) {
  return fromScure(HDKey.fromJSON(json));
}
__name(fromJson, "fromJson");
function fromSeed(seed, options2 = {}) {
  const { versions } = options2;
  const key = HDKey.fromMasterSeed(from3(seed), versions);
  return fromScure(key);
}
__name(fromSeed, "fromSeed");
function path(options2 = {}) {
  const { account = 0, change = 0, index = 0 } = options2;
  return `m/44'/60'/${account}'/${change}/${index}`;
}
__name(path, "path");
var init_HdKey = __esm({
  "../node_modules/ox/_esm/core/HdKey.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_esm2();
    init_Bytes();
    init_hdKey();
    __name2(fromExtendedKey, "fromExtendedKey");
    fromExtendedKey.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromJson, "fromJson");
    fromJson.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(fromSeed, "fromSeed");
    fromSeed.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(path, "path");
    path.parseError = (error) => error;
  }
});
var init_Fee = __esm({
  "../node_modules/ox/_esm/core/Fee.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
function fromRpc7(log, _options = {}) {
  return {
    ...log,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null
  };
}
__name(fromRpc7, "fromRpc7");
function toRpc7(log, _options = {}) {
  return {
    address: log.address,
    blockHash: log.blockHash,
    blockNumber: typeof log.blockNumber === "bigint" ? fromNumber(log.blockNumber) : null,
    data: log.data,
    logIndex: typeof log.logIndex === "number" ? fromNumber(log.logIndex) : null,
    topics: log.topics,
    transactionHash: log.transactionHash,
    transactionIndex: typeof log.transactionIndex === "number" ? fromNumber(log.transactionIndex) : null,
    removed: log.removed
  };
}
__name(toRpc7, "toRpc7");
var init_Log = __esm({
  "../node_modules/ox/_esm/core/Log.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    __name2(fromRpc7, "fromRpc");
    fromRpc7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc7, "toRpc");
    toRpc7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function pbkdf2Init(hash7, _password, _salt, _opts) {
  ahash(hash7);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  anumber(c2);
  anumber(dkLen);
  anumber(asyncTick);
  if (c2 < 1)
    throw new Error("iterations (c) should be >= 1");
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash7, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
__name(pbkdf2Init, "pbkdf2Init");
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u2);
  return DK;
}
__name(pbkdf2Output, "pbkdf2Output");
function pbkdf2(hash7, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash7, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view2 = createView(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view2.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti.set(u2.subarray(0, Ti.length));
    for (let ui = 1; ui < c2; ui++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i2 = 0; i2 < Ti.length; i2++)
        Ti[i2] ^= u2[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}
__name(pbkdf2, "pbkdf2");
var init_pbkdf2 = __esm({
  "../node_modules/@noble/hashes/esm/pbkdf2.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_hmac();
    init_utils2();
    __name2(pbkdf2Init, "pbkdf2Init");
    __name2(pbkdf2Output, "pbkdf2Output");
    __name2(pbkdf2, "pbkdf2");
  }
});
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
__name(nfkd, "nfkd");
function normalize3(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
__name(normalize3, "normalize3");
function aentropy(ent) {
  abytes(ent, 16, 20, 24, 28, 32);
}
__name(aentropy, "aentropy");
function generateMnemonic(wordlist, strength = 128) {
  anumber(strength);
  if (strength % 32 !== 0 || strength > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes(strength / 8), wordlist);
}
__name(generateMnemonic, "generateMnemonic");
function getCoder(wordlist) {
  if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
    throw new Error("Wordlist: expected array of 2048 strings");
  wordlist.forEach((i2) => {
    if (typeof i2 !== "string")
      throw new Error("wordlist: non-string element: " + i2);
  });
  return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist));
}
__name(getCoder, "getCoder");
function mnemonicToEntropy(mnemonic, wordlist) {
  const { words } = normalize3(mnemonic);
  const entropy = getCoder(wordlist).decode(words);
  aentropy(entropy);
  return entropy;
}
__name(mnemonicToEntropy, "mnemonicToEntropy");
function entropyToMnemonic(entropy, wordlist) {
  aentropy(entropy);
  const words = getCoder(wordlist).encode(entropy);
  return words.join(isJapanese(wordlist) ? "\u3000" : " ");
}
__name(entropyToMnemonic, "entropyToMnemonic");
function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch (e2) {
    return false;
  }
  return true;
}
__name(validateMnemonic, "validateMnemonic");
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize3(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}
__name(mnemonicToSeedSync, "mnemonicToSeedSync");
var isJapanese;
var calcChecksum;
var psalt;
var init_esm3 = __esm({
  "../node_modules/@scure/bip39/esm/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_pbkdf2();
    init_sha2();
    init_utils2();
    init_esm();
    isJapanese = /* @__PURE__ */ __name2((wordlist) => wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093", "isJapanese");
    __name2(nfkd, "nfkd");
    __name2(normalize3, "normalize");
    __name2(aentropy, "aentropy");
    __name2(generateMnemonic, "generateMnemonic");
    calcChecksum = /* @__PURE__ */ __name2((entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([sha256(entropy)[0] >> bitsLeft << bitsLeft]);
    }, "calcChecksum");
    __name2(getCoder, "getCoder");
    __name2(mnemonicToEntropy, "mnemonicToEntropy");
    __name2(entropyToMnemonic, "entropyToMnemonic");
    __name2(validateMnemonic, "validateMnemonic");
    psalt = /* @__PURE__ */ __name2((passphrase) => nfkd("mnemonic" + passphrase), "psalt");
    __name2(mnemonicToSeedSync, "mnemonicToSeedSync");
  }
});
function random3(wordlist, options2 = {}) {
  const { strength = 128 } = options2;
  return generateMnemonic(wordlist, strength);
}
__name(random3, "random3");
function toHdKey(mnemonic, options2 = {}) {
  const { passphrase } = options2;
  const seed = toSeed(mnemonic, { passphrase });
  return fromSeed(seed);
}
__name(toHdKey, "toHdKey");
function toPrivateKey(mnemonic, options2 = {}) {
  const { path: path2 = path(), passphrase } = options2;
  const hdKey = toHdKey(mnemonic, { passphrase }).derive(path2);
  if (options2.as === "Bytes")
    return from3(hdKey.privateKey);
  return hdKey.privateKey;
}
__name(toPrivateKey, "toPrivateKey");
function toSeed(mnemonic, options2 = {}) {
  const { passphrase } = options2;
  const seed = mnemonicToSeedSync(mnemonic, passphrase);
  if (options2.as === "Hex")
    return toHex(seed);
  return seed;
}
__name(toSeed, "toSeed");
function validate6(mnemonic, wordlist) {
  return validateMnemonic(mnemonic, wordlist);
}
__name(validate6, "validate6");
var init_Mnemonic = __esm({
  "../node_modules/ox/_esm/core/Mnemonic.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_esm3();
    init_Bytes();
    init_HdKey();
    __name2(random3, "random");
    random3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toHdKey, "toHdKey");
    toHdKey.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toPrivateKey, "toPrivateKey");
    toPrivateKey.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toSeed, "toSeed");
    toSeed.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate6, "validate");
    validate6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function encode6(data) {
  const message = from2(data);
  return concat(
    // Personal Sign Format: `0x19  "Ethereum Signed Message:\n"  message.length  message`
    "0x19",
    fromString("Ethereum Signed Message:\n" + size2(message)),
    message
  );
}
__name(encode6, "encode6");
function getSignPayload2(data) {
  return keccak256(encode6(data));
}
__name(getSignPayload2, "getSignPayload2");
var init_PersonalMessage = __esm({
  "../node_modules/ox/_esm/core/PersonalMessage.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hash();
    init_Hex();
    __name2(encode6, "encode");
    encode6.parseError = (error) => error;
    __name2(getSignPayload2, "getSignPayload");
    getSignPayload2.parseError = (error) => error;
  }
});
var require_eventemitter3 = __commonJS({
  "../node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    __name(Events, "Events");
    __name2(Events, "Events");
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    __name(EE, "EE");
    __name2(EE, "EE");
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    __name(addListener, "addListener");
    __name2(addListener, "addListener");
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    __name(clearEvent, "clearEvent");
    __name2(clearEvent, "clearEvent");
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    __name(EventEmitter2, "EventEmitter2");
    __name2(EventEmitter2, "EventEmitter");
    EventEmitter2.prototype.eventNames = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    }, "eventNames"), "eventNames");
    EventEmitter2.prototype.listeners = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    }, "listeners"), "listeners");
    EventEmitter2.prototype.listenerCount = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    }, "listenerCount"), "listenerCount");
    EventEmitter2.prototype.emit = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    }, "emit"), "emit");
    EventEmitter2.prototype.on = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    }, "on"), "on");
    EventEmitter2.prototype.once = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    }, "once"), "once");
    EventEmitter2.prototype.removeListener = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    }, "removeListener"), "removeListener");
    EventEmitter2.prototype.removeAllListeners = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    }, "removeAllListeners"), "removeAllListeners");
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});
var import_index;
var init_eventemitter3 = __esm({
  "../node_modules/eventemitter3/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_index = __toESM(require_eventemitter3(), 1);
  }
});
function parse2(response, options2 = {}) {
  const { raw = false } = options2;
  const response_ = response;
  if (raw)
    return response;
  if (response_.error) {
    const { code } = response_.error;
    const JsonRpcError = (() => {
      if (code === InternalError.code)
        return InternalError;
      if (code === InvalidInputError2.code)
        return InvalidInputError2;
      if (code === InvalidParamsError.code)
        return InvalidParamsError;
      if (code === InvalidRequestError.code)
        return InvalidRequestError;
      if (code === LimitExceededError.code)
        return LimitExceededError;
      if (code === MethodNotFoundError.code)
        return MethodNotFoundError;
      if (code === MethodNotSupportedError.code)
        return MethodNotSupportedError;
      if (code === ParseError.code)
        return ParseError;
      if (code === ResourceNotFoundError.code)
        return ResourceNotFoundError;
      if (code === ResourceUnavailableError.code)
        return ResourceUnavailableError;
      if (code === TransactionRejectedError.code)
        return TransactionRejectedError;
      if (code === VersionNotSupportedError.code)
        return VersionNotSupportedError;
      return BaseError3;
    })();
    throw new JsonRpcError(response_.error);
  }
  return response_.result;
}
__name(parse2, "parse2");
var BaseError3;
var InvalidInputError2;
var ResourceNotFoundError;
var ResourceUnavailableError;
var TransactionRejectedError;
var MethodNotSupportedError;
var LimitExceededError;
var VersionNotSupportedError;
var InvalidRequestError;
var MethodNotFoundError;
var InvalidParamsError;
var InternalError;
var ParseError;
var init_RpcResponse = __esm({
  "../node_modules/ox/_esm/core/RpcResponse.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(parse2, "parse");
    parse2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    BaseError3 = /* @__PURE__ */ __name(class extends Error {
      constructor(errorObject) {
        const { code, message, data } = errorObject;
        super(message);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.BaseError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = code;
        this.data = data;
      }
    }, "BaseError3");
    __name2(BaseError3, "BaseError");
    InvalidInputError2 = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32e3
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.InvalidInputError"
        });
      }
    }, "InvalidInputError2");
    __name2(InvalidInputError2, "InvalidInputError");
    Object.defineProperty(InvalidInputError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    ResourceNotFoundError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32001
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.ResourceNotFoundError"
        });
      }
    }, "ResourceNotFoundError");
    __name2(ResourceNotFoundError, "ResourceNotFoundError");
    Object.defineProperty(ResourceNotFoundError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    ResourceUnavailableError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32002
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.ResourceUnavailableError"
        });
      }
    }, "ResourceUnavailableError");
    __name2(ResourceUnavailableError, "ResourceUnavailableError");
    Object.defineProperty(ResourceUnavailableError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    TransactionRejectedError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32003
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.TransactionRejectedError"
        });
      }
    }, "TransactionRejectedError");
    __name2(TransactionRejectedError, "TransactionRejectedError");
    Object.defineProperty(TransactionRejectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    MethodNotSupportedError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32004
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.MethodNotSupportedError"
        });
      }
    }, "MethodNotSupportedError");
    __name2(MethodNotSupportedError, "MethodNotSupportedError");
    Object.defineProperty(MethodNotSupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    LimitExceededError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32005
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.LimitExceededError"
        });
      }
    }, "LimitExceededError");
    __name2(LimitExceededError, "LimitExceededError");
    Object.defineProperty(LimitExceededError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    VersionNotSupportedError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32006
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.VersionNotSupportedError"
        });
      }
    }, "VersionNotSupportedError");
    __name2(VersionNotSupportedError, "VersionNotSupportedError");
    Object.defineProperty(VersionNotSupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    InvalidRequestError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32600
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.InvalidRequestError"
        });
      }
    }, "InvalidRequestError");
    __name2(InvalidRequestError, "InvalidRequestError");
    Object.defineProperty(InvalidRequestError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    MethodNotFoundError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32601
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.MethodNotFoundError"
        });
      }
    }, "MethodNotFoundError");
    __name2(MethodNotFoundError, "MethodNotFoundError");
    Object.defineProperty(MethodNotFoundError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    InvalidParamsError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32602
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.InvalidParamsError"
        });
      }
    }, "InvalidParamsError");
    __name2(InvalidParamsError, "InvalidParamsError");
    Object.defineProperty(InvalidParamsError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    InternalError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32603
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.InternalErrorError"
        });
      }
    }, "InternalError");
    __name2(InternalError, "InternalError");
    Object.defineProperty(InternalError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    ParseError = /* @__PURE__ */ __name(class extends BaseError3 {
      constructor() {
        super(...arguments);
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: -32700
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcResponse.ParseError"
        });
      }
    }, "ParseError");
    __name2(ParseError, "ParseError");
    Object.defineProperty(ParseError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
  }
});
function createEmitter() {
  const emitter = new import_index.default();
  return {
    get eventNames() {
      return emitter.eventNames.bind(emitter);
    },
    get listenerCount() {
      return emitter.listenerCount.bind(emitter);
    },
    get listeners() {
      return emitter.listeners.bind(emitter);
    },
    addListener: emitter.addListener.bind(emitter),
    emit: emitter.emit.bind(emitter),
    off: emitter.off.bind(emitter),
    on: emitter.on.bind(emitter),
    once: emitter.once.bind(emitter),
    removeAllListeners: emitter.removeAllListeners.bind(emitter),
    removeListener: emitter.removeListener.bind(emitter)
  };
}
__name(createEmitter, "createEmitter");
function from19(provider, options2 = {}) {
  const { includeEvents = true } = options2;
  if (!provider)
    throw new IsUndefinedError();
  return {
    ...includeEvents ? {
      on: provider.on?.bind(provider),
      removeListener: provider.removeListener?.bind(provider)
    } : {},
    async request(args) {
      const result = await provider.request(args);
      if (result && typeof result === "object" && "jsonrpc" in result)
        return parse2(result);
      return result;
    }
  };
}
__name(from19, "from19");
var ProviderRpcError;
var UserRejectedRequestError;
var UnauthorizedError;
var UnsupportedMethodError;
var DisconnectedError;
var ChainDisconnectedError;
var IsUndefinedError;
var init_Provider = __esm({
  "../node_modules/ox/_esm/core/Provider.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_eventemitter3();
    init_Errors();
    init_RpcResponse();
    ProviderRpcError = /* @__PURE__ */ __name(class extends Error {
      constructor(code, message) {
        super(message);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderRpcError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = code;
        this.details = message;
      }
    }, "ProviderRpcError");
    __name2(ProviderRpcError, "ProviderRpcError");
    UserRejectedRequestError = /* @__PURE__ */ __name(class extends ProviderRpcError {
      constructor() {
        super(4001, "The user rejected the request.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Provider.UserRejectedRequestError"
        });
      }
    }, "UserRejectedRequestError");
    __name2(UserRejectedRequestError, "UserRejectedRequestError");
    Object.defineProperty(UserRejectedRequestError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    UnauthorizedError = /* @__PURE__ */ __name(class extends ProviderRpcError {
      constructor() {
        super(4100, "The requested method and/or account has not been authorized by the user.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Provider.UnauthorizedError"
        });
      }
    }, "UnauthorizedError");
    __name2(UnauthorizedError, "UnauthorizedError");
    Object.defineProperty(UnauthorizedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    UnsupportedMethodError = /* @__PURE__ */ __name(class extends ProviderRpcError {
      constructor() {
        super(4200, "The provider does not support the requested method.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Provider.UnsupportedMethodError"
        });
      }
    }, "UnsupportedMethodError");
    __name2(UnsupportedMethodError, "UnsupportedMethodError");
    Object.defineProperty(UnsupportedMethodError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    DisconnectedError = /* @__PURE__ */ __name(class extends ProviderRpcError {
      constructor() {
        super(4900, "The provider is disconnected from all chains.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Provider.DisconnectedError"
        });
      }
    }, "DisconnectedError");
    __name2(DisconnectedError, "DisconnectedError");
    Object.defineProperty(DisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    ChainDisconnectedError = /* @__PURE__ */ __name(class extends ProviderRpcError {
      constructor() {
        super(4901, "The provider is not connected to the requested chain.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Provider.ChainDisconnectedError"
        });
      }
    }, "ChainDisconnectedError");
    __name2(ChainDisconnectedError, "ChainDisconnectedError");
    Object.defineProperty(ChainDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    __name2(createEmitter, "createEmitter");
    createEmitter.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from19, "from");
    from19.parseError = (error) => error;
    IsUndefinedError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("`provider` is undefined.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Provider.IsUndefinedError"
        });
      }
    }, "IsUndefinedError");
    __name2(IsUndefinedError, "IsUndefinedError");
  }
});
var init_RpcSchema = __esm({
  "../node_modules/ox/_esm/core/RpcSchema.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
function createStore2(options2 = {}) {
  let id3 = options2.id ?? 0;
  return {
    prepare(options22) {
      return from20({
        id: id3++,
        ...options22
      });
    },
    get id() {
      return id3;
    }
  };
}
__name(createStore2, "createStore2");
function from20(options2) {
  return {
    ...options2,
    jsonrpc: "2.0"
  };
}
__name(from20, "from20");
var init_RpcRequest = __esm({
  "../node_modules/ox/_esm/core/RpcRequest.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(createStore2, "createStore");
    createStore2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from20, "from");
    from20.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function withTimeout(fn, options2) {
  const { errorInstance = new TimeoutError(), timeout, signal } = options2;
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0)
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        resolve(await fn({ signal: controller.signal }));
      } catch (err) {
        if (err?.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
__name(withTimeout, "withTimeout");
var TimeoutError;
var init_promise = __esm({
  "../node_modules/ox/_esm/core/internal/promise.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Errors();
    __name2(withTimeout, "withTimeout");
    withTimeout.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    TimeoutError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor() {
        super("Operation timed out.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Promise.TimeoutError"
        });
      }
    }, "TimeoutError");
    __name2(TimeoutError, "TimeoutError");
  }
});
function create2(transport, options_root) {
  const requestStore = createStore2();
  return {
    request: async ({ method, params }, options2 = {}) => {
      const body = requestStore.prepare({ method, params });
      const data = await transport.request(body, options2);
      return parse2(data, {
        raw: options2.raw ?? options_root?.raw
      });
    }
  };
}
__name(create2, "create2");
var init_rpcTransport = __esm({
  "../node_modules/ox/_esm/core/internal/rpcTransport.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_RpcRequest();
    init_RpcResponse();
    __name2(create2, "create");
    create2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function fromHttp(url, options2 = {}) {
  return create2({
    async request(body_, options_) {
      const { fetchFn = options2.fetchFn ?? fetch, fetchOptions: fetchOptions_ = options2.fetchOptions, timeout = options2.timeout ?? 1e4 } = options_;
      const body = JSON.stringify(body_);
      const fetchOptions = typeof fetchOptions_ === "function" ? await fetchOptions_(body_) : fetchOptions_;
      const response = await withTimeout(({ signal }) => {
        const init2 = {
          ...fetchOptions,
          body,
          headers: {
            "Content-Type": "application/json",
            ...fetchOptions?.headers
          },
          method: fetchOptions?.method ?? "POST",
          signal: fetchOptions?.signal ?? (timeout > 0 ? signal : null)
        };
        const request = new Request(url, init2);
        return fetchFn(request);
      }, {
        timeout,
        signal: true
      });
      const data = await (async () => {
        if (response.headers.get("Content-Type")?.startsWith("application/json"))
          return response.json();
        return response.text().then((data2) => {
          try {
            return JSON.parse(data2 || "{}");
          } catch (err) {
            if (response.ok)
              throw new MalformedResponseError({
                response: data2
              });
            return { error: data2 };
          }
        });
      })();
      if (!response.ok)
        throw new HttpError({
          body,
          details: JSON.stringify(data.error) ?? response.statusText,
          response,
          url
        });
      return data;
    }
  }, { raw: options2.raw });
}
__name(fromHttp, "fromHttp");
var HttpError;
var MalformedResponseError;
var init_RpcTransport = __esm({
  "../node_modules/ox/_esm/core/RpcTransport.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Errors();
    init_errors2();
    init_promise();
    init_rpcTransport();
    __name2(fromHttp, "fromHttp");
    fromHttp.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    HttpError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ body, details, response, url }) {
        super("HTTP request failed.", {
          details,
          metaMessages: [
            `Status: ${response.status}`,
            `URL: ${getUrl(url)}`,
            body ? `Body: ${JSON.stringify(body)}` : void 0
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcTransport.HttpError"
        });
      }
    }, "HttpError");
    __name2(HttpError, "HttpError");
    MalformedResponseError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ response }) {
        super("HTTP Response could not be parsed as JSON.", {
          metaMessages: [`Response: ${response}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcTransport.MalformedResponseError"
        });
      }
    }, "MalformedResponseError");
    __name2(MalformedResponseError, "MalformedResponseError");
  }
});
var Fp256;
var p256_a;
var p256_b;
var p256;
var Fp384;
var p384_a;
var p384_b;
var p384;
var Fp521;
var p521_a;
var p521_b;
var p521;
var init_nist = __esm({
  "../node_modules/@noble/curves/esm/nist.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sha2();
    init_shortw_utils();
    init_modular();
    Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
    p256_a = Fp256.create(BigInt("-3"));
    p256_b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
    p256 = createCurve({
      a: p256_a,
      b: p256_b,
      Fp: Fp256,
      n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
      Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
      Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
      h: BigInt(1),
      lowS: false
    }, sha256);
    Fp384 = Field(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"));
    p384_a = Fp384.create(BigInt("-3"));
    p384_b = BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
    p384 = createCurve({
      a: p384_a,
      b: p384_b,
      Fp: Fp384,
      n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
      Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
      Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
      h: BigInt(1),
      lowS: false
    }, sha384);
    Fp521 = Field(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
    p521_a = Fp521.create(BigInt("-3"));
    p521_b = BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");
    p521 = createCurve({
      a: p521_a,
      b: p521_b,
      Fp: Fp521,
      n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
      Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
      Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),
      h: BigInt(1),
      lowS: false,
      allowedPrivateKeyLengths: [130, 131, 132]
      // P521 keys are variable-length. Normalize to 132b
    }, sha512);
  }
});
var p2562;
var secp256r1;
var init_p256 = __esm({
  "../node_modules/@noble/curves/esm/p256.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_nist();
    p2562 = p256;
    secp256r1 = p256;
  }
});
function recoverPublicKey2(options2) {
  const { payload, signature } = options2;
  const { r: r3, s: s2, yParity } = signature;
  const signature_ = new secp256r1.Signature(BigInt(r3), BigInt(s2)).addRecoveryBit(yParity);
  const payload_ = payload instanceof Uint8Array ? fromBytes(payload) : payload;
  const point = signature_.recoverPublicKey(payload_.substring(2));
  return from4(point);
}
__name(recoverPublicKey2, "recoverPublicKey2");
function sign3(options2) {
  const { hash: hash7, payload, privateKey } = options2;
  const { r: r3, s: s2, recovery } = secp256r1.sign(payload instanceof Uint8Array ? payload : fromHex(payload), privateKey instanceof Uint8Array ? privateKey : fromHex(privateKey), ...hash7 ? [{ prehash: true, lowS: true }] : []);
  return {
    r: r3,
    s: s2,
    yParity: recovery
  };
}
__name(sign3, "sign3");
function verify3(options2) {
  const { hash: hash7, payload, publicKey, signature } = options2;
  return secp256r1.verify(signature, payload instanceof Uint8Array ? payload : fromHex(payload), toHex2(publicKey).substring(2), ...hash7 ? [{ prehash: true, lowS: true }] : []);
}
__name(verify3, "verify3");
var init_P256 = __esm({
  "../node_modules/ox/_esm/core/P256.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_p256();
    init_Bytes();
    init_Hex();
    init_PublicKey();
    __name2(recoverPublicKey2, "recoverPublicKey");
    recoverPublicKey2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(sign3, "sign");
    sign3.parseError = (error) => error;
    __name2(verify3, "verify");
    verify3.parseError = (error) => error;
  }
});
function createMessage(value) {
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version3 } = value;
  {
    if (chainId !== Math.floor(chainId))
      throw new InvalidMessageFieldError({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${chainId}`
        ]
      });
    if (!(domainRegex.test(domain) || ipRegex.test(domain) || localhostRegex.test(domain)))
      throw new InvalidMessageFieldError({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${domain}`
        ]
      });
    if (!nonceRegex.test(nonce))
      throw new InvalidMessageFieldError({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${nonce}`
        ]
      });
    if (!isUri(uri))
      throw new InvalidMessageFieldError({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${uri}`
        ]
      });
    if (version3 !== "1")
      throw new InvalidMessageFieldError({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${version3}`
        ]
      });
    if (scheme && !schemeRegex.test(scheme))
      throw new InvalidMessageFieldError({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${scheme}`
        ]
      });
    const statement2 = value.statement;
    if (statement2?.includes("\n"))
      throw new InvalidMessageFieldError({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${statement2}`
        ]
      });
  }
  const address = from5(value.address);
  const origin = (() => {
    if (scheme)
      return `${scheme}://${domain}`;
    return domain;
  })();
  const statement = (() => {
    if (!value.statement)
      return "";
    return `${value.statement}
`;
  })();
  const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version3}
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!isUri(resource))
        throw new InvalidMessageFieldError({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${resource}`
          ]
        });
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}
__name(createMessage, "createMessage");
function isUri(value) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value))
    return false;
  if (/%[^0-9a-f]/i.test(value))
    return false;
  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
    return false;
  const splitted = splitUri(value);
  const scheme = splitted[1];
  const authority = splitted[2];
  const path2 = splitted[3];
  const query = splitted[4];
  const fragment = splitted[5];
  if (!(scheme?.length && path2 && path2.length >= 0))
    return false;
  if (authority?.length) {
    if (!(path2.length === 0 || /^\//.test(path2)))
      return false;
  } else {
    if (/^\/\//.test(path2))
      return false;
  }
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
    return false;
  let out = "";
  out += `${scheme}:`;
  if (authority?.length)
    out += `//${authority}`;
  out += path2;
  if (query?.length)
    out += `?${query}`;
  if (fragment?.length)
    out += `#${fragment}`;
  return out;
}
__name(isUri, "isUri");
function splitUri(value) {
  return value.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
__name(splitUri, "splitUri");
var domainRegex;
var ipRegex;
var localhostRegex;
var nonceRegex;
var schemeRegex;
var InvalidMessageFieldError;
var init_Siwe = __esm({
  "../node_modules/ox/_esm/core/Siwe.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Address();
    init_Errors();
    domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;
    ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;
    localhostRegex = /^localhost(:[0-9]{1,5})?$/;
    nonceRegex = /^[a-zA-Z0-9]{8,}$/;
    schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;
    __name2(createMessage, "createMessage");
    createMessage.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(isUri, "isUri");
    __name2(splitUri, "splitUri");
    InvalidMessageFieldError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor(parameters) {
        const { field, metaMessages } = parameters;
        super(`Invalid Sign-In with Ethereum message field "${field}".`, {
          metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Siwe.InvalidMessageFieldError"
        });
      }
    }, "InvalidMessageFieldError");
    __name2(InvalidMessageFieldError, "InvalidMessageFieldError");
  }
});
function format8(value, decimals = 0) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
__name(format8, "format8");
function formatEther(wei, unit = "wei") {
  return format8(wei, exponents.ether - exponents[unit]);
}
__name(formatEther, "formatEther");
function formatGwei(wei, unit = "wei") {
  return format8(wei, exponents.gwei - exponents[unit]);
}
__name(formatGwei, "formatGwei");
function from21(value, decimals = 0) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
    throw new InvalidDecimalNumberError({ value });
  let [integer = "", fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}
__name(from21, "from21");
function fromEther(ether, unit = "wei") {
  return from21(ether, exponents.ether - exponents[unit]);
}
__name(fromEther, "fromEther");
function fromGwei(gwei, unit = "wei") {
  return from21(gwei, exponents.gwei - exponents[unit]);
}
__name(fromGwei, "fromGwei");
var exponents;
var InvalidDecimalNumberError;
var init_Value = __esm({
  "../node_modules/ox/_esm/core/Value.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Errors();
    exponents = {
      wei: 0,
      gwei: 9,
      szabo: 12,
      finney: 15,
      ether: 18
    };
    __name2(format8, "format");
    format8.parseError = (error) => error;
    __name2(formatEther, "formatEther");
    formatEther.parseError = (error) => error;
    __name2(formatGwei, "formatGwei");
    formatGwei.parseError = (error) => error;
    __name2(from21, "from");
    from21.parseError = (error) => error;
    __name2(fromEther, "fromEther");
    fromEther.parseError = (error) => error;
    __name2(fromGwei, "fromGwei");
    fromGwei.parseError = (error) => error;
    InvalidDecimalNumberError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ value }) {
        super(`Value \`${value}\` is not a valid decimal number.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Value.InvalidDecimalNumberError"
        });
      }
    }, "InvalidDecimalNumberError");
    __name2(InvalidDecimalNumberError, "InvalidDecimalNumberError");
  }
});
var FeeCapTooHighError;
var GasPriceTooHighError;
var InvalidChainIdError;
var InvalidSerializedError;
var TipAboveFeeCapError;
var init_TransactionEnvelope = __esm({
  "../node_modules/ox/_esm/core/TransactionEnvelope.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Errors();
    init_Value();
    FeeCapTooHighError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ feeCap } = {}) {
        super(`The fee cap (\`maxFeePerGas\`/\`maxPriorityFeePerGas\`${feeCap ? ` = ${formatGwei(feeCap)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionEnvelope.FeeCapTooHighError"
        });
      }
    }, "FeeCapTooHighError");
    __name2(FeeCapTooHighError, "FeeCapTooHighError");
    GasPriceTooHighError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ gasPrice } = {}) {
        super(`The gas price (\`gasPrice\`${gasPrice ? ` = ${formatGwei(gasPrice)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionEnvelope.GasPriceTooHighError"
        });
      }
    }, "GasPriceTooHighError");
    __name2(GasPriceTooHighError, "GasPriceTooHighError");
    InvalidChainIdError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ chainId }) {
        super(typeof chainId !== "undefined" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionEnvelope.InvalidChainIdError"
        });
      }
    }, "InvalidChainIdError");
    __name2(InvalidChainIdError, "InvalidChainIdError");
    InvalidSerializedError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ attributes, serialized, type: type6 }) {
        const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
        super(`Invalid serialized transaction of type "${type6}" was provided.`, {
          metaMessages: [
            `Serialized Transaction: "${serialized}"`,
            missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionEnvelope.InvalidSerializedError"
        });
      }
    }, "InvalidSerializedError");
    __name2(InvalidSerializedError, "InvalidSerializedError");
    TipAboveFeeCapError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionEnvelope.TipAboveFeeCapError"
        });
      }
    }, "TipAboveFeeCapError");
    __name2(TipAboveFeeCapError, "TipAboveFeeCapError");
  }
});
function assert6(envelope) {
  const { chainId, gasPrice, to: to3 } = envelope;
  if (to3)
    assert4(to3, { strict: false });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
__name(assert6, "assert6");
function deserialize(serialized) {
  const tuple = toHex3(serialized);
  const [nonce, gasPrice, gas, to3, value, data, chainIdOrV_, r3, s2] = tuple;
  if (!(tuple.length === 6 || tuple.length === 9))
    throw new InvalidSerializedError({
      attributes: {
        nonce,
        gasPrice,
        gas,
        to: to3,
        value,
        data,
        ...tuple.length > 6 ? {
          v: chainIdOrV_,
          r: r3,
          s: s2
        } : {}
      },
      serialized,
      type
    });
  const transaction = {
    type
  };
  if (validate(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate(data) && data !== "0x")
    transaction.data = data;
  if (validate(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (tuple.length === 6)
    return transaction;
  const chainIdOrV = validate(chainIdOrV_) && chainIdOrV_ !== "0x" ? Number(chainIdOrV_) : 0;
  if (s2 === "0x" && r3 === "0x") {
    if (chainIdOrV > 0)
      transaction.chainId = Number(chainIdOrV);
    return transaction;
  }
  const v2 = chainIdOrV;
  const chainId = Math.floor((v2 - 35) / 2);
  if (chainId > 0)
    transaction.chainId = chainId;
  else if (v2 !== 27 && v2 !== 28)
    throw new InvalidVError({ value: v2 });
  transaction.yParity = vToYParity(v2);
  transaction.v = v2;
  transaction.s = s2 === "0x" ? 0n : BigInt(s2);
  transaction.r = r3 === "0x" ? 0n : BigInt(r3);
  assert6(transaction);
  return transaction;
}
__name(deserialize, "deserialize");
function from22(envelope, options2 = {}) {
  const { signature } = options2;
  const envelope_ = typeof envelope === "string" ? deserialize(envelope) : envelope;
  assert6(envelope_);
  const signature_ = (() => {
    if (!signature)
      return {};
    const s2 = from13(signature);
    s2.v = yParityToV(s2.yParity);
    return s2;
  })();
  return {
    ...envelope_,
    ...signature_,
    type: "legacy"
  };
}
__name(from22, "from22");
function getSignPayload3(envelope) {
  return hash2(envelope, { presign: true });
}
__name(getSignPayload3, "getSignPayload3");
function hash2(envelope, options2 = {}) {
  const { presign } = options2;
  return keccak256(serialize({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
__name(hash2, "hash2");
function serialize(envelope, options2 = {}) {
  const { chainId = 0, gas, data, input, nonce, to: to3, value, gasPrice } = envelope;
  assert6(envelope);
  let serialized = [
    nonce ? fromNumber(nonce) : "0x",
    gasPrice ? fromNumber(gasPrice) : "0x",
    gas ? fromNumber(gas) : "0x",
    to3 ?? "0x",
    value ? fromNumber(value) : "0x",
    data ?? input ?? "0x"
  ];
  const signature = (() => {
    if (options2.signature)
      return {
        r: options2.signature.r,
        s: options2.signature.s,
        v: yParityToV(options2.signature.yParity)
      };
    if (typeof envelope.r === "undefined" || typeof envelope.s === "undefined")
      return void 0;
    return {
      r: envelope.r,
      s: envelope.s,
      v: envelope.v
    };
  })();
  if (signature) {
    const v2 = (() => {
      if (signature.v >= 35) {
        const inferredChainId = Math.floor((signature.v - 35) / 2);
        if (inferredChainId > 0)
          return signature.v;
        return 27 + (signature.v === 35 ? 0 : 1);
      }
      if (chainId > 0)
        return chainId * 2 + 35 + signature.v - 27;
      const v3 = 27 + (signature.v === 27 ? 0 : 1);
      if (signature.v !== v3)
        throw new InvalidVError({ value: signature.v });
      return v3;
    })();
    serialized = [
      ...serialized,
      fromNumber(v2),
      signature.r === 0n ? "0x" : trimLeft(fromNumber(signature.r)),
      signature.s === 0n ? "0x" : trimLeft(fromNumber(signature.s))
    ];
  } else if (chainId > 0)
    serialized = [...serialized, fromNumber(chainId), "0x", "0x"];
  return fromHex3(serialized);
}
__name(serialize, "serialize");
function toRpc8(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: typeof envelope.chainId === "number" ? fromNumber(envelope.chainId) : void 0,
    data: envelope.data ?? envelope.input,
    type: "0x0",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber(envelope.gasPrice) } : {},
    ...signature ? {
      ...toRpc(signature),
      v: signature.yParity === 0 ? "0x1b" : "0x1c"
    } : {}
  };
}
__name(toRpc8, "toRpc8");
function validate7(envelope) {
  try {
    assert6(envelope);
    return true;
  } catch {
    return false;
  }
}
__name(validate7, "validate7");
var type;
var init_TransactionEnvelopeLegacy = __esm({
  "../node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Address();
    init_Hash();
    init_Hex();
    init_Rlp();
    init_Signature();
    init_TransactionEnvelope();
    type = "legacy";
    __name2(assert6, "assert");
    assert6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(deserialize, "deserialize");
    deserialize.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from22, "from");
    from22.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSignPayload3, "getSignPayload");
    getSignPayload3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(hash2, "hash");
    hash2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(serialize, "serialize");
    serialize.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc8, "toRpc");
    toRpc8.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate7, "validate");
    validate7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function assert7(envelope) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to3 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to3)
    assert4(to3, { strict: false });
  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ feeCap: maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({
      maxFeePerGas,
      maxPriorityFeePerGas
    });
}
__name(assert7, "assert7");
function deserialize2(serialized) {
  const transactionArray = toHex3(slice(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to3, value, data, accessList, yParity, r3, s2] = transactionArray;
  if (!(transactionArray.length === 9 || transactionArray.length === 12))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to3,
        value,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r3,
          s: s2
        } : {}
      },
      serialized,
      type: type2
    });
  let transaction = {
    chainId: Number(chainId),
    type: type2
  };
  if (validate(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate(data) && data !== "0x")
    transaction.data = data;
  if (validate(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r3 && s2 && yParity ? fromTuple([yParity, r3, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert7(transaction);
  return transaction;
}
__name(deserialize2, "deserialize2");
function from23(envelope, options2 = {}) {
  const { signature } = options2;
  const envelope_ = typeof envelope === "string" ? deserialize2(envelope) : envelope;
  assert7(envelope_);
  return {
    ...envelope_,
    ...signature ? from13(signature) : {},
    type: "eip1559"
  };
}
__name(from23, "from23");
function getSignPayload4(envelope) {
  return hash3(envelope, { presign: true });
}
__name(getSignPayload4, "getSignPayload4");
function hash3(envelope, options2 = {}) {
  const { presign } = options2;
  return keccak256(serialize2({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
__name(hash3, "hash3");
function serialize2(envelope, options2 = {}) {
  const { chainId, gas, nonce, to: to3, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert7(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract(options2.signature || envelope);
  const serialized = [
    fromNumber(chainId),
    nonce ? fromNumber(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber(maxFeePerGas) : "0x",
    gas ? fromNumber(gas) : "0x",
    to3 ?? "0x",
    value ? fromNumber(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat(serializedType, fromHex3(serialized));
}
__name(serialize2, "serialize2");
function toRpc9(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: fromNumber(envelope.chainId),
    data: envelope.data ?? envelope.input,
    type: "0x2",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber(envelope.value) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? {
      maxPriorityFeePerGas: fromNumber(envelope.maxPriorityFeePerGas)
    } : {},
    ...signature ? toRpc(signature) : {}
  };
}
__name(toRpc9, "toRpc9");
function validate8(envelope) {
  try {
    assert7(envelope);
    return true;
  } catch {
    return false;
  }
}
__name(validate8, "validate8");
var serializedType;
var type2;
var init_TransactionEnvelopeEip1559 = __esm({
  "../node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_AccessList();
    init_Address();
    init_Hash();
    init_Hex();
    init_Rlp();
    init_Signature();
    init_TransactionEnvelope();
    serializedType = "0x02";
    type2 = "eip1559";
    __name2(assert7, "assert");
    assert7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(deserialize2, "deserialize");
    deserialize2.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from23, "from");
    from23.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSignPayload4, "getSignPayload");
    getSignPayload4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(hash3, "hash");
    hash3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(serialize2, "serialize");
    serialize2.parseError = (error) => error;
    __name2(toRpc9, "toRpc");
    toRpc9.parseError = (error) => error;
    __name2(validate8, "validate");
    validate8.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function assert8(envelope) {
  const { chainId, gasPrice, to: to3 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to3)
    assert4(to3, { strict: false });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
__name(assert8, "assert8");
function deserialize3(serialized) {
  const transactionArray = toHex3(slice(serialized, 1));
  const [chainId, nonce, gasPrice, gas, to3, value, data, accessList, yParity, r3, s2] = transactionArray;
  if (!(transactionArray.length === 8 || transactionArray.length === 11))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        gasPrice,
        gas,
        to: to3,
        value,
        data,
        accessList,
        ...transactionArray.length > 8 ? {
          yParity,
          r: r3,
          s: s2
        } : {}
      },
      serialized,
      type: type3
    });
  let transaction = {
    chainId: Number(chainId),
    type: type3
  };
  if (validate(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate(data) && data !== "0x")
    transaction.data = data;
  if (validate(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r3 && s2 && yParity ? fromTuple([yParity, r3, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert8(transaction);
  return transaction;
}
__name(deserialize3, "deserialize3");
function from24(envelope, options2 = {}) {
  const { signature } = options2;
  const envelope_ = typeof envelope === "string" ? deserialize3(envelope) : envelope;
  assert8(envelope_);
  return {
    ...envelope_,
    ...signature ? from13(signature) : {},
    type: "eip2930"
  };
}
__name(from24, "from24");
function getSignPayload5(envelope) {
  return hash4(envelope, { presign: true });
}
__name(getSignPayload5, "getSignPayload5");
function hash4(envelope, options2 = {}) {
  const { presign } = options2;
  return keccak256(serialize3({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
__name(hash4, "hash4");
function serialize3(envelope, options2 = {}) {
  const { chainId, gas, data, input, nonce, to: to3, value, accessList, gasPrice } = envelope;
  assert8(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract(options2.signature || envelope);
  const serialized = [
    fromNumber(chainId),
    nonce ? fromNumber(nonce) : "0x",
    gasPrice ? fromNumber(gasPrice) : "0x",
    gas ? fromNumber(gas) : "0x",
    to3 ?? "0x",
    value ? fromNumber(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat("0x01", fromHex3(serialized));
}
__name(serialize3, "serialize3");
function toRpc10(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: fromNumber(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber(envelope.gasPrice) } : {},
    type: "0x1",
    ...signature ? toRpc(signature) : {}
  };
}
__name(toRpc10, "toRpc10");
function validate9(envelope) {
  try {
    assert8(envelope);
    return true;
  } catch {
    return false;
  }
}
__name(validate9, "validate9");
var type3;
var init_TransactionEnvelopeEip2930 = __esm({
  "../node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_AccessList();
    init_Address();
    init_Hash();
    init_Hex();
    init_Rlp();
    init_Signature();
    init_TransactionEnvelope();
    type3 = "eip2930";
    __name2(assert8, "assert");
    assert8.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(deserialize3, "deserialize");
    deserialize3.parseError = (error) => error;
    __name2(from24, "from");
    from24.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSignPayload5, "getSignPayload");
    getSignPayload5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(hash4, "hash");
    hash4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(serialize3, "serialize");
    serialize3.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc10, "toRpc");
    toRpc10.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate9, "validate");
    validate9.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function assert9(envelope) {
  const { blobVersionedHashes } = envelope;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobVersionedHashesError();
    for (const hash7 of blobVersionedHashes) {
      const size3 = size2(hash7);
      const version3 = toNumber(slice(hash7, 0, 1));
      if (size3 !== 32)
        throw new InvalidVersionedHashSizeError({ hash: hash7, size: size3 });
      if (version3 !== versionedHashVersion)
        throw new InvalidVersionedHashVersionError({
          hash: hash7,
          version: version3
        });
    }
  }
  assert7(envelope);
}
__name(assert9, "assert9");
function deserialize4(serialized) {
  const transactionOrWrapperArray = toHex3(slice(serialized, 1));
  const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
  const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
  const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to3, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, yParity, r3, s2] = transactionArray;
  const [blobs, commitments, proofs] = wrapperArray;
  if (!(transactionArray.length === 11 || transactionArray.length === 14))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to3,
        value,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r3,
          s: s2
        } : {}
      },
      serialized,
      type: type4
    });
  let transaction = {
    blobVersionedHashes,
    chainId: Number(chainId),
    type: type4
  };
  if (validate(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate(data) && data !== "0x")
    transaction.data = data;
  if (validate(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate(maxFeePerBlobGas) && maxFeePerBlobGas !== "0x")
    transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas);
  if (validate(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList?.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (blobs && commitments && proofs)
    transaction.sidecars = toSidecars(blobs, {
      commitments,
      proofs
    });
  const signature = r3 && s2 && yParity ? fromTuple([yParity, r3, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert9(transaction);
  return transaction;
}
__name(deserialize4, "deserialize4");
function from25(envelope, options2 = {}) {
  const { signature } = options2;
  const envelope_ = typeof envelope === "string" ? deserialize4(envelope) : envelope;
  assert9(envelope_);
  return {
    ...envelope_,
    ...signature ? from13(signature) : {},
    type: "eip4844"
  };
}
__name(from25, "from25");
function getSignPayload6(envelope) {
  return hash5(envelope, { presign: true });
}
__name(getSignPayload6, "getSignPayload6");
function hash5(envelope, options2 = {}) {
  const { presign } = options2;
  return keccak256(serialize4({
    ...envelope,
    ...presign ? {
      sidecars: void 0,
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
__name(hash5, "hash5");
function serialize4(envelope, options2 = {}) {
  const { blobVersionedHashes, chainId, gas, nonce, to: to3, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = envelope;
  assert9(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract(options2.signature || envelope);
  const serialized = [
    fromNumber(chainId),
    nonce ? fromNumber(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber(maxFeePerGas) : "0x",
    gas ? fromNumber(gas) : "0x",
    to3 ?? "0x",
    value ? fromNumber(value) : "0x",
    data ?? "0x",
    accessTupleList,
    maxFeePerBlobGas ? fromNumber(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...signature ? toTuple(signature) : []
  ];
  const sidecars = options2.sidecars || envelope.sidecars;
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i2 = 0; i2 < sidecars.length; i2++) {
      const { blob, commitment, proof } = sidecars[i2];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concat("0x03", sidecars ? (
    // If sidecars are provided, envelope turns into a "network wrapper":
    fromHex3([serialized, blobs, commitments, proofs])
  ) : (
    // Otherwise, standard envelope is used:
    fromHex3(serialized)
  ));
}
__name(serialize4, "serialize4");
function toRpc11(envelope) {
  const signature = extract(envelope);
  return {
    ...envelope,
    chainId: fromNumber(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber(envelope.value) } : {},
    ...typeof envelope.maxFeePerBlobGas === "bigint" ? { maxFeePerBlobGas: fromNumber(envelope.maxFeePerBlobGas) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? { maxPriorityFeePerGas: fromNumber(envelope.maxPriorityFeePerGas) } : {},
    type: "0x3",
    ...signature ? toRpc(signature) : {}
  };
}
__name(toRpc11, "toRpc11");
function validate10(envelope) {
  try {
    assert9(envelope);
    return true;
  } catch {
    return false;
  }
}
__name(validate10, "validate10");
var type4;
var init_TransactionEnvelopeEip4844 = __esm({
  "../node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_AccessList();
    init_Blobs();
    init_Hash();
    init_Hex();
    init_Kzg();
    init_Rlp();
    init_Signature();
    init_TransactionEnvelope();
    init_TransactionEnvelopeEip1559();
    type4 = "eip4844";
    __name2(assert9, "assert");
    assert9.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(deserialize4, "deserialize");
    deserialize4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from25, "from");
    from25.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSignPayload6, "getSignPayload");
    getSignPayload6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(hash5, "hash");
    hash5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(serialize4, "serialize");
    serialize4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc11, "toRpc");
    toRpc11.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate10, "validate");
    validate10.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function assert10(envelope) {
  const { authorizationList } = envelope;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { address, chainId } = authorization;
      if (address)
        assert4(address, { strict: false });
      if (Number(chainId) < 0)
        throw new InvalidChainIdError({ chainId });
    }
  }
  assert7(envelope);
}
__name(assert10, "assert10");
function deserialize5(serialized) {
  const transactionArray = toHex3(slice(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to3, value, data, accessList, authorizationList, yParity, r3, s2] = transactionArray;
  if (!(transactionArray.length === 10 || transactionArray.length === 13))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to3,
        value,
        data,
        accessList,
        authorizationList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r3,
          s: s2
        } : {}
      },
      serialized,
      type: type5
    });
  let transaction = {
    chainId: Number(chainId),
    type: type5
  };
  if (validate(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate(data) && data !== "0x")
    transaction.data = data;
  if (validate(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (authorizationList !== "0x")
    transaction.authorizationList = fromTupleList2(authorizationList);
  const signature = r3 && s2 && yParity ? fromTuple([yParity, r3, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert10(transaction);
  return transaction;
}
__name(deserialize5, "deserialize5");
function from26(envelope, options2 = {}) {
  const { signature } = options2;
  const envelope_ = typeof envelope === "string" ? deserialize5(envelope) : envelope;
  assert10(envelope_);
  return {
    ...envelope_,
    ...signature ? from13(signature) : {},
    type: "eip7702"
  };
}
__name(from26, "from26");
function getSignPayload7(envelope) {
  return hash6(envelope, { presign: true });
}
__name(getSignPayload7, "getSignPayload7");
function hash6(envelope, options2 = {}) {
  const { presign } = options2;
  return keccak256(serialize5({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0
    } : {}
  }));
}
__name(hash6, "hash6");
function serialize5(envelope, options2 = {}) {
  const { authorizationList, chainId, gas, nonce, to: to3, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert10(envelope);
  const accessTupleList = toTupleList(accessList);
  const authorizationTupleList = toTupleList2(authorizationList);
  const signature = extract(options2.signature || envelope);
  const serialized = [
    fromNumber(chainId),
    nonce ? fromNumber(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber(maxFeePerGas) : "0x",
    gas ? fromNumber(gas) : "0x",
    to3 ?? "0x",
    value ? fromNumber(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    authorizationTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat(serializedType2, fromHex3(serialized));
}
__name(serialize5, "serialize5");
function validate11(envelope) {
  try {
    assert10(envelope);
    return true;
  } catch {
    return false;
  }
}
__name(validate11, "validate11");
var serializedType2;
var type5;
var init_TransactionEnvelopeEip7702 = __esm({
  "../node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_AccessList();
    init_Address();
    init_Authorization();
    init_Hash();
    init_Hex();
    init_Rlp();
    init_Signature();
    init_TransactionEnvelope();
    init_TransactionEnvelopeEip1559();
    serializedType2 = "0x04";
    type5 = "eip7702";
    __name2(assert10, "assert");
    assert10.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(deserialize5, "deserialize");
    deserialize5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(from26, "from");
    from26.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSignPayload7, "getSignPayload");
    getSignPayload7.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(hash6, "hash");
    hash6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(serialize5, "serialize");
    serialize5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate11, "validate");
    validate11.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function fromRpc8(receipt) {
  if (!receipt)
    return null;
  return {
    ...receipt,
    blobGasPrice: receipt.blobGasPrice ? BigInt(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : void 0,
    blockNumber: BigInt(receipt.blockNumber ?? 0n),
    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),
    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),
    gasUsed: BigInt(receipt.gasUsed ?? 0n),
    logs: receipt.logs.map((log) => fromRpc7(log, { pending: false })),
    status: fromRpcStatus[receipt.status],
    transactionIndex: Number(receipt.transactionIndex ?? 0),
    type: fromRpcType2[receipt.type] || receipt.type
  };
}
__name(fromRpc8, "fromRpc8");
function toRpc12(receipt) {
  return {
    blobGasPrice: receipt.blobGasPrice ? fromNumber(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? fromNumber(receipt.blobGasUsed) : void 0,
    blockHash: receipt.blockHash,
    blockNumber: fromNumber(receipt.blockNumber),
    contractAddress: receipt.contractAddress,
    cumulativeGasUsed: fromNumber(receipt.cumulativeGasUsed),
    effectiveGasPrice: fromNumber(receipt.effectiveGasPrice),
    from: receipt.from,
    gasUsed: fromNumber(receipt.gasUsed),
    logs: receipt.logs.map(toRpc7),
    logsBloom: receipt.logsBloom,
    root: receipt.root,
    status: toRpcStatus[receipt.status],
    to: receipt.to,
    transactionHash: receipt.transactionHash,
    transactionIndex: fromNumber(receipt.transactionIndex),
    type: toRpcType2[receipt.type] ?? receipt.type
  };
}
__name(toRpc12, "toRpc12");
var fromRpcStatus;
var toRpcStatus;
var fromRpcType2;
var toRpcType2;
var init_TransactionReceipt = __esm({
  "../node_modules/ox/_esm/core/TransactionReceipt.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hex();
    init_Log();
    fromRpcStatus = {
      "0x0": "reverted",
      "0x1": "success"
    };
    toRpcStatus = {
      reverted: "0x0",
      success: "0x1"
    };
    fromRpcType2 = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559",
      "0x3": "eip4844",
      "0x4": "eip7702"
    };
    toRpcType2 = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2",
      eip4844: "0x3",
      eip7702: "0x4"
    };
    __name2(fromRpc8, "fromRpc");
    fromRpc8.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(toRpc12, "toRpc");
    toRpc12.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function toRpc13(request) {
  const request_rpc = {};
  if (typeof request.accessList !== "undefined")
    request_rpc.accessList = request.accessList;
  if (typeof request.authorizationList !== "undefined")
    request_rpc.authorizationList = toRpcList(request.authorizationList);
  if (typeof request.blobVersionedHashes !== "undefined")
    request_rpc.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined")
    request_rpc.blobs = request.blobs;
  if (typeof request.chainId !== "undefined")
    request_rpc.chainId = fromNumber(request.chainId);
  if (typeof request.data !== "undefined") {
    request_rpc.data = request.data;
    request_rpc.input = request.data;
  } else if (typeof request.input !== "undefined") {
    request_rpc.data = request.input;
    request_rpc.input = request.input;
  }
  if (typeof request.from !== "undefined")
    request_rpc.from = request.from;
  if (typeof request.gas !== "undefined")
    request_rpc.gas = fromNumber(request.gas);
  if (typeof request.gasPrice !== "undefined")
    request_rpc.gasPrice = fromNumber(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    request_rpc.maxFeePerBlobGas = fromNumber(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    request_rpc.maxFeePerGas = fromNumber(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber(request.maxPriorityFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    request_rpc.nonce = fromNumber(request.nonce);
  if (typeof request.to !== "undefined")
    request_rpc.to = request.to;
  if (typeof request.type !== "undefined")
    request_rpc.type = request.type;
  if (typeof request.value !== "undefined")
    request_rpc.value = fromNumber(request.value);
  return request_rpc;
}
__name(toRpc13, "toRpc13");
var init_TransactionRequest = __esm({
  "../node_modules/ox/_esm/core/TransactionRequest.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Authorization();
    init_Hex();
    __name2(toRpc13, "toRpc");
    toRpc13.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
function assert11(value) {
  const { domain, message, primaryType, types } = value;
  const validateData = /* @__PURE__ */ __name2((struct, data) => {
    for (const param of struct) {
      const { name, type: type6 } = param;
      const value2 = data[name];
      const integerMatch = type6.match(integerRegex2);
      if (integerMatch && (typeof value2 === "number" || typeof value2 === "bigint")) {
        const [, base, size_] = integerMatch;
        fromNumber(value2, {
          signed: base === "int",
          size: Number.parseInt(size_ ?? "") / 8
        });
      }
      if (type6 === "address" && typeof value2 === "string" && !validate4(value2))
        throw new InvalidAddressError({
          address: value2,
          cause: new InvalidInputError()
        });
      const bytesMatch = type6.match(bytesRegex2);
      if (bytesMatch) {
        const [, size3] = bytesMatch;
        if (size3 && size2(value2) !== Number.parseInt(size3))
          throw new BytesSizeMismatchError2({
            expectedSize: Number.parseInt(size3),
            givenSize: size2(value2)
          });
      }
      const struct2 = types[type6];
      if (struct2) {
        validateReference(type6);
        validateData(struct2, value2);
      }
    }
  }, "validateData");
  if (types.EIP712Domain && domain)
    validateData(types.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain") {
    if (types[primaryType])
      validateData(types[primaryType], message);
    else
      throw new InvalidPrimaryTypeError({ primaryType, types });
  }
}
__name(assert11, "assert11");
function domainSeparator(domain) {
  return hashDomain({
    domain
  });
}
__name(domainSeparator, "domainSeparator");
function encode7(value) {
  const { domain = {}, message, primaryType } = value;
  const types = {
    EIP712Domain: extractEip712DomainTypes(domain),
    ...value.types
  };
  assert11({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x19", "0x01"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  return concat(...parts);
}
__name(encode7, "encode7");
function encodeType(value) {
  const { primaryType, types } = value;
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type6 of deps) {
    result += `${type6}(${(types[type6] ?? []).map(({ name, type: t2 }) => `${t2} ${name}`).join(",")})`;
  }
  return result;
}
__name(encodeType, "encodeType");
function extractEip712DomainTypes(domain) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    typeof domain?.chainId === "number" && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
__name(extractEip712DomainTypes, "extractEip712DomainTypes");
function getSignPayload8(value) {
  return keccak256(encode7(value));
}
__name(getSignPayload8, "getSignPayload8");
function hashDomain(value) {
  const { domain, types } = value;
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types: {
      ...types,
      EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain)
    }
  });
}
__name(hashDomain, "hashDomain");
function hashStruct(value) {
  const { data, primaryType, types } = value;
  const encoded = encodeData2({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
__name(hashStruct, "hashStruct");
function serialize6(value) {
  const { domain: domain_, message: message_, primaryType, types } = value;
  const normalizeData = /* @__PURE__ */ __name2((struct, value2) => {
    const data = { ...value2 };
    for (const param of struct) {
      const { name, type: type6 } = param;
      if (type6 === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  }, "normalizeData");
  const domain = (() => {
    if (!types.EIP712Domain)
      return {};
    if (!domain_)
      return {};
    return normalizeData(types.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return void 0;
    if (!types[primaryType])
      return {};
    return normalizeData(types[primaryType], message_);
  })();
  return stringify({ domain, message, primaryType, types }, (_, value2) => {
    if (typeof value2 === "bigint")
      return value2.toString();
    return value2;
  });
}
__name(serialize6, "serialize6");
function validate12(value) {
  try {
    assert11(value);
    return true;
  } catch {
    return false;
  }
}
__name(validate12, "validate12");
function encodeData2(value) {
  const { data, primaryType, types } = value;
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType] ?? []) {
    const [type6, value2] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type6);
    encodedValues.push(value2);
  }
  return encode2(encodedTypes, encodedValues);
}
__name(encodeData2, "encodeData2");
function hashType(value) {
  const { primaryType, types } = value;
  const encodedHashType = fromString(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
}
__name(hashType, "hashType");
function encodeField(properties) {
  let { types, name, type: type6, value } = properties;
  if (types[type6] !== void 0)
    return [
      { type: "bytes32" },
      keccak256(encodeData2({ data: value, primaryType: type6, types }))
    ];
  if (type6 === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value, { as: "Hex" })];
  }
  if (type6 === "string")
    return [
      { type: "bytes32" },
      keccak256(fromString2(value), { as: "Hex" })
    ];
  if (type6.lastIndexOf("]") === type6.length - 1) {
    const parsedType = type6.slice(0, type6.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encode2(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v2]) => v2)))
    ];
  }
  return [{ type: type6 }, value];
}
__name(encodeField, "encodeField");
function findTypeDependencies(value, results = /* @__PURE__ */ new Set()) {
  const { primaryType: primaryType_, types } = value;
  const match2 = primaryType_.match(/^\w*/u);
  const primaryType = match2?.[0];
  if (results.has(primaryType) || types[primaryType] === void 0)
    return results;
  results.add(primaryType);
  for (const field of types[primaryType])
    findTypeDependencies({ primaryType: field.type, types }, results);
  return results;
}
__name(findTypeDependencies, "findTypeDependencies");
function validateReference(type6) {
  if (type6 === "address" || type6 === "bool" || type6 === "string" || type6.startsWith("bytes") || type6.startsWith("uint") || type6.startsWith("int"))
    throw new InvalidStructTypeError({ type: type6 });
}
__name(validateReference, "validateReference");
var BytesSizeMismatchError2;
var InvalidPrimaryTypeError;
var InvalidStructTypeError;
var init_TypedData = __esm({
  "../node_modules/ox/_esm/core/TypedData.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_AbiParameters();
    init_Address();
    init_Bytes();
    init_Errors();
    init_Hash();
    init_Hex();
    init_Json();
    init_Solidity();
    __name2(assert11, "assert");
    assert11.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(domainSeparator, "domainSeparator");
    domainSeparator.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(encode7, "encode");
    encode7.parseError = (error) => error;
    __name2(encodeType, "encodeType");
    encodeType.parseError = (error) => error;
    __name2(extractEip712DomainTypes, "extractEip712DomainTypes");
    extractEip712DomainTypes.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getSignPayload8, "getSignPayload");
    getSignPayload8.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(hashDomain, "hashDomain");
    hashDomain.parseError = (error) => error;
    __name2(hashStruct, "hashStruct");
    hashStruct.parseError = (error) => error;
    __name2(serialize6, "serialize");
    serialize6.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(validate12, "validate");
    validate12.parseError = (error) => error;
    BytesSizeMismatchError2 = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ expectedSize, givenSize }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TypedData.BytesSizeMismatchError"
        });
      }
    }, "BytesSizeMismatchError2");
    __name2(BytesSizeMismatchError2, "BytesSizeMismatchError");
    InvalidPrimaryTypeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ primaryType, types }) {
        super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
          metaMessages: ["Check that the primary type is a key in `types`."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TypedData.InvalidPrimaryTypeError"
        });
      }
    }, "InvalidPrimaryTypeError");
    __name2(InvalidPrimaryTypeError, "InvalidPrimaryTypeError");
    InvalidStructTypeError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ type: type6 }) {
        super(`Struct type "${type6}" is invalid.`, {
          metaMessages: ["Struct type must not be a Solidity type."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TypedData.InvalidStructTypeError"
        });
      }
    }, "InvalidStructTypeError");
    __name2(InvalidStructTypeError, "InvalidStructTypeError");
    __name2(encodeData2, "encodeData");
    __name2(hashType, "hashType");
    __name2(encodeField, "encodeField");
    __name2(findTypeDependencies, "findTypeDependencies");
    __name2(validateReference, "validateReference");
  }
});
function encode8(value) {
  const { data, validator } = value;
  return concat(
    // Validator Data Format: `0x19  0x00  <intended validator address>  <data to sign>`
    "0x19",
    "0x00",
    validator,
    from2(data)
  );
}
__name(encode8, "encode8");
function getSignPayload9(value) {
  return keccak256(encode8(value));
}
__name(getSignPayload9, "getSignPayload9");
var init_ValidatorData = __esm({
  "../node_modules/ox/_esm/core/ValidatorData.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Hash();
    init_Hex();
    __name2(encode8, "encode");
    encode8.parseError = (error) => error;
    __name2(getSignPayload9, "getSignPayload");
    getSignPayload9.parseError = (error) => error;
  }
});
function parseAsn1Signature(bytes) {
  const r_start = bytes[4] === 0 ? 5 : 4;
  const r_end = r_start + 32;
  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;
  const r3 = BigInt(fromBytes(bytes.slice(r_start, r_end)));
  const s2 = BigInt(fromBytes(bytes.slice(s_start)));
  return {
    r: r3,
    s: s2 > p2562.CURVE.n / 2n ? p2562.CURVE.n - s2 : s2
  };
}
__name(parseAsn1Signature, "parseAsn1Signature");
async function parseCredentialPublicKey(response) {
  const publicKeyBuffer = response.getPublicKey();
  if (!publicKeyBuffer)
    throw new CredentialCreationFailedError();
  try {
    const publicKeyBytes = new Uint8Array(publicKeyBuffer);
    const cryptoKey = await crypto.subtle.importKey("spki", new Uint8Array(publicKeyBytes), {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: "SHA-256"
    }, true, ["verify"]);
    const publicKey = new Uint8Array(await crypto.subtle.exportKey("raw", cryptoKey));
    return from4(publicKey);
  } catch (error) {
    if (error.message !== "Permission denied to access object")
      throw error;
    const data = new Uint8Array(response.attestationObject);
    const coordinateLength = 32;
    const cborPrefix = 88;
    const findStart = /* @__PURE__ */ __name2((key) => {
      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);
      for (let i2 = 0; i2 < data.length - coordinate.length; i2++)
        if (coordinate.every((byte, j2) => data[i2 + j2] === byte))
          return i2 + coordinate.length;
      throw new CredentialCreationFailedError();
    }, "findStart");
    const xStart = findStart(33);
    const yStart = findStart(34);
    return from4(new Uint8Array([
      4,
      ...data.slice(xStart, xStart + coordinateLength),
      ...data.slice(yStart, yStart + coordinateLength)
    ]));
  }
}
__name(parseCredentialPublicKey, "parseCredentialPublicKey");
var init_webauthn = __esm({
  "../node_modules/ox/_esm/core/internal/webauthn.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_p256();
    init_Hex();
    init_PublicKey();
    init_WebAuthnP256();
    __name2(parseAsn1Signature, "parseAsn1Signature");
    __name2(parseCredentialPublicKey, "parseCredentialPublicKey");
  }
});
async function createCredential(options2) {
  const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options2;
  const creationOptions = getCredentialCreationOptions(rest);
  try {
    const credential = await createFn(creationOptions);
    if (!credential)
      throw new CredentialCreationFailedError();
    const response = credential.response;
    const publicKey = await parseCredentialPublicKey(response);
    return {
      id: credential.id,
      publicKey,
      raw: credential
    };
  } catch (error) {
    throw new CredentialCreationFailedError({
      cause: error
    });
  }
}
__name(createCredential, "createCredential");
function getAuthenticatorData(options2 = {}) {
  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options2;
  const rpIdHash = sha2563(fromString(rpId));
  const flag_bytes = fromNumber(flag, { size: 1 });
  const signCount_bytes = fromNumber(signCount, { size: 4 });
  return concat(rpIdHash, flag_bytes, signCount_bytes);
}
__name(getAuthenticatorData, "getAuthenticatorData");
function getClientDataJSON(options2) {
  const { challenge, crossOrigin = false, extraClientData, origin = window.location.origin } = options2;
  return JSON.stringify({
    type: "webauthn.get",
    challenge: fromHex6(challenge, { url: true, pad: false }),
    origin,
    crossOrigin,
    ...extraClientData
  });
}
__name(getClientDataJSON, "getClientDataJSON");
function getCredentialCreationOptions(options2) {
  const { attestation = "none", authenticatorSelection = {
    residentKey: "preferred",
    requireResidentKey: false,
    userVerification: "required"
  }, challenge = createChallenge, excludeCredentialIds, name: name_, rp = {
    id: window.location.hostname,
    name: window.document.title
  }, user, extensions } = options2;
  const name = user?.name ?? name_;
  return {
    publicKey: {
      attestation,
      authenticatorSelection,
      challenge,
      ...excludeCredentialIds ? {
        excludeCredentials: excludeCredentialIds?.map((id3) => ({
          id: toBytes7(id3),
          type: "public-key"
        }))
      } : {},
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7
          // p256
        }
      ],
      rp,
      user: {
        id: user?.id ?? keccak256(fromString2(name), { as: "Bytes" }),
        name,
        displayName: user?.displayName ?? name
      },
      extensions
    }
  };
}
__name(getCredentialCreationOptions, "getCredentialCreationOptions");
function getCredentialRequestOptions(options2) {
  const { credentialId, challenge, rpId = window.location.hostname, userVerification = "required" } = options2;
  return {
    publicKey: {
      ...credentialId ? {
        allowCredentials: [
          {
            id: toBytes7(credentialId),
            type: "public-key"
          }
        ]
      } : {},
      challenge: fromHex(challenge),
      rpId,
      userVerification
    }
  };
}
__name(getCredentialRequestOptions, "getCredentialRequestOptions");
function getSignPayload10(options2) {
  const { challenge, crossOrigin, extraClientData, flag, origin, rpId, signCount, userVerification = "required" } = options2;
  const authenticatorData = getAuthenticatorData({
    flag,
    rpId,
    signCount
  });
  const clientDataJSON = getClientDataJSON({
    challenge,
    crossOrigin,
    extraClientData,
    origin
  });
  const clientDataJSONHash = sha2563(fromString(clientDataJSON));
  const challengeIndex = clientDataJSON.indexOf('"challenge"');
  const typeIndex = clientDataJSON.indexOf('"type"');
  const metadata = {
    authenticatorData,
    clientDataJSON,
    challengeIndex,
    typeIndex,
    userVerificationRequired: userVerification === "required"
  };
  const payload = concat(authenticatorData, clientDataJSONHash);
  return { metadata, payload };
}
__name(getSignPayload10, "getSignPayload10");
async function sign4(options2) {
  const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options2;
  const requestOptions = getCredentialRequestOptions(rest);
  try {
    const credential = await getFn(requestOptions);
    if (!credential)
      throw new CredentialRequestFailedError();
    const response = credential.response;
    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));
    const challengeIndex = clientDataJSON.indexOf('"challenge"');
    const typeIndex = clientDataJSON.indexOf('"type"');
    const signature = parseAsn1Signature(new Uint8Array(response.signature));
    return {
      metadata: {
        authenticatorData: fromBytes(new Uint8Array(response.authenticatorData)),
        clientDataJSON,
        challengeIndex,
        typeIndex,
        userVerificationRequired: requestOptions.publicKey.userVerification === "required"
      },
      signature,
      raw: credential
    };
  } catch (error) {
    throw new CredentialRequestFailedError({
      cause: error
    });
  }
}
__name(sign4, "sign4");
function verify4(options2) {
  const { challenge, hash: hash7 = true, metadata, publicKey, signature } = options2;
  const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;
  const authenticatorDataBytes = fromHex(authenticatorData);
  if (authenticatorDataBytes.length < 37)
    return false;
  const flag = authenticatorDataBytes[32];
  if ((flag & 1) !== 1)
    return false;
  if (userVerificationRequired && (flag & 4) !== 4)
    return false;
  if ((flag & 8) !== 8 && (flag & 16) === 16)
    return false;
  const type6 = '"type":"webauthn.get"';
  if (type6 !== clientDataJSON.slice(Number(typeIndex), type6.length + 1))
    return false;
  const match2 = clientDataJSON.slice(Number(challengeIndex)).match(/^"challenge":"(.*?)"/);
  if (!match2)
    return false;
  const [_, challenge_extracted] = match2;
  if (fromBytes(toBytes7(challenge_extracted)) !== challenge)
    return false;
  const clientDataJSONHash = sha2563(fromString2(clientDataJSON), {
    as: "Bytes"
  });
  const payload = concat2(authenticatorDataBytes, clientDataJSONHash);
  return verify3({
    hash: hash7,
    payload,
    publicKey,
    signature
  });
}
__name(verify4, "verify4");
var createChallenge;
var CredentialCreationFailedError;
var CredentialRequestFailedError;
var init_WebAuthnP256 = __esm({
  "../node_modules/ox/_esm/core/WebAuthnP256.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Base64();
    init_Bytes();
    init_Errors();
    init_Hash();
    init_Hex();
    init_P256();
    init_webauthn();
    createChallenge = Uint8Array.from([
      105,
      171,
      180,
      181,
      160,
      222,
      75,
      198,
      42,
      42,
      32,
      31,
      141,
      37,
      186,
      233
    ]);
    __name2(createCredential, "createCredential");
    createCredential.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getAuthenticatorData, "getAuthenticatorData");
    getAuthenticatorData.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getClientDataJSON, "getClientDataJSON");
    getClientDataJSON.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getCredentialCreationOptions, "getCredentialCreationOptions");
    getCredentialCreationOptions.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(getCredentialRequestOptions, "getCredentialRequestOptions");
    getCredentialRequestOptions.parseError = (error) => error;
    __name2(getSignPayload10, "getSignPayload");
    getSignPayload10.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(sign4, "sign");
    sign4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(verify4, "verify");
    verify4.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    CredentialCreationFailedError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ cause } = {}) {
        super("Failed to create credential.", {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WebAuthnP256.CredentialCreationFailedError"
        });
      }
    }, "CredentialCreationFailedError");
    __name2(CredentialCreationFailedError, "CredentialCreationFailedError");
    CredentialRequestFailedError = /* @__PURE__ */ __name(class extends BaseError2 {
      constructor({ cause } = {}) {
        super("Failed to request credential.", {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WebAuthnP256.CredentialRequestFailedError"
        });
      }
    }, "CredentialRequestFailedError");
    __name2(CredentialRequestFailedError, "CredentialRequestFailedError");
  }
});
async function createKeyPair(options2 = {}) {
  const { extractable = false } = options2;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, extractable, ["sign", "verify"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from4(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
__name(createKeyPair, "createKeyPair");
async function sign5(options2) {
  const { payload, privateKey } = options2;
  const signature = await globalThis.crypto.subtle.sign({
    name: "ECDSA",
    hash: "SHA-256"
  }, privateKey, from3(payload));
  const signature_bytes = fromArray(new Uint8Array(signature));
  const r3 = toBigInt2(slice2(signature_bytes, 0, 32));
  let s2 = toBigInt2(slice2(signature_bytes, 32, 64));
  if (s2 > p2562.CURVE.n / 2n)
    s2 = p2562.CURVE.n - s2;
  return { r: r3, s: s2 };
}
__name(sign5, "sign5");
async function verify5(options2) {
  const { payload, signature } = options2;
  const publicKey = await globalThis.crypto.subtle.importKey("raw", toBytes3(options2.publicKey), { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
  return await globalThis.crypto.subtle.verify({
    name: "ECDSA",
    hash: "SHA-256"
  }, publicKey, concat2(fromNumber2(signature.r), fromNumber2(signature.s)), from3(payload));
}
__name(verify5, "verify5");
var init_WebCryptoP256 = __esm({
  "../node_modules/ox/_esm/core/WebCryptoP256.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_p256();
    init_Bytes();
    init_PublicKey();
    __name2(createKeyPair, "createKeyPair");
    createKeyPair.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(sign5, "sign");
    sign5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
    __name2(verify5, "verify");
    verify5.parseError = (error) => (
      /* v8 ignore next */
      error
    );
  }
});
var init_esm4 = __esm({
  "../node_modules/ox/_esm/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Abi();
    init_AbiConstructor();
    init_AbiError();
    init_AbiEvent();
    init_AbiFunction();
    init_AbiItem();
    init_AbiParameters();
    init_AccessList();
    init_AccountProof();
    init_Address();
    init_AesGcm();
    init_Authorization();
    init_Base58();
    init_Base64();
    init_Blobs();
    init_Block();
    init_Bloom();
    init_Bls();
    init_BlsPoint();
    init_Bytes();
    init_Caches();
    init_ContractAddress();
    init_Ens();
    init_Errors();
    init_Filter();
    init_Hash();
    init_HdKey();
    init_Hex();
    init_Fee();
    init_Json();
    init_Kzg();
    init_Log();
    init_Mnemonic();
    init_PersonalMessage();
    init_Provider();
    init_PublicKey();
    init_Rlp();
    init_RpcSchema();
    init_RpcRequest();
    init_RpcResponse();
    init_RpcTransport();
    init_Secp256k1();
    init_P256();
    init_Signature();
    init_Siwe();
    init_Solidity();
    init_Transaction();
    init_TransactionEnvelope();
    init_TransactionEnvelopeLegacy();
    init_TransactionEnvelopeEip1559();
    init_TransactionEnvelopeEip2930();
    init_TransactionEnvelopeEip4844();
    init_TransactionEnvelopeEip7702();
    init_TransactionReceipt();
    init_TransactionRequest();
    init_TypedData();
    init_ValidatorData();
    init_Value();
    init_WebAuthnP256();
    init_WebCryptoP256();
    init_Withdrawal();
  }
});
function hashToField(input) {
  if (Bytes_exports.validate(input) || Hex_exports.validate(input))
    return hashEncodedBytes(input);
  return hashString(input);
}
__name(hashToField, "hashToField");
function packAndEncode(input) {
  const [types, values] = input.reduce(
    ([types2, values2], [type6, value]) => {
      types2.push(type6);
      values2.push(value);
      return [types2, values2];
    },
    [[], []]
  );
  return hashEncodedBytes(AbiParameters_exports.encodePacked(types, values));
}
__name(packAndEncode, "packAndEncode");
function hashString(input) {
  const bytesInput = import_buffer.Buffer.from(input);
  return hashEncodedBytes(bytesInput);
}
__name(hashString, "hashString");
function hashEncodedBytes(input) {
  const hash7 = BigInt(Hash_exports.keccak256(input, { as: "Hex" })) >> 8n;
  const rawDigest = hash7.toString(16);
  return { hash: hash7, digest: `0x${rawDigest.padStart(64, "0")}` };
}
__name(hashEncodedBytes, "hashEncodedBytes");
var import_buffer;
var generateSignal;
var encodeAction;
var init_chunk_HZ2SQA5V = __esm({
  "../node_modules/@worldcoin/idkit-core/build/chunk-HZ2SQA5V.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_buffer = __toESM(require_buffer(), 1);
    init_esm4();
    __name2(hashToField, "hashToField");
    __name2(packAndEncode, "packAndEncode");
    __name2(hashString, "hashString");
    __name2(hashEncodedBytes, "hashEncodedBytes");
    generateSignal = /* @__PURE__ */ __name2((signal) => {
      if (!signal || typeof signal === "string")
        return hashToField(signal ?? "");
      return packAndEncode(signal.types.map((type6, index) => [type6, signal.values[index]]));
    }, "generateSignal");
    encodeAction = /* @__PURE__ */ __name2((action) => {
      if (!action)
        return "";
      if (typeof action === "string")
        return action;
      return action.types.map((type6, index) => `${type6}(${action.values[index]})`).join(",");
    }, "encodeAction");
  }
});
function useStore(api, selector = identity2, equalityFn) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice3 = useSyncExternalStoreWithSelector2(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue2(slice3);
  return slice3;
}
__name(useStore, "useStore");
var import_react2;
var import_with_selector2;
var useDebugValue2;
var useSyncExternalStoreWithSelector2;
var didWarnAboutEqualityFn;
var identity2;
var createImpl;
var create3;
var init_esm5 = __esm({
  "../node_modules/zustand/esm/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_vanilla();
    init_vanilla();
    import_react2 = __toESM(require_react(), 1);
    import_with_selector2 = __toESM(require_with_selector(), 1);
    ({ useDebugValue: useDebugValue2 } = import_react2.default);
    ({ useSyncExternalStoreWithSelector: useSyncExternalStoreWithSelector2 } = import_with_selector2.default);
    didWarnAboutEqualityFn = false;
    identity2 = /* @__PURE__ */ __name2((arg) => arg, "identity");
    __name2(useStore, "useStore");
    createImpl = /* @__PURE__ */ __name2((createState2) => {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && typeof createState2 !== "function") {
        console.warn(
          "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
        );
      }
      const api = typeof createState2 === "function" ? createStore(createState2) : createState2;
      const useBoundStore = /* @__PURE__ */ __name2((selector, equalityFn) => useStore(api, selector, equalityFn), "useBoundStore");
      Object.assign(useBoundStore, api);
      return useBoundStore;
    }, "createImpl");
    create3 = /* @__PURE__ */ __name2((createState2) => createState2 ? createImpl(createState2) : createImpl, "create");
  }
});
var isBrowser;
var isNode;
var isWebWorker;
var isJsDom;
var isDeno;
var init_dist2 = __esm({
  "../node_modules/browser-or-node/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    isNode = // @ts-expect-error
    typeof process !== "undefined" && // @ts-expect-error
    process.versions != null && // @ts-expect-error
    process.versions.node != null;
    isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
    isJsDom = typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && "userAgent" in navigator && true && ("Cloudflare-Workers".includes("Node.js") || "Cloudflare-Workers".includes("jsdom"));
    isDeno = // @ts-expect-error
    typeof Deno !== "undefined" && // @ts-expect-error
    typeof Deno.version !== "undefined" && // @ts-expect-error
    typeof Deno.version.deno !== "undefined";
  }
});
function validate_bridge_url(bridge_url, is_staging) {
  try {
    new URL(bridge_url);
  } catch (e2) {
    return { valid: false, errors: ["Failed to parse Bridge URL."] };
  }
  const test_url = new URL(bridge_url);
  const errors = [];
  if (is_staging && ["localhost", "127.0.0.1"].includes(test_url.hostname)) {
    console.log("Using staging app_id with localhost bridge_url. Skipping validation.");
    return { valid: true };
  }
  if (test_url.protocol !== "https:") {
    errors.push("Bridge URL must use HTTPS.");
  }
  if (test_url.port) {
    errors.push("Bridge URL must use the default port (443).");
  }
  if (test_url.pathname !== "/") {
    errors.push("Bridge URL must not have a path.");
  }
  if (test_url.search) {
    errors.push("Bridge URL must not have query parameters.");
  }
  if (test_url.hash) {
    errors.push("Bridge URL must not have a fragment.");
  }
  if (!test_url.hostname.endsWith(".worldcoin.org") && !test_url.hostname.endsWith(".toolsforhumanity.com")) {
    console.warn(
      "Bridge URL should be a subdomain of worldcoin.org or toolsforhumanity.com. The user's identity wallet may refuse to connect. This is a temporary measure and may be removed in the future."
    );
  }
  if (errors.length) {
    return { valid: false, errors };
  }
  return { valid: true };
}
__name(validate_bridge_url, "validate_bridge_url");
var import_buffer2;
var AppErrorCodes;
var VerificationState;
var VerificationLevel;
var isReactNative;
var isWeb;
var getGlobalObject;
var getCrypto;
var DEFAULT_VERIFICATION_LEVEL;
var buffer_encode;
var buffer_decode;
var verification_level_to_credential_types;
var credential_type_to_verification_level;
var WebCryptoAdapter;
var ReactNativeCryptoAdapter;
var cryptoAdapterInstance;
var getCryptoAdapter;
var generateKey;
var exportKey;
var encryptRequest;
var decryptResponse;
var DEFAULT_BRIDGE_URL;
var createStoreImplementation;
var useWorldBridgeStore;
var init_build = __esm({
  "../node_modules/@worldcoin/idkit-core/build/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_chunk_HZ2SQA5V();
    init_esm5();
    init_dist2();
    import_buffer2 = __toESM(require_buffer(), 1);
    AppErrorCodes = /* @__PURE__ */ ((AppErrorCodes2) => {
      AppErrorCodes2["ConnectionFailed"] = "connection_failed";
      AppErrorCodes2["VerificationRejected"] = "verification_rejected";
      AppErrorCodes2["MaxVerificationsReached"] = "max_verifications_reached";
      AppErrorCodes2["CredentialUnavailable"] = "credential_unavailable";
      AppErrorCodes2["MalformedRequest"] = "malformed_request";
      AppErrorCodes2["InvalidNetwork"] = "invalid_network";
      AppErrorCodes2["InclusionProofFailed"] = "inclusion_proof_failed";
      AppErrorCodes2["InclusionProofPending"] = "inclusion_proof_pending";
      AppErrorCodes2["UnexpectedResponse"] = "unexpected_response";
      AppErrorCodes2["FailedByHostApp"] = "failed_by_host_app";
      AppErrorCodes2["GenericError"] = "generic_error";
      return AppErrorCodes2;
    })(AppErrorCodes || {});
    VerificationState = /* @__PURE__ */ ((VerificationState2) => {
      VerificationState2["PreparingClient"] = "loading_widget";
      VerificationState2["WaitingForConnection"] = "awaiting_connection";
      VerificationState2["WaitingForApp"] = "awaiting_app";
      VerificationState2["Confirmed"] = "confirmed";
      VerificationState2["Failed"] = "failed";
      return VerificationState2;
    })(VerificationState || {});
    VerificationLevel = /* @__PURE__ */ ((VerificationLevel2) => {
      VerificationLevel2["Orb"] = "orb";
      VerificationLevel2["SecureDocument"] = "secure_document";
      VerificationLevel2["Document"] = "document";
      VerificationLevel2["Device"] = "device";
      return VerificationLevel2;
    })(VerificationLevel || {});
    __name2(validate_bridge_url, "validate_bridge_url");
    isReactNative = /* @__PURE__ */ __name2(() => {
      return typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }, "isReactNative");
    isWeb = /* @__PURE__ */ __name2(() => {
      return isBrowser;
    }, "isWeb");
    getGlobalObject = /* @__PURE__ */ __name2(() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      throw new Error("Unable to locate global object");
    }, "getGlobalObject");
    getCrypto = /* @__PURE__ */ __name2(() => {
      const globalObj = getGlobalObject();
      if (typeof globalObj.crypto !== "undefined") {
        return globalObj.crypto;
      }
      throw new Error("Crypto API not available. For React Native, ensure polyfills are set up properly.");
    }, "getCrypto");
    DEFAULT_VERIFICATION_LEVEL = "orb";
    buffer_encode = /* @__PURE__ */ __name2((buffer) => {
      return import_buffer2.Buffer.from(buffer).toString("base64");
    }, "buffer_encode");
    buffer_decode = /* @__PURE__ */ __name2((encoded) => {
      return import_buffer2.Buffer.from(encoded, "base64");
    }, "buffer_decode");
    verification_level_to_credential_types = /* @__PURE__ */ __name2((verification_level) => {
      switch (verification_level) {
        case "device":
          return [
            "orb",
            "device"
            /* Device */
          ];
        case "document":
          return [
            "document",
            "orb"
            /* Orb */
          ];
        case "secure_document":
          return [
            "secure_document",
            "orb"
            /* Orb */
          ];
        case "orb":
          return [
            "orb"
            /* Orb */
          ];
        default:
          throw new Error(`Unknown verification level: ${verification_level}`);
      }
    }, "verification_level_to_credential_types");
    credential_type_to_verification_level = /* @__PURE__ */ __name2((credential_type) => {
      switch (credential_type) {
        case "orb":
          return "orb";
        case "secure_document":
          return "secure_document";
        case "document":
          return "document";
        case "device":
          return "device";
        default:
          throw new Error(`Unknown credential_type: ${credential_type}`);
      }
    }, "credential_type_to_verification_level");
    WebCryptoAdapter = /* @__PURE__ */ __name2(class {
      constructor() {
        this.encoder = new TextEncoder();
        this.decoder = new TextDecoder();
      }
      async generateKey() {
        return {
          iv: window.crypto.getRandomValues(new Uint8Array(12)),
          key: await window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"])
        };
      }
      async exportKey(key) {
        return buffer_encode(await window.crypto.subtle.exportKey("raw", key));
      }
      async encryptRequest(key, iv, request) {
        return {
          iv: buffer_encode(iv),
          payload: buffer_encode(
            await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, this.encoder.encode(request))
          )
        };
      }
      async decryptResponse(key, iv, payload) {
        return this.decoder.decode(
          await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, buffer_decode(payload))
        );
      }
    }, "WebCryptoAdapter");
    ReactNativeCryptoAdapter = /* @__PURE__ */ __name2(class {
      constructor() {
        this.encoder = new TextEncoder();
        this.decoder = new TextDecoder();
      }
      async generateKey() {
        const crypto3 = getCrypto();
        return {
          iv: crypto3.getRandomValues(new Uint8Array(12)),
          key: await crypto3.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"])
        };
      }
      async exportKey(key) {
        const crypto3 = getCrypto();
        return buffer_encode(await crypto3.subtle.exportKey("raw", key));
      }
      async encryptRequest(key, iv, request) {
        const crypto3 = getCrypto();
        return {
          iv: buffer_encode(iv),
          payload: buffer_encode(
            await crypto3.subtle.encrypt({ name: "AES-GCM", iv }, key, this.encoder.encode(request))
          )
        };
      }
      async decryptResponse(key, iv, payload) {
        const crypto3 = getCrypto();
        return this.decoder.decode(await crypto3.subtle.decrypt({ name: "AES-GCM", iv }, key, buffer_decode(payload)));
      }
    }, "ReactNativeCryptoAdapter");
    cryptoAdapterInstance = null;
    getCryptoAdapter = /* @__PURE__ */ __name2(() => {
      if (cryptoAdapterInstance) {
        return cryptoAdapterInstance;
      }
      if (isWeb()) {
        cryptoAdapterInstance = new WebCryptoAdapter();
        return cryptoAdapterInstance;
      }
      if (isReactNative()) {
        cryptoAdapterInstance = new ReactNativeCryptoAdapter();
        return cryptoAdapterInstance;
      }
      throw new Error("Unsupported platform");
    }, "getCryptoAdapter");
    generateKey = /* @__PURE__ */ __name2(async () => {
      return getCryptoAdapter().generateKey();
    }, "generateKey");
    exportKey = /* @__PURE__ */ __name2(async (key) => {
      return getCryptoAdapter().exportKey(key);
    }, "exportKey");
    encryptRequest = /* @__PURE__ */ __name2(async (key, iv, request) => {
      return getCryptoAdapter().encryptRequest(key, iv, request);
    }, "encryptRequest");
    decryptResponse = /* @__PURE__ */ __name2(async (key, iv, payload) => {
      return getCryptoAdapter().decryptResponse(key, iv, payload);
    }, "decryptResponse");
    DEFAULT_BRIDGE_URL = "https://bridge.worldcoin.org";
    createStoreImplementation = /* @__PURE__ */ __name2((set, get) => ({
      iv: null,
      key: null,
      result: null,
      errorCode: null,
      requestId: null,
      connectorURI: null,
      bridge_url: DEFAULT_BRIDGE_URL,
      verificationState: "loading_widget",
      createClient: async ({ bridge_url, app_id, verification_level, action_description, action, signal, partner }) => {
        const { key, iv } = await generateKey();
        if (bridge_url) {
          const validation = validate_bridge_url(bridge_url, app_id.includes("staging"));
          if (!validation.valid) {
            console.error(validation.errors.join("\n"));
            set({
              verificationState: "failed"
              /* Failed */
            });
            throw new Error("Invalid bridge_url. Please check the console for more details.");
          }
        }
        const res = await fetch(new URL("/request", bridge_url ?? DEFAULT_BRIDGE_URL), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(
            await encryptRequest(
              key,
              iv,
              JSON.stringify({
                app_id,
                action_description,
                action: encodeAction(action),
                signal: generateSignal(signal).digest,
                credential_types: verification_level_to_credential_types(
                  verification_level ?? DEFAULT_VERIFICATION_LEVEL
                ),
                verification_level: verification_level ?? DEFAULT_VERIFICATION_LEVEL
              })
            )
          )
        });
        if (!res.ok) {
          set({
            verificationState: "failed"
            /* Failed */
          });
          throw new Error("Failed to create client");
        }
        const { request_id } = await res.json();
        set({
          iv,
          key,
          requestId: request_id,
          bridge_url: bridge_url ?? DEFAULT_BRIDGE_URL,
          verificationState: "awaiting_connection",
          connectorURI: `https://world.org/verify?t=wld&i=${request_id}&k=${encodeURIComponent(
            await exportKey(key)
          )}${bridge_url && bridge_url !== DEFAULT_BRIDGE_URL ? `&b=${encodeURIComponent(bridge_url)}` : ""}${partner ? `&partner=${encodeURIComponent(true)}` : ""}`
        });
      },
      pollForUpdates: async () => {
        const key = get().key;
        if (!key)
          throw new Error("No keypair found. Please call `createClient` first.");
        const res = await fetch(new URL(`/response/${get().requestId}`, get().bridge_url));
        if (!res.ok) {
          return set({
            errorCode: "connection_failed",
            verificationState: "failed"
            /* Failed */
          });
        }
        const { response, status } = await res.json();
        if (status != "completed") {
          return set({
            verificationState: status == "retrieved" ? "awaiting_app" : "awaiting_connection"
            /* WaitingForConnection */
          });
        }
        let result = JSON.parse(
          await decryptResponse(key, buffer_decode(response.iv), response.payload)
        );
        if ("error_code" in result) {
          return set({
            errorCode: result.error_code,
            verificationState: "failed"
            /* Failed */
          });
        }
        if ("credential_type" in result) {
          result = {
            verification_level: credential_type_to_verification_level(result.credential_type),
            ...result
          };
        }
        set({
          result,
          key: null,
          requestId: null,
          connectorURI: null,
          verificationState: "confirmed"
          /* Confirmed */
        });
      },
      reset: () => {
        set({
          iv: null,
          key: null,
          result: null,
          errorCode: null,
          requestId: null,
          connectorURI: null,
          verificationState: "loading_widget"
          /* PreparingClient */
        });
      }
    }), "createStoreImplementation");
    useWorldBridgeStore = create3(createStoreImplementation);
  }
});
var require_utils = __commonJS({
  "../node_modules/qrcode/lib/core/utils.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getSymbolSize(version3) {
      if (!version3)
        throw new Error('"version" cannot be null or undefined');
      if (version3 < 1 || version3 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version3 * 4 + 17;
    }, "getSymbolSize"), "getSymbolSize");
    exports.getSymbolTotalCodewords = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getSymbolTotalCodewords(version3) {
      return CODEWORDS_COUNT[version3];
    }, "getSymbolTotalCodewords"), "getSymbolTotalCodewords");
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function setToSJISFunction(f2) {
      if (typeof f2 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f2;
    }, "setToSJISFunction"), "setToSJISFunction");
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toSJIS(kanji) {
      return toSJISFunction(kanji);
    }, "toSJIS"), "toSJIS");
  }
});
var require_error_correction_level = __commonJS({
  "../node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString5(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    __name(fromString5, "fromString5");
    __name2(fromString5, "fromString");
    exports.isValid = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    }, "isValid"), "isValid");
    exports.from = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function from27(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString5(value);
      } catch (e2) {
        return defaultValue;
      }
    }, "from27"), "from");
  }
});
var require_bit_buffer = __commonJS({
  "../node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    __name(BitBuffer, "BitBuffer");
    __name2(BitBuffer, "BitBuffer");
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i2 = 0; i2 < length; i2++) {
          this.putBit((num >>> length - i2 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});
var require_bit_matrix = __commonJS({
  "../node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    function BitMatrix(size3) {
      if (!size3 || size3 < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size3;
      this.data = new Uint8Array(size3 * size3);
      this.reservedBit = new Uint8Array(size3 * size3);
    }
    __name(BitMatrix, "BitMatrix");
    __name2(BitMatrix, "BitMatrix");
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});
var require_alignment_pattern = __commonJS({
  "../node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getRowColCoords(version3) {
      if (version3 === 1)
        return [];
      const posCount = Math.floor(version3 / 7) + 2;
      const size3 = getSymbolSize(version3);
      const intervals = size3 === 145 ? 26 : Math.ceil((size3 - 13) / (2 * posCount - 2)) * 2;
      const positions = [size3 - 7];
      for (let i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    }, "getRowColCoords"), "getRowColCoords");
    exports.getPositions = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPositions(version3) {
      const coords = [];
      const pos = exports.getRowColCoords(version3);
      const posLength = pos.length;
      for (let i2 = 0; i2 < posLength; i2++) {
        for (let j2 = 0; j2 < posLength; j2++) {
          if (i2 === 0 && j2 === 0 || // top-left
          i2 === 0 && j2 === posLength - 1 || // bottom-left
          i2 === posLength - 1 && j2 === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j2]]);
        }
      }
      return coords;
    }, "getPositions"), "getPositions");
  }
});
var require_finder_pattern = __commonJS({
  "../node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPositions(version3) {
      const size3 = getSymbolSize(version3);
      return [
        // top-left
        [0, 0],
        // top-right
        [size3 - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size3 - FINDER_PATTERN_SIZE]
      ];
    }, "getPositions"), "getPositions");
  }
});
var require_mask_pattern = __commonJS({
  "../node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    }, "isValid"), "isValid");
    exports.from = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function from27(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    }, "from27"), "from");
    exports.getPenaltyN1 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPenaltyN1(data) {
      const size3 = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size3; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size3; col++) {
          let module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    }, "getPenaltyN1"), "getPenaltyN1");
    exports.getPenaltyN2 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPenaltyN2(data) {
      const size3 = data.size;
      let points = 0;
      for (let row = 0; row < size3 - 1; row++) {
        for (let col = 0; col < size3 - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    }, "getPenaltyN2"), "getPenaltyN2");
    exports.getPenaltyN3 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPenaltyN3(data) {
      const size3 = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size3; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size3; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    }, "getPenaltyN3"), "getPenaltyN3");
    exports.getPenaltyN4 = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i2 = 0; i2 < modulesCount; i2++)
        darkCount += data.data[i2];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    }, "getPenaltyN4"), "getPenaltyN4");
    function getMaskAt(maskPattern, i2, j2) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i2 + j2) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j2 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i2 + j2) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i2 * j2 % 2 + i2 * j2 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    __name(getMaskAt, "getMaskAt");
    __name2(getMaskAt, "getMaskAt");
    exports.applyMask = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function applyMask(pattern, data) {
      const size3 = data.size;
      for (let col = 0; col < size3; col++) {
        for (let row = 0; row < size3; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    }, "applyMask"), "applyMask");
    exports.getBestMask = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p2 = 0; p2 < numPatterns; p2++) {
        setupFormatFunc(p2);
        exports.applyMask(p2, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p2, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p2;
        }
      }
      return bestPattern;
    }, "getBestMask"), "getBestMask");
  }
});
var require_error_correction_code = __commonJS({
  "../node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBlocksCount(version3, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version3 - 1) * 4 + 3];
        default:
          return void 0;
      }
    }, "getBlocksCount"), "getBlocksCount");
    exports.getTotalCodewordsCount = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getTotalCodewordsCount(version3, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version3 - 1) * 4 + 3];
        default:
          return void 0;
      }
    }, "getTotalCodewordsCount"), "getTotalCodewordsCount");
  }
});
var require_galois_field = __commonJS({
  "../node_modules/qrcode/lib/core/galois-field.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function initTables() {
      let x2 = 1;
      for (let i2 = 0; i2 < 255; i2++) {
        EXP_TABLE[i2] = x2;
        LOG_TABLE[x2] = i2;
        x2 <<= 1;
        if (x2 & 256) {
          x2 ^= 285;
        }
      }
      for (let i2 = 255; i2 < 512; i2++) {
        EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
      }
    }, "initTables"), "initTables"))();
    exports.log = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function log(n2) {
      if (n2 < 1)
        throw new Error("log(" + n2 + ")");
      return LOG_TABLE[n2];
    }, "log"), "log");
    exports.exp = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function exp(n2) {
      return EXP_TABLE[n2];
    }, "exp"), "exp");
    exports.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul(x2, y2) {
      if (x2 === 0 || y2 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
    }, "mul"), "mul");
  }
});
var require_polynomial = __commonJS({
  "../node_modules/qrcode/lib/core/polynomial.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var GF = require_galois_field();
    exports.mul = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i2 = 0; i2 < p1.length; i2++) {
        for (let j2 = 0; j2 < p2.length; j2++) {
          coeff[i2 + j2] ^= GF.mul(p1[i2], p2[j2]);
        }
      }
      return coeff;
    }, "mul"), "mul");
    exports.mod = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function mod2(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    }, "mod2"), "mod");
    exports.generateECPolynomial = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i2 = 0; i2 < degree; i2++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
      }
      return poly;
    }, "generateECPolynomial"), "generateECPolynomial");
  }
});
var require_reed_solomon_encoder = __commonJS({
  "../node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    __name(ReedSolomonEncoder, "ReedSolomonEncoder");
    __name2(ReedSolomonEncoder, "ReedSolomonEncoder");
    ReedSolomonEncoder.prototype.initialize = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    }, "initialize"), "initialize");
    ReedSolomonEncoder.prototype.encode = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function encode9(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    }, "encode9"), "encode");
    module.exports = ReedSolomonEncoder;
  }
});
var require_version_check = __commonJS({
  "../node_modules/qrcode/lib/core/version-check.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    exports.isValid = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isValid(version3) {
      return !isNaN(version3) && version3 >= 1 && version3 <= 40;
    }, "isValid"), "isValid");
  }
});
var require_regex = __commonJS({
  "../node_modules/qrcode/lib/core/regex.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function testKanji(str) {
      return TEST_KANJI.test(str);
    }, "testKanji"), "testKanji");
    exports.testNumeric = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    }, "testNumeric"), "testNumeric");
    exports.testAlphanumeric = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    }, "testAlphanumeric"), "testAlphanumeric");
  }
});
var require_mode = __commonJS({
  "../node_modules/qrcode/lib/core/mode.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getCharCountIndicator(mode, version3) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version3)) {
        throw new Error("Invalid version: " + version3);
      }
      if (version3 >= 1 && version3 < 10)
        return mode.ccBits[0];
      else if (version3 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    }, "getCharCountIndicator"), "getCharCountIndicator");
    exports.getBestModeForData = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    }, "getBestModeForData"), "getBestModeForData");
    exports.toString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function toString5(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    }, "toString5"), "toString");
    exports.isValid = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    }, "isValid"), "isValid");
    function fromString5(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    __name(fromString5, "fromString5");
    __name2(fromString5, "fromString");
    exports.from = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function from27(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString5(value);
      } catch (e2) {
        return defaultValue;
      }
    }, "from27"), "from");
  }
});
var require_version = __commonJS({
  "../node_modules/qrcode/lib/core/version.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    __name(getBestVersionForDataLength, "getBestVersionForDataLength");
    __name2(getBestVersionForDataLength, "getBestVersionForDataLength");
    function getReservedBitsCount(mode, version3) {
      return Mode.getCharCountIndicator(mode, version3) + 4;
    }
    __name(getReservedBitsCount, "getReservedBitsCount");
    __name2(getReservedBitsCount, "getReservedBitsCount");
    function getTotalBitsFromDataArray(segments, version3) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version3);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    __name(getTotalBitsFromDataArray, "getTotalBitsFromDataArray");
    __name2(getTotalBitsFromDataArray, "getTotalBitsFromDataArray");
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    __name(getBestVersionForMixedData, "getBestVersionForMixedData");
    __name2(getBestVersionForMixedData, "getBestVersionForMixedData");
    exports.from = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function from27(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    }, "from27"), "from");
    exports.getCapacity = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getCapacity(version3, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version3)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version3);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version3);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    }, "getCapacity"), "getCapacity");
    exports.getBestVersionForData = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    }, "getBestVersionForData"), "getBestVersionForData");
    exports.getEncodedBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getEncodedBits(version3) {
      if (!VersionCheck.isValid(version3) || version3 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d2 = version3 << 12;
      while (Utils.getBCHDigit(d2) - G18_BCH >= 0) {
        d2 ^= G18 << Utils.getBCHDigit(d2) - G18_BCH;
      }
      return version3 << 12 | d2;
    }, "getEncodedBits"), "getEncodedBits");
  }
});
var require_format_info = __commonJS({
  "../node_modules/qrcode/lib/core/format-info.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d2 = data << 10;
      while (Utils.getBCHDigit(d2) - G15_BCH >= 0) {
        d2 ^= G15 << Utils.getBCHDigit(d2) - G15_BCH;
      }
      return (data << 10 | d2) ^ G15_MASK;
    }, "getEncodedBits"), "getEncodedBits");
  }
});
var require_numeric_data = __commonJS({
  "../node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    __name(NumericData, "NumericData");
    __name2(NumericData, "NumericData");
    NumericData.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    }, "getBitsLength"), "getBitsLength");
    NumericData.prototype.getLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength"), "getLength");
    NumericData.prototype.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    }, "getBitsLength"), "getBitsLength");
    NumericData.prototype.write = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function write(bitBuffer) {
      let i2, group, value;
      for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
        group = this.data.substr(i2, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i2;
      if (remainingNum > 0) {
        group = this.data.substr(i2);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    }, "write"), "write");
    module.exports = NumericData;
  }
});
var require_alphanumeric_data = __commonJS({
  "../node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    __name(AlphanumericData, "AlphanumericData");
    __name2(AlphanumericData, "AlphanumericData");
    AlphanumericData.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    }, "getBitsLength"), "getBitsLength");
    AlphanumericData.prototype.getLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength"), "getLength");
    AlphanumericData.prototype.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    }, "getBitsLength"), "getBitsLength");
    AlphanumericData.prototype.write = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function write(bitBuffer) {
      let i2;
      for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
      }
    }, "write"), "write");
    module.exports = AlphanumericData;
  }
});
var require_byte_data = __commonJS({
  "../node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        this.data = new TextEncoder().encode(data);
      } else {
        this.data = new Uint8Array(data);
      }
    }
    __name(ByteData, "ByteData");
    __name2(ByteData, "ByteData");
    ByteData.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength(length) {
      return length * 8;
    }, "getBitsLength"), "getBitsLength");
    ByteData.prototype.getLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength"), "getLength");
    ByteData.prototype.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    }, "getBitsLength"), "getBitsLength");
    ByteData.prototype.write = function(bitBuffer) {
      for (let i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
        bitBuffer.put(this.data[i2], 8);
      }
    };
    module.exports = ByteData;
  }
});
var require_kanji_data = __commonJS({
  "../node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    __name(KanjiData, "KanjiData");
    __name2(KanjiData, "KanjiData");
    KanjiData.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength(length) {
      return length * 13;
    }, "getBitsLength"), "getBitsLength");
    KanjiData.prototype.getLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getLength() {
      return this.data.length;
    }, "getLength"), "getLength");
    KanjiData.prototype.getBitsLength = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    }, "getBitsLength"), "getBitsLength");
    KanjiData.prototype.write = function(bitBuffer) {
      let i2;
      for (i2 = 0; i2 < this.data.length; i2++) {
        let value = Utils.toSJIS(this.data[i2]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});
var require_dijkstra = __commonJS({
  "../node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var dijkstra = {
      single_source_shortest_paths: function(graph, s2, d2) {
        var predecessors = {};
        var costs = {};
        costs[s2] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s2, 0);
        var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u2 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u2] || {};
          for (v2 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v2)) {
              cost_of_e = adjacent_nodes[v2];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v2];
              first_visit = typeof costs[v2] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v2, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v2] = u2;
              }
            }
          }
        }
        if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
          var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
        var nodes = [];
        var u2 = d2;
        var predecessor;
        while (u2) {
          nodes.push(u2);
          predecessor = predecessors[u2];
          u2 = predecessors[u2];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s2, d2) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s2, d2);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d2
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T2 = dijkstra.PriorityQueue, t2 = {}, key;
          opts = opts || {};
          for (key in T2) {
            if (T2.hasOwnProperty(key)) {
              t2[key] = T2[key];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T2.default_sorter;
          return t2;
        },
        default_sorter: function(a2, b2) {
          return a2.cost - b2.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});
var require_segments = __commonJS({
  "../node_modules/qrcode/lib/core/segments.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    __name(getStringByteLength, "getStringByteLength");
    __name2(getStringByteLength, "getStringByteLength");
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    __name(getSegments, "getSegments");
    __name2(getSegments, "getSegments");
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    __name(getSegmentsFromString, "getSegmentsFromString");
    __name2(getSegmentsFromString, "getSegmentsFromString");
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    __name(getSegmentBitsLength, "getSegmentBitsLength");
    __name2(getSegmentBitsLength, "getSegmentBitsLength");
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    __name(mergeSegments, "mergeSegments");
    __name2(mergeSegments, "mergeSegments");
    function buildNodes(segs) {
      const nodes = [];
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    __name(buildNodes, "buildNodes");
    __name2(buildNodes, "buildNodes");
    function buildGraph(nodes, version3) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const nodeGroup = nodes[i2];
        const currentNodeIds = [];
        for (let j2 = 0; j2 < nodeGroup.length; j2++) {
          const node = nodeGroup[j2];
          const key = "" + i2 + j2;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
            const prevNodeId = prevNodeIds[n2];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version3);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
        graph[prevNodeIds[n2]].end = 0;
      }
      return { map: graph, table };
    }
    __name(buildGraph, "buildGraph");
    __name2(buildGraph, "buildGraph");
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    __name(buildSingleSegment, "buildSingleSegment");
    __name2(buildSingleSegment, "buildSingleSegment");
    exports.fromArray = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromArray2(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    }, "fromArray2"), "fromArray");
    exports.fromString = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function fromString5(data, version3) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version3);
      const path2 = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i2 = 1; i2 < path2.length - 1; i2++) {
        optimizedSegs.push(graph.table[path2[i2]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    }, "fromString5"), "fromString");
    exports.rawSplit = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    }, "rawSplit"), "rawSplit");
  }
});
var require_qrcode = __commonJS({
  "../node_modules/qrcode/lib/core/qrcode.js"(exports) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version3) {
      const size3 = matrix.size;
      const pos = FinderPattern.getPositions(version3);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r3 = -1; r3 <= 7; r3++) {
          if (row + r3 <= -1 || size3 <= row + r3)
            continue;
          for (let c2 = -1; c2 <= 7; c2++) {
            if (col + c2 <= -1 || size3 <= col + c2)
              continue;
            if (r3 >= 0 && r3 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r3 === 0 || r3 === 6) || r3 >= 2 && r3 <= 4 && c2 >= 2 && c2 <= 4) {
              matrix.set(row + r3, col + c2, true, true);
            } else {
              matrix.set(row + r3, col + c2, false, true);
            }
          }
        }
      }
    }
    __name(setupFinderPattern, "setupFinderPattern");
    __name2(setupFinderPattern, "setupFinderPattern");
    function setupTimingPattern(matrix) {
      const size3 = matrix.size;
      for (let r3 = 8; r3 < size3 - 8; r3++) {
        const value = r3 % 2 === 0;
        matrix.set(r3, 6, value, true);
        matrix.set(6, r3, value, true);
      }
    }
    __name(setupTimingPattern, "setupTimingPattern");
    __name2(setupTimingPattern, "setupTimingPattern");
    function setupAlignmentPattern(matrix, version3) {
      const pos = AlignmentPattern.getPositions(version3);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r3 = -2; r3 <= 2; r3++) {
          for (let c2 = -2; c2 <= 2; c2++) {
            if (r3 === -2 || r3 === 2 || c2 === -2 || c2 === 2 || r3 === 0 && c2 === 0) {
              matrix.set(row + r3, col + c2, true, true);
            } else {
              matrix.set(row + r3, col + c2, false, true);
            }
          }
        }
      }
    }
    __name(setupAlignmentPattern, "setupAlignmentPattern");
    __name2(setupAlignmentPattern, "setupAlignmentPattern");
    function setupVersionInfo(matrix, version3) {
      const size3 = matrix.size;
      const bits = Version.getEncodedBits(version3);
      let row, col, mod2;
      for (let i2 = 0; i2 < 18; i2++) {
        row = Math.floor(i2 / 3);
        col = i2 % 3 + size3 - 8 - 3;
        mod2 = (bits >> i2 & 1) === 1;
        matrix.set(row, col, mod2, true);
        matrix.set(col, row, mod2, true);
      }
    }
    __name(setupVersionInfo, "setupVersionInfo");
    __name2(setupVersionInfo, "setupVersionInfo");
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size3 = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i2, mod2;
      for (i2 = 0; i2 < 15; i2++) {
        mod2 = (bits >> i2 & 1) === 1;
        if (i2 < 6) {
          matrix.set(i2, 8, mod2, true);
        } else if (i2 < 8) {
          matrix.set(i2 + 1, 8, mod2, true);
        } else {
          matrix.set(size3 - 15 + i2, 8, mod2, true);
        }
        if (i2 < 8) {
          matrix.set(8, size3 - i2 - 1, mod2, true);
        } else if (i2 < 9) {
          matrix.set(8, 15 - i2 - 1 + 1, mod2, true);
        } else {
          matrix.set(8, 15 - i2 - 1, mod2, true);
        }
      }
      matrix.set(size3 - 8, 8, 1, true);
    }
    __name(setupFormatInfo, "setupFormatInfo");
    __name2(setupFormatInfo, "setupFormatInfo");
    function setupData(matrix, data) {
      const size3 = matrix.size;
      let inc = -1;
      let row = size3 - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size3 - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (let c2 = 0; c2 < 2; c2++) {
            if (!matrix.isReserved(row, col - c2)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c2, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size3 <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    __name(setupData, "setupData");
    __name2(setupData, "setupData");
    function createData(version3, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version3));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version3);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i2 = 0; i2 < remainingByte; i2++) {
        buffer.put(i2 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version3, errorCorrectionLevel);
    }
    __name(createData, "createData");
    __name2(createData, "createData");
    function createCodewords(bitBuffer, version3, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version3);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version3, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version3, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
        const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b2] = buffer.slice(offset, offset + dataSize);
        ecData[b2] = rs.encode(dcData[b2]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i2, r3;
      for (i2 = 0; i2 < maxDataSize; i2++) {
        for (r3 = 0; r3 < ecTotalBlocks; r3++) {
          if (i2 < dcData[r3].length) {
            data[index++] = dcData[r3][i2];
          }
        }
      }
      for (i2 = 0; i2 < ecCount; i2++) {
        for (r3 = 0; r3 < ecTotalBlocks; r3++) {
          data[index++] = ecData[r3][i2];
        }
      }
      return data;
    }
    __name(createCodewords, "createCodewords");
    __name2(createCodewords, "createCodewords");
    function createSymbol(data, version3, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version3;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version3) {
        version3 = bestVersion;
      } else if (version3 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version3, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version3);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version3);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version3);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version3 >= 7) {
        setupVersionInfo(modules, version3);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version3,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    __name(createSymbol, "createSymbol");
    __name2(createSymbol, "createSymbol");
    exports.create = /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function create4(data, options2) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version3;
      let mask;
      if (typeof options2 !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options2.errorCorrectionLevel, ECLevel.M);
        version3 = Version.from(options2.version);
        mask = MaskPattern.from(options2.maskPattern);
        if (options2.toSJISFunc) {
          Utils.setToSJISFunction(options2.toSJISFunc);
        }
      }
      return createSymbol(data, version3, errorCorrectionLevel, mask);
    }, "create4"), "create");
  }
});
var require_react_jsx_runtime_development = __commonJS({
  "../node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    (function() {
      function getComponentNameFromType(type6) {
        if (null == type6)
          return null;
        if ("function" === typeof type6)
          return type6.$$typeof === REACT_CLIENT_REFERENCE ? null : type6.displayName || type6.name || null;
        if ("string" === typeof type6)
          return type6;
        switch (type6) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type6)
          switch ("number" === typeof type6.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type6.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type6.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type6._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type6.render;
              type6 = type6.displayName;
              type6 || (type6 = innerType.displayName || innerType.name || "", type6 = "" !== type6 ? "ForwardRef(" + type6 + ")" : "ForwardRef");
              return type6;
            case REACT_MEMO_TYPE:
              return innerType = type6.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type6.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type6._payload;
              type6 = type6._init;
              try {
                return getComponentNameFromType(type6(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      __name2(getComponentNameFromType, "getComponentNameFromType");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      __name2(testStringCoercion, "testStringCoercion");
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      __name(checkKeyStringCoercion, "checkKeyStringCoercion");
      __name2(checkKeyStringCoercion, "checkKeyStringCoercion");
      function getTaskName(type6) {
        if (type6 === REACT_FRAGMENT_TYPE)
          return "<>";
        if ("object" === typeof type6 && null !== type6 && type6.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type6);
          return name ? "<" + name + ">" : "<...>";
        } catch (x2) {
          return "<...>";
        }
      }
      __name(getTaskName, "getTaskName");
      __name2(getTaskName, "getTaskName");
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      __name(getOwner, "getOwner");
      __name2(getOwner, "getOwner");
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      __name(UnknownOwner, "UnknownOwner");
      __name2(UnknownOwner, "UnknownOwner");
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning)
            return false;
        }
        return void 0 !== config.key;
      }
      __name(hasValidKey, "hasValidKey");
      __name2(hasValidKey, "hasValidKey");
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        __name(warnAboutAccessingKey, "warnAboutAccessingKey");
        __name2(warnAboutAccessingKey, "warnAboutAccessingKey");
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      __name(defineKeyPropWarningGetter, "defineKeyPropWarningGetter");
      __name2(defineKeyPropWarningGetter, "defineKeyPropWarningGetter");
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      __name(elementRefGetterWithDeprecationWarning, "elementRefGetterWithDeprecationWarning");
      __name2(elementRefGetterWithDeprecationWarning, "elementRefGetterWithDeprecationWarning");
      function ReactElement(type6, key, self2, source, owner, props, debugStack, debugTask) {
        self2 = props.ref;
        type6 = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type6,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type6, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type6, "ref", { enumerable: false, value: null });
        type6._store = {};
        Object.defineProperty(type6._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type6, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type6, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type6, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type6.props), Object.freeze(type6));
        return type6;
      }
      __name(ReactElement, "ReactElement");
      __name2(ReactElement, "ReactElement");
      function jsxDEVImpl(type6, config, maybeKey, isStaticChildren, source, self2, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else
            validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type6);
          var keys = Object.keys(config).filter(function(k) {
            return "key" !== k;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else
          maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type6 ? type6.displayName || type6.name || "Unknown" : type6
        );
        return ReactElement(
          type6,
          children,
          self2,
          source,
          getOwner(),
          maybeKey,
          debugStack,
          debugTask
        );
      }
      __name(jsxDEVImpl, "jsxDEVImpl");
      __name2(jsxDEVImpl, "jsxDEVImpl");
      function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
      }
      __name(validateChildKeys, "validateChildKeys");
      __name2(validateChildKeys, "validateChildKeys");
      var React31 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React31.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React31 = {
        "react-stack-bottom-frame": function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React31["react-stack-bottom-frame"].bind(
        React31,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = function(type6, config, maybeKey, source, self2) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type6,
          config,
          maybeKey,
          false,
          source,
          self2,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type6)) : unknownOwnerDebugTask
        );
      };
      exports.jsxs = function(type6, config, maybeKey, source, self2) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type6,
          config,
          maybeKey,
          true,
          source,
          self2,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type6)) : unknownOwnerDebugTask
        );
      };
    })();
  }
});
var require_jsx_runtime = __commonJS({
  "../node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});
function __(str, params) {
  if (typeof navigator === "undefined")
    return str;
  return replaceParams(getLang()?.[str] ?? str, params);
}
__name(__, "__");
var import_react3;
var import_qrcode;
var import_jsx_runtime;
var translations;
var getLang;
var replaceParams;
var SELF_HOSTED_APP_ID;
var useIDKitStore;
var idkit_default;
var generateMatrix;
var Qrcode;
var QRCode_default;
var init_chunk_5OWPJUHG = __esm({
  "../node_modules/@worldcoin/idkit/build/chunk-5OWPJUHG.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_shallow();
    init_traditional();
    init_build();
    import_react3 = __toESM(require_react(), 1);
    import_qrcode = __toESM(require_qrcode(), 1);
    import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
    translations = {};
    getLang = /* @__PURE__ */ __name2(() => {
      if (!navigator?.languages)
        return;
      const supportedLang = navigator.languages.find((l2) => translations[l2] != void 0) ?? "";
      return translations[supportedLang];
    }, "getLang");
    replaceParams = /* @__PURE__ */ __name2((str, params) => {
      let replaced = str;
      for (const [key, value] of Object.entries(params ?? {}))
        replaced = str.replace(`:${key}`, value);
      return replaced;
    }, "replaceParams");
    __name2(__, "__");
    SELF_HOSTED_APP_ID = "self_hosted";
    useIDKitStore = createWithEqualityFn()(
      (set, get) => ({
        app_id: "",
        signal: "",
        action: "",
        action_description: "",
        bridge_url: "",
        verification_level: DEFAULT_VERIFICATION_LEVEL,
        partner: false,
        open: false,
        result: null,
        errorTitle: "",
        errorDetail: "",
        autoClose: true,
        errorState: null,
        processing: false,
        errorCallbacks: {},
        verifyCallbacks: {},
        successCallbacks: {},
        stage: "WORLD_ID",
        setStage: (stage) => set({ stage }),
        setErrorState: (errorState) => set({ errorState }),
        setProcessing: (processing) => set({ processing }),
        retryFlow: () => {
          set({ stage: "WORLD_ID", errorState: null });
        },
        addErrorCallback: (cb, source) => {
          set((state) => {
            state.errorCallbacks[source] = cb;
            return state;
          });
        },
        addSuccessCallback: (cb, source) => {
          set((state) => {
            state.successCallbacks[source] = cb;
            return state;
          });
        },
        addVerificationCallback: (cb, source) => {
          set((state) => {
            state.verifyCallbacks[source] = cb;
            return state;
          });
        },
        setOptions: ({
          handleVerify,
          onSuccess,
          signal,
          action,
          app_id,
          partner,
          onError,
          verification_level,
          action_description,
          bridge_url,
          autoClose,
          advanced
        }, source) => {
          set({
            signal,
            action,
            bridge_url,
            action_description,
            autoClose: autoClose ?? true,
            app_id: advanced?.self_hosted ? SELF_HOSTED_APP_ID : app_id,
            verification_level: verification_level ?? DEFAULT_VERIFICATION_LEVEL,
            partner
          });
          get().addSuccessCallback(onSuccess, source);
          if (onError)
            get().addErrorCallback(onError, source);
          if (handleVerify)
            get().addVerificationCallback(handleVerify, source);
        },
        handleVerify: (result) => {
          set({ stage: "HOST_APP_VERIFICATION", processing: false });
          Promise.all(Object.values(get().verifyCallbacks).map(async (cb) => cb?.(result))).then(
            () => {
              set({ stage: "SUCCESS", result });
              if (get().autoClose)
                setTimeout(() => get().onOpenChange(false), 2500);
            },
            (response) => {
              let errorMessage = void 0;
              if (response && typeof response === "object" && response.message) {
                errorMessage = response.message;
              }
              set({
                stage: "ERROR",
                errorState: {
                  code: AppErrorCodes.FailedByHostApp,
                  message: errorMessage ? __(errorMessage) : void 0
                }
              });
            }
          );
        },
        onOpenChange: (open) => {
          if (open) {
            return set({ open });
          }
          const errorState = get().errorState;
          if (get().stage === "ERROR" && errorState) {
            const callbacks = get().errorCallbacks;
            requestAnimationFrame(() => Object.values(callbacks).forEach((cb) => void cb?.(errorState)));
          }
          const result = get().result;
          if (get().stage == "SUCCESS" && result) {
            const callbacks = get().successCallbacks;
            requestAnimationFrame(() => Object.values(callbacks).forEach((cb) => void cb?.(result)));
          }
          set({
            open,
            result: null,
            errorState: null,
            processing: false,
            stage: "WORLD_ID"
            /* WORLD_ID */
          });
        }
      }),
      shallow$1
    );
    idkit_default = useIDKitStore;
    generateMatrix = /* @__PURE__ */ __name2((data) => {
      const arr = import_qrcode.default.create(data, { errorCorrectionLevel: "M" }).modules.data;
      const sqrt = Math.sqrt(arr.length);
      return arr.reduce(
        (rows, key, index) => {
          if (index % sqrt === 0)
            rows.push([key]);
          else
            rows[rows.length - 1].push(key);
          return rows;
        },
        []
      );
    }, "generateMatrix");
    Qrcode = /* @__PURE__ */ __name2(({ data, size: size3 = 300 }) => {
      const dots = (0, import_react3.useMemo)(() => {
        const dots2 = [];
        const matrix = generateMatrix(data);
        const cellSize = size3 / matrix.length;
        const qrList = [
          { x: 0, y: 0 },
          { x: 1, y: 0 },
          { x: 0, y: 1 }
        ];
        qrList.forEach(({ x: x2, y: y2 }) => {
          const x1 = (matrix.length - 7) * cellSize * x2;
          const y1 = (matrix.length - 7) * cellSize * y2;
          for (let i2 = 0; i2 < 3; i2++) {
            dots2.push(
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                "rect",
                {
                  fill: "currentColor",
                  x: x1 + cellSize * i2,
                  y: y1 + cellSize * i2,
                  width: cellSize * (7 - i2 * 2),
                  height: cellSize * (7 - i2 * 2),
                  rx: (i2 - 2) * -5,
                  ry: (i2 - 2) * -5,
                  className: i2 % 3 === 0 ? "text-black" : i2 % 3 === 1 ? "text-white" : "text-black"
                },
                `${i2}-${x2}-${y2}`
              )
            );
          }
        });
        matrix.forEach((row, i2) => {
          row.forEach((_, j2) => {
            if (!matrix[i2][j2])
              return;
            if (i2 < 7 && j2 < 7 || i2 > matrix.length - 8 && j2 < 7 || i2 < 7 && j2 > matrix.length - 8)
              return;
            dots2.push(
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                "circle",
                {
                  fill: "currentColor",
                  r: cellSize / 3,
                  cx: i2 * cellSize + cellSize / 2,
                  cy: j2 * cellSize + cellSize / 2,
                  className: "text-black dark:text-white"
                },
                `circle-${i2}-${j2}`
              )
            );
          });
        });
        return dots2;
      }, [size3, data]);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", { height: size3, width: size3, "data-test-id": "qr-code", children: dots });
    }, "Qrcode");
    QRCode_default = (0, import_react3.memo)(Qrcode);
  }
});
var require_react_dom_development = __commonJS({
  "../node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    (function() {
      function noop2() {
      }
      __name(noop2, "noop2");
      __name2(noop2, "noop");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      __name2(testStringCoercion, "testStringCoercion");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      __name(createPortal$1, "createPortal$1");
      __name2(createPortal$1, "createPortal$1");
      function getCrossOriginStringAs(as, input) {
        if ("font" === as)
          return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      __name(getCrossOriginStringAs, "getCrossOriginStringAs");
      __name2(getCrossOriginStringAs, "getCrossOriginStringAs");
      function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
      }
      __name(getValueDescriptorExpectingObjectForWarning, "getValueDescriptorExpectingObjectForWarning");
      __name2(getValueDescriptorExpectingObjectForWarning, "getValueDescriptorExpectingObjectForWarning");
      function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
      }
      __name(getValueDescriptorExpectingEnumForWarning, "getValueDescriptorExpectingEnumForWarning");
      __name2(getValueDescriptorExpectingEnumForWarning, "getValueDescriptorExpectingEnumForWarning");
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      __name(resolveDispatcher, "resolveDispatcher");
      __name2(resolveDispatcher, "resolveDispatcher");
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React31 = require_react(), Internals = {
        d: {
          f: noop2,
          r: function() {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop2,
          C: noop2,
          L: noop2,
          m: noop2,
          X: noop2,
          S: noop2,
          M: noop2
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React31.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn)
            return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
            "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
          );
        }
      };
      exports.preconnect = function(href, options2) {
        "string" === typeof href && href ? null != options2 && "object" !== typeof options2 ? console.error(
          "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
          getValueDescriptorExpectingEnumForWarning(options2)
        ) : null != options2 && "string" !== typeof options2.crossOrigin && console.error(
          "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
          getValueDescriptorExpectingObjectForWarning(options2.crossOrigin)
        ) : console.error(
          "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        "string" === typeof href && (options2 ? (options2 = options2.crossOrigin, options2 = "string" === typeof options2 ? "use-credentials" === options2 ? options2 : "" : void 0) : options2 = null, Internals.d.C(href, options2));
      };
      exports.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href)
          console.error(
            "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
        else if (1 < arguments.length) {
          var options2 = arguments[1];
          "object" === typeof options2 && options2.hasOwnProperty("crossOrigin") ? console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options2)
          ) : console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options2)
          );
        }
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options2) {
        "string" === typeof href && href ? null == options2 || "object" !== typeof options2 ? console.error(
          "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
          getValueDescriptorExpectingEnumForWarning(options2)
        ) : "style" !== options2.as && "script" !== options2.as && console.error(
          'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
          getValueDescriptorExpectingEnumForWarning(options2.as)
        ) : console.error(
          "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        if ("string" === typeof href && options2 && "string" === typeof options2.as) {
          var as = options2.as, crossOrigin = getCrossOriginStringAs(as, options2.crossOrigin), integrity = "string" === typeof options2.integrity ? options2.integrity : void 0, fetchPriority = "string" === typeof options2.fetchPriority ? options2.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options2.precedence ? options2.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options2.nonce ? options2.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options2) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options2 && "object" !== typeof options2 ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : options2 && "as" in options2 && "script" !== options2.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options2.as) + ".");
        if (encountered)
          console.error(
            "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
            encountered
          );
        else
          switch (encountered = options2 && "string" === typeof options2.as ? options2.as : "script", encountered) {
            case "script":
              break;
            default:
              encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
          }
        if ("string" === typeof href)
          if ("object" === typeof options2 && null !== options2) {
            if (null == options2.as || "script" === options2.as)
              encountered = getCrossOriginStringAs(
                options2.as,
                options2.crossOrigin
              ), Internals.d.M(href, {
                crossOrigin: encountered,
                integrity: "string" === typeof options2.integrity ? options2.integrity : void 0,
                nonce: "string" === typeof options2.nonce ? options2.nonce : void 0
              });
          } else
            null == options2 && Internals.d.M(href);
      };
      exports.preload = function(href, options2) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options2 || "object" !== typeof options2 ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : "string" === typeof options2.as && options2.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options2.as) + ".");
        encountered && console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
        if ("string" === typeof href && "object" === typeof options2 && null !== options2 && "string" === typeof options2.as) {
          encountered = options2.as;
          var crossOrigin = getCrossOriginStringAs(
            encountered,
            options2.crossOrigin
          );
          Internals.d.L(href, encountered, {
            crossOrigin,
            integrity: "string" === typeof options2.integrity ? options2.integrity : void 0,
            nonce: "string" === typeof options2.nonce ? options2.nonce : void 0,
            type: "string" === typeof options2.type ? options2.type : void 0,
            fetchPriority: "string" === typeof options2.fetchPriority ? options2.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options2.referrerPolicy ? options2.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options2.imageSrcSet ? options2.imageSrcSet : void 0,
            imageSizes: "string" === typeof options2.imageSizes ? options2.imageSizes : void 0,
            media: "string" === typeof options2.media ? options2.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options2) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options2 && "object" !== typeof options2 ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : options2 && "as" in options2 && "string" !== typeof options2.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options2.as) + ".");
        encountered && console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
        "string" === typeof href && (options2 ? (encountered = getCrossOriginStringAs(
          options2.as,
          options2.crossOrigin
        ), Internals.d.m(href, {
          as: "string" === typeof options2.as && "script" !== options2.as ? options2.as : void 0,
          crossOrigin: encountered,
          integrity: "string" === typeof options2.integrity ? options2.integrity : void 0
        })) : Internals.d.m(href));
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a2) {
        return fn(a2);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
      };
      exports.version = "19.1.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});
var require_react_dom = __commonJS({
  "../node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_development();
    }
  }
});
var require_react_dom_server_edge_development = __commonJS({
  "../node_modules/react-dom/cjs/react-dom-server.edge.development.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    (function() {
      function styleReplacer(match2, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
      }
      __name(styleReplacer, "styleReplacer");
      __name2(styleReplacer, "styleReplacer");
      function scriptReplacer(match2, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
      }
      __name(scriptReplacer, "scriptReplacer");
      __name2(scriptReplacer, "scriptReplacer");
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m2, p0) {
          return p0;
        });
      }
      __name(objectName, "objectName");
      __name2(objectName, "objectName");
      function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
      }
      __name(describeKeyForErrorMessage, "describeKeyForErrorMessage");
      __name2(describeKeyForErrorMessage, "describeKeyForErrorMessage");
      function describeValueForErrorMessage(value) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(
              10 >= value.length ? value : value.slice(0, 10) + "..."
            );
          case "object":
            if (isArrayImpl(value))
              return "[...]";
            if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
              return "client";
            value = objectName(value);
            return "Object" === value ? "{...}" : value;
          case "function":
            return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
          default:
            return String(value);
        }
      }
      __name(describeValueForErrorMessage, "describeValueForErrorMessage");
      __name2(describeValueForErrorMessage, "describeValueForErrorMessage");
      function describeElementType(type6) {
        if ("string" === typeof type6)
          return type6;
        switch (type6) {
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type6)
          switch (type6.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeElementType(type6.render);
            case REACT_MEMO_TYPE:
              return describeElementType(type6.type);
            case REACT_LAZY_TYPE:
              var payload = type6._payload;
              type6 = type6._init;
              try {
                return describeElementType(type6(payload));
              } catch (x2) {
              }
          }
        return "";
      }
      __name(describeElementType, "describeElementType");
      __name2(describeElementType, "describeElementType");
      function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind)
          return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray))
          if (jsxChildrenParents.has(objectOrArray)) {
            var type6 = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type6) + ">";
            for (var i2 = 0; i2 < objectOrArray.length; i2++) {
              var value = objectOrArray[i2];
              value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
              "" + i2 === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type6) + ">";
          } else {
            objKind = "[";
            for (type6 = 0; type6 < objectOrArray.length; type6++)
              0 < type6 && (objKind += ", "), i2 = objectOrArray[type6], i2 = "object" === typeof i2 && null !== i2 ? describeObjectForErrorMessage(i2) : describeValueForErrorMessage(i2), "" + type6 === expandedName ? (start = objKind.length, length = i2.length, objKind += i2) : objKind = 10 > i2.length && 40 > objKind.length + i2.length ? objKind + i2 : objKind + "...";
            objKind += "]";
          }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
          objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
          if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG)
            return "client";
          if (jsxPropsParents.has(objectOrArray)) {
            objKind = jsxPropsParents.get(objectOrArray);
            objKind = "<" + (describeElementType(objKind) || "...");
            type6 = Object.keys(objectOrArray);
            for (i2 = 0; i2 < type6.length; i2++) {
              objKind += " ";
              value = type6[i2];
              objKind += describeKeyForErrorMessage(value) + "=";
              var _value2 = objectOrArray[value];
              var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
              "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
              value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
            }
            objKind += ">";
          } else {
            objKind = "{";
            type6 = Object.keys(objectOrArray);
            for (i2 = 0; i2 < type6.length; i2++)
              0 < i2 && (objKind += ", "), value = type6[i2], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
            objKind += "}";
          }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
      }
      __name(describeObjectForErrorMessage, "describeObjectForErrorMessage");
      __name2(describeObjectForErrorMessage, "describeObjectForErrorMessage");
      function murmurhash3_32_gc(key, seed) {
        var remainder = key.length & 3;
        var bytes = key.length - remainder;
        var h1 = seed;
        for (seed = 0; seed < bytes; ) {
          var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
          ++seed;
          k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        }
        h1 ^= key.length;
        h1 ^= h1 >>> 16;
        h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        return (h1 ^ h1 >>> 16) >>> 0;
      }
      __name(murmurhash3_32_gc, "murmurhash3_32_gc");
      __name2(murmurhash3_32_gc, "murmurhash3_32_gc");
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      __name(handleErrorInNextTick, "handleErrorInNextTick");
      __name2(handleErrorInNextTick, "handleErrorInNextTick");
      function writeChunk(destination, chunk) {
        if (0 !== chunk.byteLength)
          if (2048 < chunk.byteLength)
            0 < writtenBytes && (destination.enqueue(
              new Uint8Array(currentView.buffer, 0, writtenBytes)
            ), currentView = new Uint8Array(2048), writtenBytes = 0), destination.enqueue(chunk);
          else {
            var allowableBytes = currentView.length - writtenBytes;
            allowableBytes < chunk.byteLength && (0 === allowableBytes ? destination.enqueue(currentView) : (currentView.set(
              chunk.subarray(0, allowableBytes),
              writtenBytes
            ), destination.enqueue(currentView), chunk = chunk.subarray(allowableBytes)), currentView = new Uint8Array(2048), writtenBytes = 0);
            currentView.set(chunk, writtenBytes);
            writtenBytes += chunk.byteLength;
          }
      }
      __name(writeChunk, "writeChunk");
      __name2(writeChunk, "writeChunk");
      function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk);
        return true;
      }
      __name(writeChunkAndReturn, "writeChunkAndReturn");
      __name2(writeChunkAndReturn, "writeChunkAndReturn");
      function completeWriting(destination) {
        currentView && 0 < writtenBytes && (destination.enqueue(
          new Uint8Array(currentView.buffer, 0, writtenBytes)
        ), currentView = null, writtenBytes = 0);
      }
      __name(completeWriting, "completeWriting");
      __name2(completeWriting, "completeWriting");
      function stringToChunk(content) {
        return textEncoder.encode(content);
      }
      __name(stringToChunk, "stringToChunk");
      __name2(stringToChunk, "stringToChunk");
      function stringToPrecomputedChunk(content) {
        content = textEncoder.encode(content);
        2048 < content.byteLength && console.error(
          "precomputed chunks must be smaller than the view size configured for this host. This is a bug in React."
        );
        return content;
      }
      __name(stringToPrecomputedChunk, "stringToPrecomputedChunk");
      __name2(stringToPrecomputedChunk, "stringToPrecomputedChunk");
      function closeWithError(destination, error) {
        "function" === typeof destination.error ? destination.error(error) : destination.close();
      }
      __name(closeWithError, "closeWithError");
      __name2(closeWithError, "closeWithError");
      function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      }
      __name(typeName, "typeName");
      __name2(typeName, "typeName");
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), false;
        } catch (e2) {
          return true;
        }
      }
      __name(willCoercionThrow, "willCoercionThrow");
      __name2(willCoercionThrow, "willCoercionThrow");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      __name2(testStringCoercion, "testStringCoercion");
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkAttributeStringCoercion, "checkAttributeStringCoercion");
      __name2(checkAttributeStringCoercion, "checkAttributeStringCoercion");
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkCSSPropertyStringCoercion, "checkCSSPropertyStringCoercion");
      __name2(checkCSSPropertyStringCoercion, "checkCSSPropertyStringCoercion");
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkHtmlStringCoercion, "checkHtmlStringCoercion");
      __name2(checkHtmlStringCoercion, "checkHtmlStringCoercion");
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        console.error("Invalid attribute name: `%s`", attributeName);
        return false;
      }
      __name(isAttributeNameSafe, "isAttributeNameSafe");
      __name2(isAttributeNameSafe, "isAttributeNameSafe");
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
        ) : console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
        ));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
      }
      __name(checkControlledValueProps, "checkControlledValueProps");
      __name2(checkControlledValueProps, "checkControlledValueProps");
      function validateProperty$1(tagName, name) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
          return true;
        if (rARIACamel$1.test(name)) {
          tagName = "aria-" + name.slice(4).toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ), warnedProperties$1[name] = true;
          if (name !== tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true;
        }
        if (rARIA$1.test(name)) {
          tagName = name.toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return warnedProperties$1[name] = true, false;
          name !== tagName && (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ), warnedProperties$1[name] = true);
        }
        return true;
      }
      __name(validateProperty$1, "validateProperty$1");
      __name2(validateProperty$1, "validateProperty$1");
      function validateProperties$2(type6, props) {
        var invalidProps = [], key;
        for (key in props)
          validateProperty$1(type6, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error(
          "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type6
        ) : 1 < invalidProps.length && console.error(
          "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type6
        );
      }
      __name(validateProperties$2, "validateProperties$2");
      __name2(validateProperties$2, "validateProperties$2");
      function validateProperty(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
          return true;
        var lowerCasedName = name.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
          return console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ), warnedProperties[name] = true;
        if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
          return true;
        if (null != eventRegistry) {
          tagName = eventRegistry.possibleRegistrationNames;
          if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
            return true;
          eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
          if (null != eventRegistry)
            return console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ), warnedProperties[name] = true;
          if (EVENT_NAME_REGEX.test(name))
            return console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ), warnedProperties[name] = true;
        } else if (EVENT_NAME_REGEX.test(name))
          return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
            "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
            name
          ), warnedProperties[name] = true;
        if (rARIA.test(name) || rARIACamel.test(name))
          return true;
        if ("innerhtml" === lowerCasedName)
          return console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ), warnedProperties[name] = true;
        if ("aria" === lowerCasedName)
          return console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ), warnedProperties[name] = true;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
          return console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ), warnedProperties[name] = true;
        if ("number" === typeof value && isNaN(value))
          return console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ), warnedProperties[name] = true;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
            return console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
        } else if (name !== lowerCasedName)
          return console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ), warnedProperties[name] = true;
        switch (name) {
          case "dangerouslySetInnerHTML":
          case "children":
          case "style":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            return true;
          case "innerText":
          case "textContent":
            return true;
        }
        switch (typeof value) {
          case "boolean":
            switch (name) {
              case "autoFocus":
              case "checked":
              case "multiple":
              case "muted":
              case "selected":
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "capture":
              case "download":
              case "inert":
                return true;
              default:
                lowerCasedName = name.toLowerCase().slice(0, 5);
                if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                  return true;
                value ? console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                  value,
                  name,
                  name,
                  value,
                  name
                ) : console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  value,
                  name,
                  name,
                  value,
                  name,
                  name,
                  name
                );
                return warnedProperties[name] = true;
            }
          case "function":
          case "symbol":
            return warnedProperties[name] = true, false;
          case "string":
            if ("false" === value || "true" === value) {
              switch (name) {
                case "checked":
                case "selected":
                case "multiple":
                case "muted":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "inert":
                  break;
                default:
                  return true;
              }
              console.error(
                "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                value,
                name,
                "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                name,
                value
              );
              warnedProperties[name] = true;
            }
        }
        return true;
      }
      __name(validateProperty, "validateProperty");
      __name2(validateProperty, "validateProperty");
      function warnUnknownProperties(type6, props, eventRegistry) {
        var unknownProps = [], key;
        for (key in props)
          validateProperty(type6, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error(
          "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type6
        ) : 1 < unknownProps.length && console.error(
          "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type6
        );
      }
      __name(warnUnknownProperties, "warnUnknownProperties");
      __name2(warnUnknownProperties, "warnUnknownProperties");
      function camelize(string) {
        return string.replace(hyphenPattern, function(_, character) {
          return character.toUpperCase();
        });
      }
      __name(camelize, "camelize");
      __name2(camelize, "camelize");
      function escapeTextForBrowser(text) {
        if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
          return "" + text;
        checkHtmlStringCoercion(text);
        text = "" + text;
        var match2 = matchHtmlRegExp.exec(text);
        if (match2) {
          var html = "", index, lastIndex = 0;
          for (index = match2.index; index < text.length; index++) {
            switch (text.charCodeAt(index)) {
              case 34:
                match2 = "&quot;";
                break;
              case 38:
                match2 = "&amp;";
                break;
              case 39:
                match2 = "&#x27;";
                break;
              case 60:
                match2 = "&lt;";
                break;
              case 62:
                match2 = "&gt;";
                break;
              default:
                continue;
            }
            lastIndex !== index && (html += text.slice(lastIndex, index));
            lastIndex = index + 1;
            html += match2;
          }
          text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
        }
        return text;
      }
      __name(escapeTextForBrowser, "escapeTextForBrowser");
      __name2(escapeTextForBrowser, "escapeTextForBrowser");
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      __name(sanitizeURL, "sanitizeURL");
      __name2(sanitizeURL, "sanitizeURL");
      function escapeEntireInlineScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      __name(escapeEntireInlineScriptContent, "escapeEntireInlineScriptContent");
      __name2(escapeEntireInlineScriptContent, "escapeEntireInlineScriptContent");
      function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
        var inlineScriptWithNonce = void 0 === nonce ? startInlineScript : stringToPrecomputedChunk(
          '<script nonce="' + escapeTextForBrowser(nonce) + '">'
        ), idPrefix = resumableState.idPrefix;
        externalRuntimeConfig = [];
        var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
        void 0 !== bootstrapScriptContent && externalRuntimeConfig.push(
          inlineScriptWithNonce,
          stringToChunk(
            escapeEntireInlineScriptContent(bootstrapScriptContent)
          ),
          endInlineScript
        );
        bootstrapScriptContent = [];
        void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(
          stringToChunk(
            escapeEntireInlineScriptContent(JSON.stringify(importMap))
          )
        ), bootstrapScriptContent.push(importMapScriptEnd));
        onHeaders && "number" === typeof maxHeadersLength && 0 >= maxHeadersLength && console.error(
          "React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.",
          0 === maxHeadersLength ? "zero" : maxHeadersLength
        );
        importMap = onHeaders ? {
          preconnects: "",
          fontPreloads: "",
          highImagePreloads: "",
          remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
        } : null;
        onHeaders = {
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
          startInlineScript: inlineScriptWithNonce,
          preamble: createPreambleState(),
          externalRuntimeScript: null,
          bootstrapChunks: externalRuntimeConfig,
          importMapChunks: bootstrapScriptContent,
          onHeaders,
          headers: importMap,
          resets: {
            font: {},
            dns: {},
            connect: { default: {}, anonymous: {}, credentials: {} },
            image: {},
            style: {}
          },
          charsetChunks: [],
          viewportChunks: [],
          hoistableChunks: [],
          preconnects: /* @__PURE__ */ new Set(),
          fontPreloads: /* @__PURE__ */ new Set(),
          highImagePreloads: /* @__PURE__ */ new Set(),
          styles: /* @__PURE__ */ new Map(),
          bootstrapScripts: /* @__PURE__ */ new Set(),
          scripts: /* @__PURE__ */ new Set(),
          bulkPreloads: /* @__PURE__ */ new Set(),
          preloads: {
            images: /* @__PURE__ */ new Map(),
            stylesheets: /* @__PURE__ */ new Map(),
            scripts: /* @__PURE__ */ new Map(),
            moduleScripts: /* @__PURE__ */ new Map()
          },
          nonce,
          hoistableState: null,
          stylesToHoist: false
        };
        if (void 0 !== bootstrapScripts)
          for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
            maxHeadersLength = bootstrapScripts[importMap];
            bootstrapScriptContent = idPrefix = void 0;
            var props = {
              rel: "preload",
              as: "script",
              fetchPriority: "low",
              nonce
            };
            "string" === typeof maxHeadersLength ? props.href = inlineScriptWithNonce = maxHeadersLength : (props.href = inlineScriptWithNonce = maxHeadersLength.src, props.integrity = bootstrapScriptContent = "string" === typeof maxHeadersLength.integrity ? maxHeadersLength.integrity : void 0, props.crossOrigin = idPrefix = "string" === typeof maxHeadersLength || null == maxHeadersLength.crossOrigin ? void 0 : "use-credentials" === maxHeadersLength.crossOrigin ? "use-credentials" : "");
            preloadBootstrapScriptOrModule(
              resumableState,
              onHeaders,
              inlineScriptWithNonce,
              props
            );
            externalRuntimeConfig.push(
              startScriptSrc,
              stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
            );
            nonce && externalRuntimeConfig.push(
              scriptNonce,
              stringToChunk(escapeTextForBrowser(nonce))
            );
            "string" === typeof bootstrapScriptContent && externalRuntimeConfig.push(
              scriptIntegirty,
              stringToChunk(escapeTextForBrowser(bootstrapScriptContent))
            );
            "string" === typeof idPrefix && externalRuntimeConfig.push(
              scriptCrossOrigin,
              stringToChunk(escapeTextForBrowser(idPrefix))
            );
            externalRuntimeConfig.push(endAsyncScript);
          }
        if (void 0 !== bootstrapModules)
          for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
            importMap = bootstrapModules[bootstrapScripts], idPrefix = inlineScriptWithNonce = void 0, bootstrapScriptContent = {
              rel: "modulepreload",
              fetchPriority: "low",
              nonce
            }, "string" === typeof importMap ? bootstrapScriptContent.href = maxHeadersLength = importMap : (bootstrapScriptContent.href = maxHeadersLength = importMap.src, bootstrapScriptContent.integrity = idPrefix = "string" === typeof importMap.integrity ? importMap.integrity : void 0, bootstrapScriptContent.crossOrigin = inlineScriptWithNonce = "string" === typeof importMap || null == importMap.crossOrigin ? void 0 : "use-credentials" === importMap.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
              resumableState,
              onHeaders,
              maxHeadersLength,
              bootstrapScriptContent
            ), externalRuntimeConfig.push(
              startModuleSrc,
              stringToChunk(escapeTextForBrowser(maxHeadersLength))
            ), nonce && externalRuntimeConfig.push(
              scriptNonce,
              stringToChunk(escapeTextForBrowser(nonce))
            ), "string" === typeof idPrefix && externalRuntimeConfig.push(
              scriptIntegirty,
              stringToChunk(escapeTextForBrowser(idPrefix))
            ), "string" === typeof inlineScriptWithNonce && externalRuntimeConfig.push(
              scriptCrossOrigin,
              stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
            ), externalRuntimeConfig.push(endAsyncScript);
        return onHeaders;
      }
      __name(createRenderState, "createRenderState");
      __name2(createRenderState, "createRenderState");
      function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        return {
          idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
          nextFormID: 0,
          streamingFormat: 0,
          bootstrapScriptContent,
          bootstrapScripts,
          bootstrapModules,
          instructions: NothingSent,
          hasBody: false,
          hasHtml: false,
          unknownResources: {},
          dnsResources: {},
          connectResources: { default: {}, anonymous: {}, credentials: {} },
          imageResources: {},
          styleResources: {},
          scriptResources: {},
          moduleUnknownResources: {},
          moduleScriptResources: {}
        };
      }
      __name(createResumableState, "createResumableState");
      __name2(createResumableState, "createResumableState");
      function createPreambleState() {
        return {
          htmlChunks: null,
          headChunks: null,
          bodyChunks: null,
          contribution: NoContribution
        };
      }
      __name(createPreambleState, "createPreambleState");
      __name2(createPreambleState, "createPreambleState");
      function createFormatContext(insertionMode, selectedValue, tagScope) {
        return {
          insertionMode,
          selectedValue,
          tagScope
        };
      }
      __name(createFormatContext, "createFormatContext");
      __name2(createFormatContext, "createFormatContext");
      function createRootFormatContext(namespaceURI) {
        return createFormatContext(
          "http://www.w3.org/2000/svg" === namespaceURI ? SVG_MODE : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? MATHML_MODE : ROOT_HTML_MODE,
          null,
          0
        );
      }
      __name(createRootFormatContext, "createRootFormatContext");
      __name2(createRootFormatContext, "createRootFormatContext");
      function getChildFormatContext(parentContext, type6, props) {
        switch (type6) {
          case "noscript":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 1
            );
          case "select":
            return createFormatContext(
              HTML_MODE,
              null != props.value ? props.value : props.defaultValue,
              parentContext.tagScope
            );
          case "svg":
            return createFormatContext(SVG_MODE, null, parentContext.tagScope);
          case "picture":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 2
            );
          case "math":
            return createFormatContext(MATHML_MODE, null, parentContext.tagScope);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null, parentContext.tagScope);
          case "table":
            return createFormatContext(
              HTML_TABLE_MODE,
              null,
              parentContext.tagScope
            );
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(
              HTML_TABLE_BODY_MODE,
              null,
              parentContext.tagScope
            );
          case "colgroup":
            return createFormatContext(
              HTML_COLGROUP_MODE,
              null,
              parentContext.tagScope
            );
          case "tr":
            return createFormatContext(
              HTML_TABLE_ROW_MODE,
              null,
              parentContext.tagScope
            );
          case "head":
            if (parentContext.insertionMode < HTML_MODE)
              return createFormatContext(
                HTML_HEAD_MODE,
                null,
                parentContext.tagScope
              );
            break;
          case "html":
            if (parentContext.insertionMode === ROOT_HTML_MODE)
              return createFormatContext(
                HTML_HTML_MODE,
                null,
                parentContext.tagScope
              );
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, parentContext.tagScope) : parentContext;
      }
      __name(getChildFormatContext, "getChildFormatContext");
      __name2(getChildFormatContext, "getChildFormatContext");
      function pushTextInstance(target, text, renderState, textEmbedded) {
        if ("" === text)
          return textEmbedded;
        textEmbedded && target.push(textSeparator);
        target.push(stringToChunk(escapeTextForBrowser(text)));
        return true;
      }
      __name(pushTextInstance, "pushTextInstance");
      __name2(pushTextInstance, "pushTextInstance");
      function pushStyleAttribute(target, style) {
        if ("object" !== typeof style)
          throw Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        var isFirst = true, styleName;
        for (styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
              if (0 === styleName.indexOf("--")) {
                var nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                checkCSSPropertyStringCoercion(styleValue, styleName);
                styleValue = stringToChunk(
                  escapeTextForBrowser(("" + styleValue).trim())
                );
              } else {
                nameChunk = styleName;
                var value = styleValue;
                if (-1 < nameChunk.indexOf("-")) {
                  var name = nameChunk;
                  warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported style property %s. Did you mean %s?",
                    name,
                    camelize(name.replace(msPattern$1, "ms-"))
                  ));
                } else if (badVendoredStyleNamePattern.test(nameChunk))
                  name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                    name,
                    name.charAt(0).toUpperCase() + name.slice(1)
                  ));
                else if (badStyleValueWithSemicolonPattern.test(value)) {
                  name = nameChunk;
                  var value$jscomp$0 = value;
                  warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                    `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                    name,
                    value$jscomp$0.replace(
                      badStyleValueWithSemicolonPattern,
                      ""
                    )
                  ));
                }
                "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                  "`NaN` is an invalid value for the `%s` css style property.",
                  nameChunk
                )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                  "`Infinity` is an invalid value for the `%s` css style property.",
                  nameChunk
                )));
                nameChunk = styleName;
                value = styleNameCache.get(nameChunk);
                void 0 !== value ? nameChunk = value : (value = stringToPrecomputedChunk(
                  escapeTextForBrowser(
                    nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                  )
                ), styleNameCache.set(nameChunk, value), nameChunk = value);
                "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? stringToChunk("" + styleValue) : stringToChunk(styleValue + "px") : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = stringToChunk(
                  escapeTextForBrowser(("" + styleValue).trim())
                ));
              }
              isFirst ? (isFirst = false, target.push(
                styleAttributeStart,
                nameChunk,
                styleAssign,
                styleValue
              )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      __name(pushStyleAttribute, "pushStyleAttribute");
      __name2(pushStyleAttribute, "pushStyleAttribute");
      function pushBooleanAttribute(target, name, value) {
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeEmptyString
        );
      }
      __name(pushBooleanAttribute, "pushBooleanAttribute");
      __name2(pushBooleanAttribute, "pushBooleanAttribute");
      function pushStringAttribute(target, name, value) {
        "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
      }
      __name(pushStringAttribute, "pushStringAttribute");
      __name2(pushStringAttribute, "pushStringAttribute");
      function pushAdditionalFormField(value, key) {
        this.push(startHiddenInputChunk);
        validateAdditionalFormField(value);
        pushStringAttribute(this, "name", key);
        pushStringAttribute(this, "value", value);
        this.push(endOfStartTagSelfClosing);
      }
      __name(pushAdditionalFormField, "pushAdditionalFormField");
      __name2(pushAdditionalFormField, "pushAdditionalFormField");
      function validateAdditionalFormField(value) {
        if ("string" !== typeof value)
          throw Error(
            "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
          );
      }
      __name(validateAdditionalFormField, "validateAdditionalFormField");
      __name2(validateAdditionalFormField, "validateAdditionalFormField");
      function getCustomFormFields(resumableState, formAction) {
        if ("function" === typeof formAction.$$FORM_ACTION) {
          var id3 = resumableState.nextFormID++;
          resumableState = resumableState.idPrefix + id3;
          try {
            var customFields = formAction.$$FORM_ACTION(resumableState);
            if (customFields) {
              var formData = customFields.data;
              null != formData && formData.forEach(validateAdditionalFormField);
            }
            return customFields;
          } catch (x2) {
            if ("object" === typeof x2 && null !== x2 && "function" === typeof x2.then)
              throw x2;
            console.error(
              "Failed to serialize an action for progressive enhancement:\n%s",
              x2
            );
          }
        }
        return null;
      }
      __name(getCustomFormFields, "getCustomFormFields");
      __name2(getCustomFormFields, "getCustomFormFields");
      function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
        var formData = null;
        if ("function" === typeof formAction) {
          null === name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          ));
          null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          ));
          null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ));
          var customFields = getCustomFormFields(resumableState, formAction);
          null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
            attributeSeparator,
            stringToChunk("formAction"),
            attributeAssign,
            actionJavaScriptURL,
            attributeEnd
          ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != name && pushAttribute(target, "name", name);
        null != formAction && pushAttribute(target, "formAction", formAction);
        null != formEncType && pushAttribute(target, "formEncType", formEncType);
        null != formMethod && pushAttribute(target, "formMethod", formMethod);
        null != formTarget && pushAttribute(target, "formTarget", formTarget);
        return formData;
      }
      __name(pushFormActionAttribute, "pushFormActionAttribute");
      __name2(pushFormActionAttribute, "pushFormActionAttribute");
      function pushAttribute(target, name, value) {
        switch (name) {
          case "className":
            pushStringAttribute(target, "class", value);
            break;
          case "tabIndex":
            pushStringAttribute(target, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            pushStringAttribute(target, name, value);
            break;
          case "style":
            pushStyleAttribute(target, value);
            break;
          case "src":
          case "href":
            if ("" === value) {
              "src" === name ? console.error(
                'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              ) : console.error(
                'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              );
              break;
            }
          case "action":
          case "formAction":
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "ref":
            break;
          case "autoFocus":
          case "multiple":
          case "muted":
            pushBooleanAttribute(target, name.toLowerCase(), value);
            break;
          case "xlinkHref":
            if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              stringToChunk("xlink:href"),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "inert":
            "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = true, console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              name
            ));
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeEmptyString
            );
            break;
          case "capture":
          case "download":
            true === value ? target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeEmptyString
            ) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "rowSpan":
          case "start":
            "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "xlinkActuate":
            pushStringAttribute(target, "xlink:actuate", value);
            break;
          case "xlinkArcrole":
            pushStringAttribute(target, "xlink:arcrole", value);
            break;
          case "xlinkRole":
            pushStringAttribute(target, "xlink:role", value);
            break;
          case "xlinkShow":
            pushStringAttribute(target, "xlink:show", value);
            break;
          case "xlinkTitle":
            pushStringAttribute(target, "xlink:title", value);
            break;
          case "xlinkType":
            pushStringAttribute(target, "xlink:type", value);
            break;
          case "xmlBase":
            pushStringAttribute(target, "xml:base", value);
            break;
          case "xmlLang":
            pushStringAttribute(target, "xml:lang", value);
            break;
          case "xmlSpace":
            pushStringAttribute(target, "xml:space", value);
            break;
          default:
            if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
              if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
                switch (typeof value) {
                  case "function":
                  case "symbol":
                    return;
                  case "boolean":
                    var prefix2 = name.toLowerCase().slice(0, 5);
                    if ("data-" !== prefix2 && "aria-" !== prefix2)
                      return;
                }
                target.push(
                  attributeSeparator,
                  stringToChunk(name),
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd
                );
              }
            }
        }
      }
      __name(pushAttribute, "pushAttribute");
      __name2(pushAttribute, "pushAttribute");
      function pushInnerHTML(target, innerHTML, children) {
        if (null != innerHTML) {
          if (null != children)
            throw Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          if ("object" !== typeof innerHTML || !("__html" in innerHTML))
            throw Error(
              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
            );
          innerHTML = innerHTML.__html;
          null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push(stringToChunk("" + innerHTML)));
        }
      }
      __name(pushInnerHTML, "pushInnerHTML");
      __name2(pushInnerHTML, "pushInnerHTML");
      function checkSelectProp(props, propName) {
        var value = props[propName];
        null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
          "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
          propName
        ) : !props.multiple && value && console.error(
          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
          propName
        ));
      }
      __name(checkSelectProp, "checkSelectProp");
      __name2(checkSelectProp, "checkSelectProp");
      function flattenOptionChildren(children) {
        var content = "";
        React31.Children.forEach(children, function(child) {
          null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
            "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
          )));
        });
        return content;
      }
      __name(flattenOptionChildren, "flattenOptionChildren");
      __name2(flattenOptionChildren, "flattenOptionChildren");
      function injectFormReplayingRuntime(resumableState, renderState) {
        (resumableState.instructions & 16) === NothingSent && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
          renderState.startInlineScript,
          formReplayingRuntimeScript,
          endInlineScript
        ));
      }
      __name(injectFormReplayingRuntime, "injectFormReplayingRuntime");
      __name2(injectFormReplayingRuntime, "injectFormReplayingRuntime");
      function pushLinkImpl(target, props) {
        target.push(startChunkForTag("link"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushLinkImpl, "pushLinkImpl");
      __name2(pushLinkImpl, "pushLinkImpl");
      function escapeStyleTextContent(styleText) {
        checkHtmlStringCoercion(styleText);
        return ("" + styleText).replace(styleRegex, styleReplacer);
      }
      __name(escapeStyleTextContent, "escapeStyleTextContent");
      __name2(escapeStyleTextContent, "escapeStyleTextContent");
      function pushSelfClosing(target, props, tag) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushSelfClosing, "pushSelfClosing");
      __name2(pushSelfClosing, "pushSelfClosing");
      function pushTitleImpl(target, props) {
        target.push(startChunkForTag("title"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
        "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(stringToChunk(escapeTextForBrowser("" + props)));
        pushInnerHTML(target, innerHTML, children);
        target.push(endChunkForTag("title"));
        return null;
      }
      __name(pushTitleImpl, "pushTitleImpl");
      __name2(pushTitleImpl, "pushTitleImpl");
      function pushScriptImpl(target, props) {
        target.push(startChunkForTag("script"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
          "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
          props
        ));
        pushInnerHTML(target, innerHTML, children);
        "string" === typeof children && target.push(stringToChunk(escapeEntireInlineScriptContent(children)));
        target.push(endChunkForTag("script"));
        return null;
      }
      __name(pushScriptImpl, "pushScriptImpl");
      __name2(pushScriptImpl, "pushScriptImpl");
      function pushStartSingletonElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return tag;
      }
      __name(pushStartSingletonElement, "pushStartSingletonElement");
      __name2(pushStartSingletonElement, "pushStartSingletonElement");
      function pushStartGenericElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return "string" === typeof tag ? (target.push(stringToChunk(escapeTextForBrowser(tag))), null) : tag;
      }
      __name(pushStartGenericElement, "pushStartGenericElement");
      __name2(pushStartGenericElement, "pushStartGenericElement");
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (void 0 === tagStartChunk) {
          if (!VALID_TAG_REGEX.test(tag))
            throw Error("Invalid tag: " + tag);
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      __name(startChunkForTag, "startChunkForTag");
      __name2(startChunkForTag, "startChunkForTag");
      function pushStartInstance(target$jscomp$0, type6, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
        validateProperties$2(type6, props);
        "input" !== type6 && "textarea" !== type6 && "select" !== type6 || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type6 && props.multiple ? console.error(
          "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
          type6
        ) : console.error(
          "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
          type6
        ));
        b:
          if (-1 === type6.indexOf("-"))
            var JSCompiler_inline_result = false;
          else
            switch (type6) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                JSCompiler_inline_result = false;
                break b;
              default:
                JSCompiler_inline_result = true;
            }
        JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type6, props, null);
        !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
        formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type6.indexOf("-") && type6.toLowerCase() !== type6 && console.error(
          "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
          type6
        );
        switch (type6) {
          case "div":
          case "span":
          case "svg":
          case "path":
            break;
          case "a":
            target$jscomp$0.push(startChunkForTag("a"));
            var children = null, innerHTML = null, propKey;
            for (propKey in props)
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "children":
                      children = propValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML = propValue;
                      break;
                    case "href":
                      "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                      break;
                    default:
                      pushAttribute(target$jscomp$0, propKey, propValue);
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML, children);
            if ("string" === typeof children) {
              target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));
              var JSCompiler_inline_result$jscomp$0 = null;
            } else
              JSCompiler_inline_result$jscomp$0 = children;
            return JSCompiler_inline_result$jscomp$0;
          case "g":
          case "p":
          case "li":
            break;
          case "select":
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
              "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultSelectValue = true);
            target$jscomp$0.push(startChunkForTag("select"));
            var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
            for (propKey$jscomp$0 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                var propValue$jscomp$0 = props[propKey$jscomp$0];
                if (null != propValue$jscomp$0)
                  switch (propKey$jscomp$0) {
                    case "children":
                      children$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "defaultValue":
                    case "value":
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$0,
                        propValue$jscomp$0
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
            return children$jscomp$0;
          case "option":
            var selectedValue = formatContext.selectedValue;
            target$jscomp$0.push(startChunkForTag("option"));
            var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
            for (propKey$jscomp$1 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                var propValue$jscomp$1 = props[propKey$jscomp$1];
                if (null != propValue$jscomp$1)
                  switch (propKey$jscomp$1) {
                    case "children":
                      children$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "selected":
                      selected = propValue$jscomp$1;
                      didWarnSelectedSetOnOption || (console.error(
                        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                      ), didWarnSelectedSetOnOption = true);
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "value":
                      value = propValue$jscomp$1;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$1,
                        propValue$jscomp$1
                      );
                  }
              }
            if (null != selectedValue) {
              if (null !== value) {
                checkAttributeStringCoercion(value, "value");
                var stringValue = "" + value;
              } else
                null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                  "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                )), stringValue = flattenOptionChildren(children$jscomp$1);
              if (isArrayImpl(selectedValue))
                for (var i2 = 0; i2 < selectedValue.length; i2++) {
                  if (checkAttributeStringCoercion(selectedValue[i2], "value"), "" + selectedValue[i2] === stringValue) {
                    target$jscomp$0.push(selectedMarkerAttribute);
                    break;
                  }
                }
              else
                checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);
            } else
              selected && target$jscomp$0.push(selectedMarkerAttribute);
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
            return children$jscomp$1;
          case "textarea":
            checkControlledValueProps("textarea", props);
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
              "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultTextareaValue = true);
            target$jscomp$0.push(startChunkForTag("textarea"));
            var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
            for (propKey$jscomp$2 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                var propValue$jscomp$2 = props[propKey$jscomp$2];
                if (null != propValue$jscomp$2)
                  switch (propKey$jscomp$2) {
                    case "children":
                      children$jscomp$2 = propValue$jscomp$2;
                      break;
                    case "value":
                      value$jscomp$0 = propValue$jscomp$2;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$jscomp$2;
                      break;
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$2,
                        propValue$jscomp$2
                      );
                  }
              }
            null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
            target$jscomp$0.push(endOfStartTag);
            if (null != children$jscomp$2) {
              console.error(
                "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
              );
              if (null != value$jscomp$0)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children$jscomp$2)) {
                if (1 < children$jscomp$2.length)
                  throw Error("<textarea> can only have at most one child.");
                checkHtmlStringCoercion(children$jscomp$2[0]);
                value$jscomp$0 = "" + children$jscomp$2[0];
              }
              checkHtmlStringCoercion(children$jscomp$2);
              value$jscomp$0 = "" + children$jscomp$2;
            }
            "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
            null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(
              stringToChunk(escapeTextForBrowser("" + value$jscomp$0))
            ));
            return null;
          case "input":
            checkControlledValueProps("input", props);
            target$jscomp$0.push(startChunkForTag("input"));
            var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
            for (propKey$jscomp$3 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                var propValue$jscomp$3 = props[propKey$jscomp$3];
                if (null != propValue$jscomp$3)
                  switch (propKey$jscomp$3) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    case "name":
                      name = propValue$jscomp$3;
                      break;
                    case "formAction":
                      formAction = propValue$jscomp$3;
                      break;
                    case "formEncType":
                      formEncType = propValue$jscomp$3;
                      break;
                    case "formMethod":
                      formMethod = propValue$jscomp$3;
                      break;
                    case "formTarget":
                      formTarget = propValue$jscomp$3;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$jscomp$3;
                      break;
                    case "defaultValue":
                      defaultValue$jscomp$0 = propValue$jscomp$3;
                      break;
                    case "checked":
                      checked = propValue$jscomp$3;
                      break;
                    case "value":
                      value$jscomp$1 = propValue$jscomp$3;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$3,
                        propValue$jscomp$3
                      );
                  }
              }
            null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'An input can only specify a formAction along with type="submit" or type="image".'
            ));
            var formData = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction,
              formEncType,
              formMethod,
              formTarget,
              name
            );
            null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
              "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultChecked = true);
            null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
              "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultInputValue = true);
            null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
            null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
            target$jscomp$0.push(endOfStartTagSelfClosing);
            null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
            return null;
          case "button":
            target$jscomp$0.push(startChunkForTag("button"));
            var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
            for (propKey$jscomp$4 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                var propValue$jscomp$4 = props[propKey$jscomp$4];
                if (null != propValue$jscomp$4)
                  switch (propKey$jscomp$4) {
                    case "children":
                      children$jscomp$3 = propValue$jscomp$4;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$2 = propValue$jscomp$4;
                      break;
                    case "name":
                      name$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formAction":
                      formAction$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formEncType":
                      formEncType$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formMethod":
                      formMethod$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formTarget":
                      formTarget$jscomp$0 = propValue$jscomp$4;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$4,
                        propValue$jscomp$4
                      );
                  }
              }
            null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'A button can only specify a formAction along with type="submit" or no type.'
            ));
            var formData$jscomp$0 = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction$jscomp$0,
              formEncType$jscomp$0,
              formMethod$jscomp$0,
              formTarget$jscomp$0,
              name$jscomp$0
            );
            target$jscomp$0.push(endOfStartTag);
            null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
            if ("string" === typeof children$jscomp$3) {
              target$jscomp$0.push(
                stringToChunk(escapeTextForBrowser(children$jscomp$3))
              );
              var JSCompiler_inline_result$jscomp$1 = null;
            } else
              JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
            return JSCompiler_inline_result$jscomp$1;
          case "form":
            target$jscomp$0.push(startChunkForTag("form"));
            var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
            for (propKey$jscomp$5 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                var propValue$jscomp$5 = props[propKey$jscomp$5];
                if (null != propValue$jscomp$5)
                  switch (propKey$jscomp$5) {
                    case "children":
                      children$jscomp$4 = propValue$jscomp$5;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$3 = propValue$jscomp$5;
                      break;
                    case "action":
                      formAction$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "encType":
                      formEncType$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "method":
                      formMethod$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "target":
                      formTarget$jscomp$1 = propValue$jscomp$5;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$5,
                        propValue$jscomp$5
                      );
                  }
              }
            var formData$jscomp$1 = null, formActionName = null;
            if ("function" === typeof formAction$jscomp$1) {
              null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              ));
              null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ));
              var customFields = getCustomFormFields(
                resumableState,
                formAction$jscomp$1
              );
              null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                attributeSeparator,
                stringToChunk("action"),
                attributeAssign,
                actionJavaScriptURL,
                attributeEnd
              ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
            }
            null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
            null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
            null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
            null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
            target$jscomp$0.push(endOfStartTag);
            null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
              pushAdditionalFormField,
              target$jscomp$0
            ));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
            if ("string" === typeof children$jscomp$4) {
              target$jscomp$0.push(
                stringToChunk(escapeTextForBrowser(children$jscomp$4))
              );
              var JSCompiler_inline_result$jscomp$2 = null;
            } else
              JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
            return JSCompiler_inline_result$jscomp$2;
          case "menuitem":
            target$jscomp$0.push(startChunkForTag("menuitem"));
            for (var propKey$jscomp$6 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                var propValue$jscomp$6 = props[propKey$jscomp$6];
                if (null != propValue$jscomp$6)
                  switch (propKey$jscomp$6) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$6,
                        propValue$jscomp$6
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            return null;
          case "object":
            target$jscomp$0.push(startChunkForTag("object"));
            var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
            for (propKey$jscomp$7 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                var propValue$jscomp$7 = props[propKey$jscomp$7];
                if (null != propValue$jscomp$7)
                  switch (propKey$jscomp$7) {
                    case "children":
                      children$jscomp$5 = propValue$jscomp$7;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$4 = propValue$jscomp$7;
                      break;
                    case "data":
                      checkAttributeStringCoercion(propValue$jscomp$7, "data");
                      var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                      if ("" === sanitizedValue) {
                        console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          propKey$jscomp$7,
                          propKey$jscomp$7
                        );
                        break;
                      }
                      target$jscomp$0.push(
                        attributeSeparator,
                        stringToChunk("data"),
                        attributeAssign,
                        stringToChunk(escapeTextForBrowser(sanitizedValue)),
                        attributeEnd
                      );
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$7,
                        propValue$jscomp$7
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
            if ("string" === typeof children$jscomp$5) {
              target$jscomp$0.push(
                stringToChunk(escapeTextForBrowser(children$jscomp$5))
              );
              var JSCompiler_inline_result$jscomp$3 = null;
            } else
              JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
            return JSCompiler_inline_result$jscomp$3;
          case "title":
            var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
              Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                children$jscomp$6.length
              ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                "function" === typeof child ? "a Function" : "a Sybmol"
              ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
              ) : console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
              ));
            }
            if (insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                target$jscomp$0,
                props
              );
            else
              isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
            return JSCompiler_inline_result$jscomp$4;
          case "link":
            var rel = props.rel, href = props.href, precedence = props.precedence;
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
              "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
              ));
              pushLinkImpl(target$jscomp$0, props);
              var JSCompiler_inline_result$jscomp$5 = null;
            } else if ("stylesheet" === props.rel)
              if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                if ("string" === typeof precedence) {
                  if (null != props.disabled)
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                    );
                  else if (props.onLoad || props.onError) {
                    var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                      propDescription,
                      propDescription
                    );
                  }
                }
                JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                );
              } else {
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                  href
                ) ? resumableState.styleResources[href] : void 0;
                if (resourceState !== EXISTS) {
                  resumableState.styleResources[href] = EXISTS;
                  styleQueue || (styleQueue = {
                    precedence: stringToChunk(escapeTextForBrowser(precedence)),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(precedence, styleQueue));
                  var resource = {
                    state: PENDING$1,
                    props: assign({}, props, {
                      "data-precedence": props.precedence,
                      precedence: null
                    })
                  };
                  if (resourceState) {
                    2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                    var preloadResource = renderState.preloads.stylesheets.get(href);
                    preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                  }
                  styleQueue.sheets.set(href, resource);
                  hoistableState && hoistableState.stylesheets.add(resource);
                } else if (styleQueue) {
                  var _resource = styleQueue.sheets.get(href);
                  _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                }
                textEmbedded && target$jscomp$0.push(textSeparator);
                JSCompiler_inline_result$jscomp$5 = null;
              }
            else
              props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                target$jscomp$0,
                props
              ) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
            return JSCompiler_inline_result$jscomp$5;
          case "script":
            var asyncProp = props.async;
            if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                target$jscomp$0,
                props
              );
            else {
              var key = props.src;
              if ("module" === props.type) {
                var resources = resumableState.moduleScriptResources;
                var preloads = renderState.preloads.moduleScripts;
              } else
                resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
              var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
              if (resourceState$jscomp$0 !== EXISTS) {
                resources[key] = EXISTS;
                var scriptProps = props;
                if (resourceState$jscomp$0) {
                  2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                  var preloadResource$jscomp$0 = preloads.get(key);
                  preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                }
                var resource$jscomp$0 = [];
                renderState.scripts.add(resource$jscomp$0);
                pushScriptImpl(resource$jscomp$0, scriptProps);
              }
              textEmbedded && target$jscomp$0.push(textSeparator);
              JSCompiler_inline_result$jscomp$6 = null;
            }
            return JSCompiler_inline_result$jscomp$6;
          case "style":
            var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
              );
            }
            var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
            if (insertionMode$jscomp$0 === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
              target$jscomp$0.push(startChunkForTag("style"));
              var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
              for (propKey$jscomp$8 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                  var propValue$jscomp$8 = props[propKey$jscomp$8];
                  if (null != propValue$jscomp$8)
                    switch (propKey$jscomp$8) {
                      case "children":
                        children$jscomp$8 = propValue$jscomp$8;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$5 = propValue$jscomp$8;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$8,
                          propValue$jscomp$8
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
              "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(
                stringToChunk(escapeStyleTextContent(child$jscomp$1))
              );
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$5,
                children$jscomp$8
              );
              target$jscomp$0.push(endChunkForTag("style"));
              var JSCompiler_inline_result$jscomp$7 = null;
            } else {
              href$jscomp$0.includes(" ") && console.error(
                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                href$jscomp$0
              );
              var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
              if (resourceState$jscomp$1 !== EXISTS) {
                resumableState.styleResources[href$jscomp$0] = EXISTS;
                resourceState$jscomp$1 && console.error(
                  'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                  href$jscomp$0
                );
                styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                  stringToChunk(escapeTextForBrowser(href$jscomp$0))
                ) : (styleQueue$jscomp$0 = {
                  precedence: stringToChunk(
                    escapeTextForBrowser(precedence$jscomp$0)
                  ),
                  rules: [],
                  hrefs: [stringToChunk(escapeTextForBrowser(href$jscomp$0))],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(
                  precedence$jscomp$0,
                  styleQueue$jscomp$0
                ));
                var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                for (propKey$jscomp$9 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                    var propValue$jscomp$9 = props[propKey$jscomp$9];
                    if (null != propValue$jscomp$9)
                      switch (propKey$jscomp$9) {
                        case "children":
                          children$jscomp$9 = propValue$jscomp$9;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$6 = propValue$jscomp$9;
                      }
                  }
                var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(
                  stringToChunk(escapeStyleTextContent(child$jscomp$2))
                );
                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
              }
              styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
              textEmbedded && target$jscomp$0.push(textSeparator);
              JSCompiler_inline_result$jscomp$7 = void 0;
            }
            return JSCompiler_inline_result$jscomp$7;
          case "meta":
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                target$jscomp$0,
                props,
                "meta"
              );
            else
              textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$8 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                renderState.hoistableChunks,
                props,
                "meta"
              );
            return JSCompiler_inline_result$jscomp$8;
          case "listing":
          case "pre":
            target$jscomp$0.push(startChunkForTag(type6));
            var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
            for (propKey$jscomp$10 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                var propValue$jscomp$10 = props[propKey$jscomp$10];
                if (null != propValue$jscomp$10)
                  switch (propKey$jscomp$10) {
                    case "children":
                      children$jscomp$10 = propValue$jscomp$10;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$7 = propValue$jscomp$10;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$10,
                        propValue$jscomp$10
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            if (null != innerHTML$jscomp$7) {
              if (null != children$jscomp$10)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              var html = innerHTML$jscomp$7.__html;
              null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, stringToChunk(html)) : (checkHtmlStringCoercion(html), target$jscomp$0.push(stringToChunk("" + html))));
            }
            "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
            return children$jscomp$10;
          case "img":
            var src = props.src, srcSet = props.srcSet;
            if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
              var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
              if (resource$jscomp$1) {
                if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                  promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
              } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                var input = props.crossOrigin;
                var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                var headers = renderState.headers, header;
                headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                  imageSrcSet: props.srcSet,
                  imageSizes: props.sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  nonce: props.nonce,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.refererPolicy
                }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                  rel: "preload",
                  as: "image",
                  href: srcSet ? void 0 : src,
                  imageSrcSet: srcSet,
                  imageSizes: sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.referrerPolicy
                }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
              }
            }
            return pushSelfClosing(target$jscomp$0, props, "img");
          case "base":
          case "area":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target$jscomp$0, props, type6);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            break;
          case "head":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble = preambleState || renderState.preamble;
              if (preamble.headChunks)
                throw Error("The `<head>` tag may only be rendered once.");
              preamble.headChunks = [];
              var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                preamble.headChunks,
                props,
                "head"
              );
            } else
              JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "head"
              );
            return JSCompiler_inline_result$jscomp$9;
          case "body":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble$jscomp$0 = preambleState || renderState.preamble;
              if (preamble$jscomp$0.bodyChunks)
                throw Error("The `<body>` tag may only be rendered once.");
              preamble$jscomp$0.bodyChunks = [];
              var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                preamble$jscomp$0.bodyChunks,
                props,
                "body"
              );
            } else
              JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "body"
              );
            return JSCompiler_inline_result$jscomp$10;
          case "html":
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              var preamble$jscomp$1 = preambleState || renderState.preamble;
              if (preamble$jscomp$1.htmlChunks)
                throw Error("The `<html>` tag may only be rendered once.");
              preamble$jscomp$1.htmlChunks = [doctypeChunk];
              var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                preamble$jscomp$1.htmlChunks,
                props,
                "html"
              );
            } else
              JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "html"
              );
            return JSCompiler_inline_result$jscomp$11;
          default:
            if (-1 !== type6.indexOf("-")) {
              target$jscomp$0.push(startChunkForTag(type6));
              var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
              for (propKey$jscomp$11 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                  var propValue$jscomp$11 = props[propKey$jscomp$11];
                  if (null != propValue$jscomp$11) {
                    var attributeName = propKey$jscomp$11;
                    switch (propKey$jscomp$11) {
                      case "children":
                        children$jscomp$11 = propValue$jscomp$11;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$8 = propValue$jscomp$11;
                        break;
                      case "style":
                        pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                        break;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "ref":
                        break;
                      case "className":
                        attributeName = "class";
                      default:
                        if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                          if (true === propValue$jscomp$11)
                            propValue$jscomp$11 = "";
                          else if ("object" === typeof propValue$jscomp$11)
                            continue;
                          target$jscomp$0.push(
                            attributeSeparator,
                            stringToChunk(attributeName),
                            attributeAssign,
                            stringToChunk(
                              escapeTextForBrowser(propValue$jscomp$11)
                            ),
                            attributeEnd
                          );
                        }
                    }
                  }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$8,
                children$jscomp$11
              );
              return children$jscomp$11;
            }
        }
        return pushStartGenericElement(target$jscomp$0, props, type6);
      }
      __name(pushStartInstance, "pushStartInstance");
      __name2(pushStartInstance, "pushStartInstance");
      function endChunkForTag(tag) {
        var chunk = endTagCache.get(tag);
        void 0 === chunk && (chunk = stringToPrecomputedChunk("</" + tag + ">"), endTagCache.set(tag, chunk));
        return chunk;
      }
      __name(endChunkForTag, "endChunkForTag");
      __name2(endChunkForTag, "endChunkForTag");
      function hoistPreambleState(renderState, preambleState) {
        renderState = renderState.preamble;
        null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
        null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
        null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
      }
      __name(hoistPreambleState, "hoistPreambleState");
      __name2(hoistPreambleState, "hoistPreambleState");
      function writeBootstrap(destination, renderState) {
        renderState = renderState.bootstrapChunks;
        for (var i2 = 0; i2 < renderState.length - 1; i2++)
          writeChunk(destination, renderState[i2]);
        return i2 < renderState.length ? (i2 = renderState[i2], renderState.length = 0, writeChunkAndReturn(destination, i2)) : true;
      }
      __name(writeBootstrap, "writeBootstrap");
      __name2(writeBootstrap, "writeBootstrap");
      function writeStartPendingSuspenseBoundary(destination, renderState, id3) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (null === id3)
          throw Error(
            "An ID must have been assigned before we can complete the boundary."
          );
        writeChunk(destination, renderState.boundaryPrefix);
        writeChunk(destination, stringToChunk(id3.toString(16)));
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      __name(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
      __name2(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
      function writePreambleContribution(destination, preambleState) {
        preambleState = preambleState.contribution;
        preambleState !== NoContribution && (writeChunk(destination, boundaryPreambleContributionChunkStart), writeChunk(destination, stringToChunk("" + preambleState)), writeChunk(destination, boundaryPreambleContributionChunkEnd));
      }
      __name(writePreambleContribution, "writePreambleContribution");
      __name2(writePreambleContribution, "writePreambleContribution");
      function writeStartSegment(destination, renderState, formatContext, id3) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id3.toString(16))), writeChunkAndReturn(destination, startSegmentHTML2);
          case SVG_MODE:
            return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id3.toString(16))), writeChunkAndReturn(destination, startSegmentSVG2);
          case MATHML_MODE:
            return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id3.toString(16))), writeChunkAndReturn(destination, startSegmentMathML2);
          case HTML_TABLE_MODE:
            return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id3.toString(16))), writeChunkAndReturn(destination, startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id3.toString(16))), writeChunkAndReturn(destination, startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id3.toString(16))), writeChunkAndReturn(destination, startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id3.toString(16))), writeChunkAndReturn(destination, startSegmentColGroup2);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeStartSegment, "writeStartSegment");
      __name2(writeStartSegment, "writeStartSegment");
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return writeChunkAndReturn(destination, endSegmentHTML);
          case SVG_MODE:
            return writeChunkAndReturn(destination, endSegmentSVG);
          case MATHML_MODE:
            return writeChunkAndReturn(destination, endSegmentMathML);
          case HTML_TABLE_MODE:
            return writeChunkAndReturn(destination, endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return writeChunkAndReturn(destination, endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return writeChunkAndReturn(destination, endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return writeChunkAndReturn(destination, endSegmentColGroup);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeEndSegment, "writeEndSegment");
      __name2(writeEndSegment, "writeEndSegment");
      function escapeJSStringsForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInInstructionScripts,
          function(match2) {
            switch (match2) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
      __name2(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
      function escapeJSObjectForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInScripts,
          function(match2) {
            switch (match2) {
              case "&":
                return "\\u0026";
              case ">":
                return "\\u003e";
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
      __name2(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
      function flushStyleTagsLateForBoundary(styleQueue) {
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        0 < rules.length && 0 === hrefs.length && console.error(
          "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
        );
        var i2 = 0;
        if (hrefs.length) {
          writeChunk(this, lateStyleTagResourceOpen1);
          writeChunk(this, styleQueue.precedence);
          for (writeChunk(this, lateStyleTagResourceOpen2); i2 < hrefs.length - 1; i2++)
            writeChunk(this, hrefs[i2]), writeChunk(this, spaceSeparator);
          writeChunk(this, hrefs[i2]);
          writeChunk(this, lateStyleTagResourceOpen3);
          for (i2 = 0; i2 < rules.length; i2++)
            writeChunk(this, rules[i2]);
          destinationHasCapacity = writeChunkAndReturn(
            this,
            lateStyleTagTemplateClose
          );
          currentlyRenderingBoundaryHasStylesToHoist = true;
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
      __name2(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
      function hasStylesToHoist(stylesheet) {
        return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
      }
      __name(hasStylesToHoist, "hasStylesToHoist");
      __name2(hasStylesToHoist, "hasStylesToHoist");
      function writeHoistablesForBoundary(destination, hoistableState, renderState) {
        currentlyRenderingBoundaryHasStylesToHoist = false;
        destinationHasCapacity = true;
        hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
        hoistableState.stylesheets.forEach(hasStylesToHoist);
        currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
        return destinationHasCapacity;
      }
      __name(writeHoistablesForBoundary, "writeHoistablesForBoundary");
      __name2(writeHoistablesForBoundary, "writeHoistablesForBoundary");
      function flushResource(resource) {
        for (var i2 = 0; i2 < resource.length; i2++)
          writeChunk(this, resource[i2]);
        resource.length = 0;
      }
      __name(flushResource, "flushResource");
      __name2(flushResource, "flushResource");
      function flushStyleInPreamble(stylesheet) {
        pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
        for (var i2 = 0; i2 < stylesheetFlushingQueue.length; i2++)
          writeChunk(this, stylesheetFlushingQueue[i2]);
        stylesheetFlushingQueue.length = 0;
        stylesheet.state = PREAMBLE;
      }
      __name(flushStyleInPreamble, "flushStyleInPreamble");
      __name2(flushStyleInPreamble, "flushStyleInPreamble");
      function flushStylesInPreamble(styleQueue) {
        var hasStylesheets = 0 < styleQueue.sheets.size;
        styleQueue.sheets.forEach(flushStyleInPreamble, this);
        styleQueue.sheets.clear();
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        if (!hasStylesheets || hrefs.length) {
          writeChunk(this, styleTagResourceOpen1);
          writeChunk(this, styleQueue.precedence);
          styleQueue = 0;
          if (hrefs.length) {
            for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
              writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
            writeChunk(this, hrefs[styleQueue]);
          }
          writeChunk(this, styleTagResourceOpen3);
          for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
            writeChunk(this, rules[styleQueue]);
          writeChunk(this, styleTagResourceClose);
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStylesInPreamble, "flushStylesInPreamble");
      __name2(flushStylesInPreamble, "flushStylesInPreamble");
      function preloadLateStyle(stylesheet) {
        if (stylesheet.state === PENDING$1) {
          stylesheet.state = PRELOADED;
          var props = stylesheet.props;
          pushLinkImpl(stylesheetFlushingQueue, {
            rel: "preload",
            as: "style",
            href: stylesheet.props.href,
            crossOrigin: props.crossOrigin,
            fetchPriority: props.fetchPriority,
            integrity: props.integrity,
            media: props.media,
            hrefLang: props.hrefLang,
            referrerPolicy: props.referrerPolicy
          });
          for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
            writeChunk(this, stylesheetFlushingQueue[stylesheet]);
          stylesheetFlushingQueue.length = 0;
        }
      }
      __name(preloadLateStyle, "preloadLateStyle");
      __name2(preloadLateStyle, "preloadLateStyle");
      function preloadLateStyles(styleQueue) {
        styleQueue.sheets.forEach(preloadLateStyle, this);
        styleQueue.sheets.clear();
      }
      __name(preloadLateStyles, "preloadLateStyles");
      __name2(preloadLateStyles, "preloadLateStyles");
      function writeStyleResourceDependenciesInJS(destination, hoistableState) {
        writeChunk(destination, arrayFirstOpenBracket);
        var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
        hoistableState.stylesheets.forEach(function(resource) {
          if (resource.state !== PREAMBLE)
            if (resource.state === LATE)
              writeChunk(destination, nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), writeChunk(
                destination,
                stringToChunk(
                  escapeJSObjectForInstructionScripts("" + resource)
                )
              ), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
            else {
              writeChunk(destination, nextArrayOpenBrackChunk);
              var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
              writeChunk(
                destination,
                stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))
              );
              checkAttributeStringCoercion(precedence, "precedence");
              precedence = "" + precedence;
              writeChunk(destination, arrayInterstitial);
              writeChunk(
                destination,
                stringToChunk(escapeJSObjectForInstructionScripts(precedence))
              );
              for (var propKey in props)
                if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                  switch (propKey) {
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      writeStyleResourceAttributeInJS(
                        destination,
                        propKey,
                        precedence
                      );
                  }
              writeChunk(destination, arrayCloseBracket);
              nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              resource.state = LATE;
            }
        });
        writeChunk(destination, arrayCloseBracket);
      }
      __name(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
      __name2(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
      function writeStyleResourceAttributeInJS(destination, name, value) {
        var attributeName = name.toLowerCase();
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        switch (name) {
          case "innerHTML":
          case "dangerouslySetInnerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "style":
          case "ref":
            return;
          case "className":
            attributeName = "class";
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          case "hidden":
            if (false === value)
              return;
            name = "";
            break;
          case "src":
          case "href":
            value = sanitizeURL(value);
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          default:
            if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
              return;
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
        }
        writeChunk(destination, arrayInterstitial);
        writeChunk(
          destination,
          stringToChunk(escapeJSObjectForInstructionScripts(attributeName))
        );
        writeChunk(destination, arrayInterstitial);
        writeChunk(
          destination,
          stringToChunk(escapeJSObjectForInstructionScripts(name))
        );
      }
      __name(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
      __name2(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
      function createHoistableState() {
        return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
      }
      __name(createHoistableState, "createHoistableState");
      __name2(createHoistableState, "createHoistableState");
      function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
        (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
          'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
          href
        );
        resumableState.scriptResources[href] = EXISTS;
        resumableState.moduleScriptResources[href] = EXISTS;
        resumableState = [];
        pushLinkImpl(resumableState, props);
        renderState.bootstrapScripts.add(resumableState);
      }
      __name(preloadBootstrapScriptOrModule, "preloadBootstrapScriptOrModule");
      __name2(preloadBootstrapScriptOrModule, "preloadBootstrapScriptOrModule");
      function adoptPreloadCredentials(target, preloadState) {
        null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
        null == target.integrity && (target.integrity = preloadState[1]);
      }
      __name(adoptPreloadCredentials, "adoptPreloadCredentials");
      __name2(adoptPreloadCredentials, "adoptPreloadCredentials");
      function getPreloadAsHeader(href, as, params) {
        href = escapeHrefForLinkHeaderURLContext(href);
        as = escapeStringForLinkHeaderQuotedParamValueContext(as, "as");
        as = "<" + href + '>; rel=preload; as="' + as + '"';
        for (var paramName in params)
          hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
            href,
            paramName
          ) + '"'));
        return as;
      }
      __name(getPreloadAsHeader, "getPreloadAsHeader");
      __name2(getPreloadAsHeader, "getPreloadAsHeader");
      function escapeHrefForLinkHeaderURLContext(hrefInput) {
        checkAttributeStringCoercion(hrefInput, "href");
        return ("" + hrefInput).replace(
          regexForHrefInLinkHeaderURLContext,
          escapeHrefForLinkHeaderURLContextReplacer
        );
      }
      __name(escapeHrefForLinkHeaderURLContext, "escapeHrefForLinkHeaderURLContext");
      __name2(escapeHrefForLinkHeaderURLContext, "escapeHrefForLinkHeaderURLContext");
      function escapeHrefForLinkHeaderURLContextReplacer(match2) {
        switch (match2) {
          case "<":
            return "%3C";
          case ">":
            return "%3E";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
      __name2(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
      function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
        willCoercionThrow(value) && (console.error(
          "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
          name,
          typeName(value)
        ), testStringCoercion(value));
        return ("" + value).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        );
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContext, "escapeStringForLinkHeaderQuotedParamValueContext");
      __name2(escapeStringForLinkHeaderQuotedParamValueContext, "escapeStringForLinkHeaderQuotedParamValueContext");
      function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match2) {
        switch (match2) {
          case '"':
            return "%22";
          case "'":
            return "%27";
          case ";":
            return "%3B";
          case ",":
            return "%2C";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
      __name2(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
      function hoistStyleQueueDependency(styleQueue) {
        this.styles.add(styleQueue);
      }
      __name(hoistStyleQueueDependency, "hoistStyleQueueDependency");
      __name2(hoistStyleQueueDependency, "hoistStyleQueueDependency");
      function hoistStylesheetDependency(stylesheet) {
        this.stylesheets.add(stylesheet);
      }
      __name(hoistStylesheetDependency, "hoistStylesheetDependency");
      __name2(hoistStylesheetDependency, "hoistStylesheetDependency");
      function getComponentNameFromType(type6) {
        if (null == type6)
          return null;
        if ("function" === typeof type6)
          return type6.$$typeof === REACT_CLIENT_REFERENCE ? null : type6.displayName || type6.name || null;
        if ("string" === typeof type6)
          return type6;
        switch (type6) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type6)
          switch ("number" === typeof type6.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type6.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type6.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type6._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type6.render;
              type6 = type6.displayName;
              type6 || (type6 = innerType.displayName || innerType.name || "", type6 = "" !== type6 ? "ForwardRef(" + type6 + ")" : "ForwardRef");
              return type6;
            case REACT_MEMO_TYPE:
              return innerType = type6.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type6.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type6._payload;
              type6 = type6._init;
              try {
                return getComponentNameFromType(type6(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      __name2(getComponentNameFromType, "getComponentNameFromType");
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          prev.context._currentValue = prev.parentValue;
          prev = prev.parent;
          var parentNext = next.parent;
          if (null === prev) {
            if (null !== parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
          } else {
            if (null === parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
            popToNearestCommonAncestor(prev, parentNext);
          }
          next.context._currentValue = next.value;
        }
      }
      __name(popToNearestCommonAncestor, "popToNearestCommonAncestor");
      __name2(popToNearestCommonAncestor, "popToNearestCommonAncestor");
      function popAllPrevious(prev) {
        prev.context._currentValue = prev.parentValue;
        prev = prev.parent;
        null !== prev && popAllPrevious(prev);
      }
      __name(popAllPrevious, "popAllPrevious");
      __name2(popAllPrevious, "popAllPrevious");
      function pushAllNext(next) {
        var parentNext = next.parent;
        null !== parentNext && pushAllNext(parentNext);
        next.context._currentValue = next.value;
      }
      __name(pushAllNext, "pushAllNext");
      __name2(pushAllNext, "pushAllNext");
      function popPreviousToCommonLevel(prev, next) {
        prev.context._currentValue = prev.parentValue;
        prev = prev.parent;
        if (null === prev)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
      }
      __name(popPreviousToCommonLevel, "popPreviousToCommonLevel");
      __name2(popPreviousToCommonLevel, "popPreviousToCommonLevel");
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (null === parentNext)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
        next.context._currentValue = next.value;
      }
      __name(popNextToCommonLevel, "popNextToCommonLevel");
      __name2(popNextToCommonLevel, "popNextToCommonLevel");
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
      }
      __name(switchContext, "switchContext");
      __name2(switchContext, "switchContext");
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      __name(warnOnInvalidCallback, "warnOnInvalidCallback");
      __name2(warnOnInvalidCallback, "warnOnInvalidCallback");
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
          "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
          callerName,
          publicInstance
        ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
      }
      __name(warnNoop, "warnNoop");
      __name2(warnNoop, "warnNoop");
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        baseContext = baseContext.overflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          return {
            id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
            overflow: length + baseContext
          };
        }
        return {
          id: 1 << length | index << baseLength | baseIdWithLeadingBit,
          overflow: baseContext
        };
      }
      __name(pushTreeContext, "pushTreeContext");
      __name2(pushTreeContext, "pushTreeContext");
      function clz32Fallback(x2) {
        x2 >>>= 0;
        return 0 === x2 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
      }
      __name(clz32Fallback, "clz32Fallback");
      __name2(clz32Fallback, "clz32Fallback");
      function noop$2() {
      }
      __name(noop$2, "noop$2");
      __name2(noop$2, "noop$2");
      function trackUsedThenable(thenableState2, thenable, index) {
        index = thenableState2[index];
        void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            ));
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      __name(trackUsedThenable, "trackUsedThenable");
      __name2(trackUsedThenable, "trackUsedThenable");
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      __name(getSuspendedThenable, "getSuspendedThenable");
      __name2(getSuspendedThenable, "getSuspendedThenable");
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      __name(is, "is");
      __name2(is, "is");
      function resolveCurrentlyRenderingComponent() {
        if (null === currentlyRenderingComponent)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        isInHookUserCodeInDev && console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
        return currentlyRenderingComponent;
      }
      __name(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
      __name2(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
      function createHook() {
        if (0 < numberOfReRenders)
          throw Error("Rendered more hooks than during the previous render");
        return { memoizedState: null, queue: null, next: null };
      }
      __name(createHook, "createHook");
      __name2(createHook, "createHook");
      function createWorkInProgressHook() {
        null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
        return workInProgressHook;
      }
      __name(createWorkInProgressHook, "createWorkInProgressHook");
      __name2(createWorkInProgressHook, "createWorkInProgressHook");
      function getThenableStateAfterSuspending() {
        var state = thenableState;
        thenableState = null;
        return state;
      }
      __name(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
      __name2(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
      function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        workInProgressHook = renderPhaseUpdates = null;
      }
      __name(resetHooksState, "resetHooksState");
      __name2(resetHooksState, "resetHooksState");
      function readContext(context) {
        isInHookUserCodeInDev && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return context._currentValue;
      }
      __name(readContext, "readContext");
      __name2(readContext, "readContext");
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      __name(basicStateReducer, "basicStateReducer");
      __name2(basicStateReducer, "basicStateReducer");
      function useReducer3(reducer, initialArg, init2) {
        reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          init2 = workInProgressHook.queue;
          initialArg = init2.dispatch;
          if (null !== renderPhaseUpdates) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(init2);
            if (void 0 !== firstRenderPhaseUpdate) {
              renderPhaseUpdates.delete(init2);
              init2 = workInProgressHook.memoizedState;
              do {
                var action = firstRenderPhaseUpdate.action;
                isInHookUserCodeInDev = true;
                init2 = reducer(init2, action);
                isInHookUserCodeInDev = false;
                firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
              } while (null !== firstRenderPhaseUpdate);
              workInProgressHook.memoizedState = init2;
              return [init2, initialArg];
            }
          }
          return [workInProgressHook.memoizedState, initialArg];
        }
        isInHookUserCodeInDev = true;
        reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init2 ? init2(initialArg) : initialArg;
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = reducer;
        reducer = workInProgressHook.queue = { last: null, dispatch: null };
        reducer = reducer.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingComponent,
          reducer
        );
        return [workInProgressHook.memoizedState, reducer];
      }
      __name(useReducer3, "useReducer3");
      __name2(useReducer3, "useReducer");
      function useMemo14(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        if (null !== workInProgressHook) {
          var prevState = workInProgressHook.memoizedState;
          if (null !== prevState && null !== deps) {
            a: {
              var JSCompiler_inline_result = prevState[1];
              if (null === JSCompiler_inline_result)
                console.error(
                  "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                  currentHookNameInDev
                ), JSCompiler_inline_result = false;
              else {
                deps.length !== JSCompiler_inline_result.length && console.error(
                  "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                  currentHookNameInDev,
                  "[" + deps.join(", ") + "]",
                  "[" + JSCompiler_inline_result.join(", ") + "]"
                );
                for (var i2 = 0; i2 < JSCompiler_inline_result.length && i2 < deps.length; i2++)
                  if (!objectIs(deps[i2], JSCompiler_inline_result[i2])) {
                    JSCompiler_inline_result = false;
                    break a;
                  }
                JSCompiler_inline_result = true;
              }
            }
            if (JSCompiler_inline_result)
              return prevState[0];
          }
        }
        isInHookUserCodeInDev = true;
        nextCreate = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [nextCreate, deps];
        return nextCreate;
      }
      __name(useMemo14, "useMemo14");
      __name2(useMemo14, "useMemo");
      function dispatchAction(componentIdentity, queue, action) {
        if (25 <= numberOfReRenders)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (componentIdentity === currentlyRenderingComponent)
          if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
            renderPhaseUpdates.set(queue, componentIdentity);
          else {
            for (queue = action; null !== queue.next; )
              queue = queue.next;
            queue.next = componentIdentity;
          }
      }
      __name(dispatchAction, "dispatchAction");
      __name2(dispatchAction, "dispatchAction");
      function unsupportedStartTransition() {
        throw Error("startTransition cannot be called during server rendering.");
      }
      __name(unsupportedStartTransition, "unsupportedStartTransition");
      __name2(unsupportedStartTransition, "unsupportedStartTransition");
      function unsupportedSetOptimisticState() {
        throw Error("Cannot update optimistic state while rendering.");
      }
      __name(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
      __name2(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
      function useActionState(action, initialState, permalink) {
        resolveCurrentlyRenderingComponent();
        var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
        if ("function" === typeof action.$$FORM_ACTION) {
          var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
          request = request.formState;
          var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
          if (null !== request && "function" === typeof isSignatureEqual) {
            var postbackKey = request[1];
            isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
          }
          var boundAction = action.bind(null, initialState);
          action = /* @__PURE__ */ __name2(function(payload) {
            boundAction(payload);
          }, "action");
          "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
            prefix2 = boundAction.$$FORM_ACTION(prefix2);
            void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix2.action = permalink);
            var formData = prefix2.data;
            formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            )), formData.append("$ACTION_KEY", nextPostbackStateKey));
            return prefix2;
          });
          return [initialState, action, false];
        }
        var _boundAction = action.bind(null, initialState);
        return [
          initialState,
          function(payload) {
            _boundAction(payload);
          },
          false
        ];
      }
      __name(useActionState, "useActionState");
      __name2(useActionState, "useActionState");
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      __name(unwrapThenable, "unwrapThenable");
      __name2(unwrapThenable, "unwrapThenable");
      function unsupportedRefresh() {
        throw Error("Cache cannot be refreshed during server rendering.");
      }
      __name(unsupportedRefresh, "unsupportedRefresh");
      __name2(unsupportedRefresh, "unsupportedRefresh");
      function noop$1() {
      }
      __name(noop$1, "noop$1");
      __name2(noop$1, "noop$1");
      function disabledLog() {
      }
      __name(disabledLog, "disabledLog");
      __name2(disabledLog, "disabledLog");
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      __name(disableLogs, "disableLogs");
      __name2(disableLogs, "disableLogs");
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      __name(reenableLogs, "reenableLogs");
      __name2(reenableLogs, "reenableLogs");
      function prepareStackTrace(error, structuredStackTrace) {
        error = (error.name || "Error") + ": " + (error.message || "");
        for (var i2 = 0; i2 < structuredStackTrace.length; i2++)
          error += "\n    at " + structuredStackTrace[i2].toString();
        return error;
      }
      __name(prepareStackTrace, "prepareStackTrace");
      __name2(prepareStackTrace, "prepareStackTrace");
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x2) {
            var match2 = x2.stack.trim().match(/\n( *(at )?)/);
            prefix = match2 && match2[1] || "";
            suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
      __name2(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        var frame2 = componentFrameCache.get(fn);
        if (void 0 !== frame2)
          return frame2;
        reentry = true;
        frame2 = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareStackTrace;
        var previousDispatcher2 = null;
        previousDispatcher2 = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = /* @__PURE__ */ __name2(function() {
                    throw Error();
                  }, "Fake");
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x2) {
                      var control = x2;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame2;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      __name(describeNativeComponentFrame, "describeNativeComponentFrame");
      __name2(describeNativeComponentFrame, "describeNativeComponentFrame");
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareStackTrace;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else
          return "";
        return error;
      }
      __name(formatOwnerStack, "formatOwnerStack");
      __name2(formatOwnerStack, "formatOwnerStack");
      function describeComponentStackByType(type6) {
        if ("string" === typeof type6)
          return describeBuiltInComponentFrame(type6);
        if ("function" === typeof type6)
          return type6.prototype && type6.prototype.isReactComponent ? describeNativeComponentFrame(type6, true) : describeNativeComponentFrame(type6, false);
        if ("object" === typeof type6 && null !== type6) {
          switch (type6.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeNativeComponentFrame(type6.render, false);
            case REACT_MEMO_TYPE:
              return describeNativeComponentFrame(type6.type, false);
            case REACT_LAZY_TYPE:
              var lazyComponent = type6, payload = lazyComponent._payload;
              lazyComponent = lazyComponent._init;
              try {
                type6 = lazyComponent(payload);
              } catch (x2) {
                return describeBuiltInComponentFrame("Lazy");
              }
              return describeComponentStackByType(type6);
          }
          if ("string" === typeof type6.name)
            return payload = type6.env, describeBuiltInComponentFrame(
              type6.name + (payload ? " [" + payload + "]" : "")
            );
        }
        switch (type6) {
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
        }
        return "";
      }
      __name(describeComponentStackByType, "describeComponentStackByType");
      __name2(describeComponentStackByType, "describeComponentStackByType");
      function defaultErrorHandler(error) {
        if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
          var JSCompiler_inline_result = error.environmentName;
          error = [error].slice(0);
          "string" === typeof error[0] ? error.splice(
            0,
            1,
            "\x1B[0m\x1B[7m%c%s\x1B[0m%c " + error[0],
            "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
            " " + JSCompiler_inline_result + " ",
            ""
          ) : error.splice(
            0,
            0,
            "\x1B[0m\x1B[7m%c%s\x1B[0m%c ",
            "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
            " " + JSCompiler_inline_result + " ",
            ""
          );
          error.unshift(console);
          JSCompiler_inline_result = bind.apply(console.error, error);
          JSCompiler_inline_result();
        } else
          console.error(error);
        return null;
      }
      __name(defaultErrorHandler, "defaultErrorHandler");
      __name2(defaultErrorHandler, "defaultErrorHandler");
      function noop2() {
      }
      __name(noop2, "noop2");
      __name2(noop2, "noop");
      function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var abortSet = /* @__PURE__ */ new Set();
        this.destination = null;
        this.flushScheduled = false;
        this.resumableState = resumableState;
        this.renderState = renderState;
        this.rootFormatContext = rootFormatContext;
        this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
        this.status = 10;
        this.fatalError = null;
        this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
        this.completedPreambleSegments = this.completedRootSegment = null;
        this.abortableTasks = abortSet;
        this.pingedTasks = [];
        this.clientRenderedBoundaries = [];
        this.completedBoundaries = [];
        this.partialBoundaries = [];
        this.trackedPostpones = null;
        this.onError = void 0 === onError ? defaultErrorHandler : onError;
        this.onPostpone = void 0 === onPostpone ? noop2 : onPostpone;
        this.onAllReady = void 0 === onAllReady ? noop2 : onAllReady;
        this.onShellReady = void 0 === onShellReady ? noop2 : onShellReady;
        this.onShellError = void 0 === onShellError ? noop2 : onShellError;
        this.onFatalError = void 0 === onFatalError ? noop2 : onFatalError;
        this.formState = void 0 === formState ? null : formState;
        this.didWarnForKey = null;
      }
      __name(RequestInstance, "RequestInstance");
      __name2(RequestInstance, "RequestInstance");
      function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var now2 = getCurrentTime();
        1e3 < now2 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now2);
        resumableState = new RequestInstance(
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          formState
        );
        renderState = createPendingSegment(
          resumableState,
          0,
          null,
          rootFormatContext,
          false,
          false
        );
        renderState.parentFlushed = true;
        children = createRenderTask(
          resumableState,
          null,
          children,
          -1,
          null,
          renderState,
          null,
          null,
          resumableState.abortableTasks,
          null,
          rootFormatContext,
          null,
          emptyTreeContext,
          null,
          false,
          emptyContextObject,
          null
        );
        pushComponentStack(children);
        resumableState.pingedTasks.push(children);
        return resumableState;
      }
      __name(createRequest, "createRequest");
      __name2(createRequest, "createRequest");
      function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
        children = createRequest(
          children,
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          void 0
        );
        children.trackedPostpones = {
          workingMap: /* @__PURE__ */ new Map(),
          rootNodes: [],
          rootSlots: null
        };
        return children;
      }
      __name(createPrerenderRequest, "createPrerenderRequest");
      __name2(createPrerenderRequest, "createPrerenderRequest");
      function resolveRequest() {
        if (currentRequest)
          return currentRequest;
        if (supportsRequestStorage) {
          var store = requestStorage.getStore();
          if (store)
            return store;
        }
        return null;
      }
      __name(resolveRequest, "resolveRequest");
      __name2(resolveRequest, "resolveRequest");
      function pingTask(request, task) {
        request.pingedTasks.push(task);
        1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {
          return performWork(request);
        }) : setTimeout(function() {
          return performWork(request);
        }, 0));
      }
      __name(pingTask, "pingTask");
      __name2(pingTask, "pingTask");
      function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
        return {
          status: PENDING,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
          contentState: createHoistableState(),
          fallbackState: createHoistableState(),
          contentPreamble,
          fallbackPreamble,
          trackedContentKeyPath: null,
          trackedFallbackNode: null,
          errorMessage: null,
          errorStack: null,
          errorComponentStack: null
        };
      }
      __name(createSuspenseBoundary, "createSuspenseBoundary");
      __name2(createSuspenseBoundary, "createSuspenseBoundary");
      function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          replay: null,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          blockedPreamble,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createRenderTask, "createRenderTask");
      __name2(createRenderTask, "createRenderTask");
      function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        replay.pendingTasks++;
        var task = {
          replay,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment: null,
          blockedPreamble: null,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createReplayTask, "createReplayTask");
      __name2(createReplayTask, "createReplayTask");
      function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          parentFlushed: false,
          id: -1,
          index,
          chunks: [],
          children: [],
          preambleChildren: [],
          parentFormatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      __name(createPendingSegment, "createPendingSegment");
      __name2(createPendingSegment, "createPendingSegment");
      function getCurrentStackInDEV() {
        if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
          return "";
        var componentStack = currentTaskInDEV.componentStack;
        try {
          var info = "";
          if ("string" === typeof componentStack.type)
            info += describeBuiltInComponentFrame(componentStack.type);
          else if ("function" === typeof componentStack.type) {
            if (!componentStack.owner) {
              var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
              var JSCompiler_inline_result = name ? describeBuiltInComponentFrame(name) : "";
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          } else
            componentStack.owner || (info += describeComponentStackByType(componentStack.type));
          for (; componentStack; )
            JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
              componentStack.debugStack
            ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
              JSCompiler_inline_result.stack
            ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
          var JSCompiler_inline_result$jscomp$0 = info;
        } catch (x2) {
          JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x2.message + "\n" + x2.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
      }
      __name(getCurrentStackInDEV, "getCurrentStackInDEV");
      __name2(getCurrentStackInDEV, "getCurrentStackInDEV");
      function pushServerComponentStack(task, debugInfo) {
        if (null != debugInfo)
          for (var i2 = 0; i2 < debugInfo.length; i2++) {
            var componentInfo = debugInfo[i2];
            "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
              parent: task.componentStack,
              type: componentInfo,
              owner: componentInfo.owner,
              stack: componentInfo.debugStack
            }, task.debugTask = componentInfo.debugTask);
          }
      }
      __name(pushServerComponentStack, "pushServerComponentStack");
      __name2(pushServerComponentStack, "pushServerComponentStack");
      function pushComponentStack(task) {
        var node = task.node;
        if ("object" === typeof node && null !== node)
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type6 = node.type, owner = node._owner, stack = node._debugStack;
              pushServerComponentStack(task, node._debugInfo);
              task.debugTask = node._debugTask;
              task.componentStack = {
                parent: task.componentStack,
                type: type6,
                owner,
                stack
              };
              break;
            case REACT_LAZY_TYPE:
              pushServerComponentStack(task, node._debugInfo);
              break;
            default:
              "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
          }
      }
      __name(pushComponentStack, "pushComponentStack");
      __name2(pushComponentStack, "pushComponentStack");
      function getThrownInfo(node$jscomp$0) {
        var errorInfo = {};
        node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
          configurable: true,
          enumerable: true,
          get: function() {
            try {
              var info = "", node = node$jscomp$0;
              do
                info += describeComponentStackByType(node.type), node = node.parent;
              while (node);
              var stack = info;
            } catch (x2) {
              stack = "\nError generating stack: " + x2.message + "\n" + x2.stack;
            }
            Object.defineProperty(errorInfo, "componentStack", {
              value: stack
            });
            return stack;
          }
        });
        return errorInfo;
      }
      __name(getThrownInfo, "getThrownInfo");
      __name2(getThrownInfo, "getThrownInfo");
      function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
        boundary.errorDigest = digest;
        error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
        wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
        boundary.errorMessage = wasAborted + digest;
        boundary.errorStack = null !== error ? wasAborted + error : null;
        boundary.errorComponentStack = thrownInfo.componentStack;
      }
      __name(encodeErrorForBoundary, "encodeErrorForBoundary");
      __name2(encodeErrorForBoundary, "encodeErrorForBoundary");
      function logRecoverableError(request, error, errorInfo, debugTask) {
        request = request.onError;
        error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
        if (null != error && "string" !== typeof error)
          console.error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
            typeof error
          );
        else
          return error;
      }
      __name(logRecoverableError, "logRecoverableError");
      __name2(logRecoverableError, "logRecoverableError");
      function fatalError(request, error, errorInfo, debugTask) {
        errorInfo = request.onShellError;
        var onFatalError = request.onFatalError;
        debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
        null !== request.destination ? (request.status = CLOSED, closeWithError(request.destination, error)) : (request.status = 13, request.fatalError = error);
      }
      __name(fatalError, "fatalError");
      __name2(fatalError, "fatalError");
      function renderWithHooks(request, task, keyPath, Component3, props, secondArg) {
        var prevThenableState = task.thenableState;
        task.thenableState = null;
        currentlyRenderingComponent = {};
        currentlyRenderingTask = task;
        currentlyRenderingRequest = request;
        currentlyRenderingKeyPath = keyPath;
        isInHookUserCodeInDev = false;
        actionStateCounter = localIdCounter = 0;
        actionStateMatchingIndex = -1;
        thenableIndexCounter = 0;
        thenableState = prevThenableState;
        for (request = callComponentInDEV(Component3, props, secondArg); didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component3(props, secondArg);
        resetHooksState();
        return request;
      }
      __name(renderWithHooks, "renderWithHooks");
      __name2(renderWithHooks, "renderWithHooks");
      function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
        var didEmitActionStateMarkers = false;
        if (0 !== actionStateCount && null !== request.formState) {
          var segment = task.blockedSegment;
          if (null !== segment) {
            didEmitActionStateMarkers = true;
            segment = segment.chunks;
            for (var i2 = 0; i2 < actionStateCount; i2++)
              i2 === actionStateMatchingIndex2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);
          }
        }
        actionStateCount = task.keyPath;
        task.keyPath = keyPath;
        hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
        task.keyPath = actionStateCount;
      }
      __name(finishFunctionComponent, "finishFunctionComponent");
      __name2(finishFunctionComponent, "finishFunctionComponent");
      function renderElement(request, task, keyPath, type6, props, ref) {
        if ("function" === typeof type6)
          if (type6.prototype && type6.prototype.isReactComponent) {
            var newProps = props;
            if ("ref" in props) {
              newProps = {};
              for (var propName in props)
                "ref" !== propName && (newProps[propName] = props[propName]);
            }
            var defaultProps = type6.defaultProps;
            if (defaultProps) {
              newProps === props && (newProps = assign({}, newProps, props));
              for (var _propName in defaultProps)
                void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
            }
            var resolvedProps = newProps;
            var context = emptyContextObject, contextType = type6.contextType;
            if ("contextType" in type6 && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type6)) {
              didWarnAboutInvalidateContextType.add(type6);
              var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              console.error(
                "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                getComponentNameFromType(type6) || "Component",
                addendum
              );
            }
            "object" === typeof contextType && null !== contextType && (context = contextType._currentValue);
            var instance = new type6(resolvedProps, context);
            if ("function" === typeof type6.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
              var componentName = getComponentNameFromType(type6) || "Component";
              didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                componentName,
                null === instance.state ? "null" : "undefined",
                componentName
              ));
            }
            if ("function" === typeof type6.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
              var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
              "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
              "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
              "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                var _componentName = getComponentNameFromType(type6) || "Component", newApiName = "function" === typeof type6.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                  _componentName
                ), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _componentName,
                  newApiName,
                  null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                  null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            var name = getComponentNameFromType(type6) || "Component";
            instance.render || (type6.prototype && "function" === typeof type6.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              name
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              name
            ));
            !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              name
            );
            instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              name
            );
            instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              name
            );
            type6.childContextTypes && !didWarnAboutChildContextTypes.has(type6) && (didWarnAboutChildContextTypes.add(type6), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              name
            ));
            type6.contextTypes && !didWarnAboutContextTypes$1.has(type6) && (didWarnAboutContextTypes$1.add(type6), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              name
            ));
            "function" === typeof instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              name
            );
            type6.prototype && type6.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(type6) || "A pure component"
            );
            "function" === typeof instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              name
            );
            "function" === typeof instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              name
            );
            "function" === typeof instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              name
            );
            "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              name
            );
            var hasMutatedProps = instance.props !== resolvedProps;
            void 0 !== instance.props && hasMutatedProps && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name
            );
            instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              name,
              name
            );
            "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type6) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type6), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(type6)
            ));
            "function" === typeof instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof type6.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              name
            );
            var state = instance.state;
            state && ("object" !== typeof state || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name);
            "function" === typeof instance.getChildContext && "object" !== typeof type6.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              name
            );
            var initialState = void 0 !== instance.state ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = resolvedProps;
            instance.state = initialState;
            var internalInstance = { queue: [], replace: false };
            instance._reactInternals = internalInstance;
            var contextType$jscomp$0 = type6.contextType;
            instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue : emptyContextObject;
            if (instance.state === resolvedProps) {
              var componentName$jscomp$0 = getComponentNameFromType(type6) || "Component";
              didWarnAboutDirectlyAssigningPropsToState.has(
                componentName$jscomp$0
              ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                componentName$jscomp$0
              ), console.error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName$jscomp$0
              ));
            }
            var getDerivedStateFromProps = type6.getDerivedStateFromProps;
            if ("function" === typeof getDerivedStateFromProps) {
              var partialState = getDerivedStateFromProps(
                resolvedProps,
                initialState
              );
              if (void 0 === partialState) {
                var componentName$jscomp$1 = getComponentNameFromType(type6) || "Component";
                didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                  "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                  componentName$jscomp$1
                ));
              }
              var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign({}, initialState, partialState);
              instance.state = JSCompiler_inline_result;
            }
            if ("function" !== typeof type6.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
              var oldState = instance.state;
              if ("function" === typeof instance.componentWillMount) {
                if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                  var componentName$jscomp$2 = getComponentNameFromType(type6) || "Unknown";
                  didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName$jscomp$2
                  ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                }
                instance.componentWillMount();
              }
              "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
              oldState !== instance.state && (console.error(
                "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                getComponentNameFromType(type6) || "Component"
              ), classComponentUpdater.enqueueReplaceState(
                instance,
                instance.state,
                null
              ));
              if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                internalInstance.queue = null;
                internalInstance.replace = false;
                if (oldReplace && 1 === oldQueue.length)
                  instance.state = oldQueue[0];
                else {
                  for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2], partialState$jscomp$0 = "function" === typeof partial ? partial.call(
                      instance,
                      nextState,
                      resolvedProps,
                      void 0
                    ) : partial;
                    null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign(
                      {},
                      nextState,
                      partialState$jscomp$0
                    )) : assign(nextState, partialState$jscomp$0));
                  }
                  instance.state = nextState;
                }
              } else
                internalInstance.queue = null;
            }
            var nextChildren = callRenderInDEV(instance);
            if (12 === request.status)
              throw null;
            instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
              "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
              getComponentNameFromType(type6) || "a component"
            ), didWarnAboutReassigningProps = true);
            var prevKeyPath = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, nextChildren, -1);
            task.keyPath = prevKeyPath;
          } else {
            if (type6.prototype && "function" === typeof type6.prototype.render) {
              var componentName$jscomp$3 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName$jscomp$3,
                componentName$jscomp$3
              ), didWarnAboutBadClass[componentName$jscomp$3] = true);
            }
            var value = renderWithHooks(
              request,
              task,
              keyPath,
              type6,
              props,
              void 0
            );
            if (12 === request.status)
              throw null;
            var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
            if (type6.contextTypes) {
              var _componentName$jscomp$0 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                _componentName$jscomp$0
              ));
            }
            type6 && type6.childContextTypes && console.error(
              "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
              type6.displayName || type6.name || "Component"
            );
            if ("function" === typeof type6.getDerivedStateFromProps) {
              var _componentName2 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] || (console.error(
                "%s: Function components do not support getDerivedStateFromProps.",
                _componentName2
              ), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true);
            }
            if ("object" === typeof type6.contextType && null !== type6.contextType) {
              var _componentName3 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutContextTypeOnFunctionComponent[_componentName3] || (console.error(
                "%s: Function components do not support contextType.",
                _componentName3
              ), didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true);
            }
            finishFunctionComponent(
              request,
              task,
              keyPath,
              value,
              hasId,
              actionStateCount,
              actionStateMatchingIndex$jscomp$0
            );
          }
        else if ("string" === typeof type6) {
          var segment = task.blockedSegment;
          if (null === segment) {
            var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
            task.formatContext = getChildFormatContext(prevContext, type6, props);
            task.keyPath = keyPath;
            renderNode(request, task, children, -1);
            task.formatContext = prevContext;
            task.keyPath = prevKeyPath$jscomp$0;
          } else {
            var _children = pushStartInstance(
              segment.chunks,
              type6,
              props,
              request.resumableState,
              request.renderState,
              task.blockedPreamble,
              task.hoistableState,
              task.formatContext,
              segment.lastPushedText,
              task.isFallback
            );
            segment.lastPushedText = false;
            var _prevContext = task.formatContext, _prevKeyPath2 = task.keyPath;
            task.keyPath = keyPath;
            if ((task.formatContext = getChildFormatContext(
              _prevContext,
              type6,
              props
            )).insertionMode === HTML_HEAD_MODE) {
              var preambleSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              segment.preambleChildren.push(preambleSegment);
              var preambleTask = createRenderTask(
                request,
                null,
                _children,
                -1,
                task.blockedBoundary,
                preambleSegment,
                task.blockedPreamble,
                task.hoistableState,
                request.abortableTasks,
                task.keyPath,
                task.formatContext,
                task.context,
                task.treeContext,
                task.componentStack,
                task.isFallback,
                emptyContextObject,
                task.debugTask
              );
              pushComponentStack(preambleTask);
              request.pingedTasks.push(preambleTask);
            } else
              renderNode(request, task, _children, -1);
            task.formatContext = _prevContext;
            task.keyPath = _prevKeyPath2;
            a: {
              var target = segment.chunks, resumableState = request.resumableState;
              switch (type6) {
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                  break a;
                case "body":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) {
                    resumableState.hasBody = true;
                    break a;
                  }
                  break;
                case "html":
                  if (_prevContext.insertionMode === ROOT_HTML_MODE) {
                    resumableState.hasHtml = true;
                    break a;
                  }
                  break;
                case "head":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE)
                    break a;
              }
              target.push(endChunkForTag(type6));
            }
            segment.lastPushedText = false;
          }
        } else {
          switch (type6) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
              var prevKeyPath$jscomp$1 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = prevKeyPath$jscomp$1;
              return;
            case REACT_ACTIVITY_TYPE:
              if ("hidden" !== props.mode) {
                var prevKeyPath$jscomp$2 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$2;
              }
              return;
            case REACT_SUSPENSE_LIST_TYPE:
              var _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = _prevKeyPath3;
              return;
            case REACT_VIEW_TRANSITION_TYPE:
            case REACT_SCOPE_TYPE:
              throw Error(
                "ReactDOMServer does not yet support scope components."
              );
            case REACT_SUSPENSE_TYPE:
              a:
                if (null !== task.replay) {
                  var _prevKeyPath = task.keyPath;
                  task.keyPath = keyPath;
                  var _content = props.children;
                  try {
                    renderNode(request, task, _content, -1);
                  } finally {
                    task.keyPath = _prevKeyPath;
                  }
                } else {
                  var prevKeyPath$jscomp$3 = task.keyPath, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                  var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                    request,
                    fallbackAbortSet,
                    createPreambleState(),
                    createPreambleState()
                  ) : createSuspenseBoundary(
                    request,
                    fallbackAbortSet,
                    null,
                    null
                  );
                  null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                  var boundarySegment = createPendingSegment(
                    request,
                    parentSegment.chunks.length,
                    newBoundary,
                    task.formatContext,
                    false,
                    false
                  );
                  parentSegment.children.push(boundarySegment);
                  parentSegment.lastPushedText = false;
                  var contentRootSegment = createPendingSegment(
                    request,
                    0,
                    null,
                    task.formatContext,
                    false,
                    false
                  );
                  contentRootSegment.parentFlushed = true;
                  if (null !== request.trackedPostpones) {
                    var fallbackKeyPath = [
                      keyPath[0],
                      "Suspense Fallback",
                      keyPath[2]
                    ], fallbackReplayNode = [
                      fallbackKeyPath[1],
                      fallbackKeyPath[2],
                      [],
                      null
                    ];
                    request.trackedPostpones.workingMap.set(
                      fallbackKeyPath,
                      fallbackReplayNode
                    );
                    newBoundary.trackedFallbackNode = fallbackReplayNode;
                    task.blockedSegment = boundarySegment;
                    task.blockedPreamble = newBoundary.fallbackPreamble;
                    task.keyPath = fallbackKeyPath;
                    boundarySegment.status = 6;
                    try {
                      renderNode(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = COMPLETED;
                    } catch (thrownValue) {
                      throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                    } finally {
                      task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
                    }
                    var suspendedPrimaryTask = createRenderTask(
                      request,
                      null,
                      content,
                      -1,
                      newBoundary,
                      contentRootSegment,
                      newBoundary.contentPreamble,
                      newBoundary.contentState,
                      task.abortSet,
                      keyPath,
                      task.formatContext,
                      task.context,
                      task.treeContext,
                      task.componentStack,
                      task.isFallback,
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedPrimaryTask);
                    request.pingedTasks.push(suspendedPrimaryTask);
                  } else {
                    task.blockedBoundary = newBoundary;
                    task.blockedPreamble = newBoundary.contentPreamble;
                    task.hoistableState = newBoundary.contentState;
                    task.blockedSegment = contentRootSegment;
                    task.keyPath = keyPath;
                    contentRootSegment.status = 6;
                    try {
                      if (renderNode(request, task, content, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                        newBoundary.status = COMPLETED;
                        0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                        break a;
                      }
                    } catch (thrownValue$2) {
                      newBoundary.status = CLIENT_RENDERED;
                      if (12 === request.status) {
                        contentRootSegment.status = 3;
                        var error = request.fatalError;
                      } else
                        contentRootSegment.status = 4, error = thrownValue$2;
                      var thrownInfo = getThrownInfo(task.componentStack);
                      var errorDigest = logRecoverableError(
                        request,
                        error,
                        thrownInfo,
                        task.debugTask
                      );
                      encodeErrorForBoundary(
                        newBoundary,
                        errorDigest,
                        error,
                        thrownInfo,
                        false
                      );
                      untrackBoundary(request, newBoundary);
                    } finally {
                      task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
                    }
                    var suspendedFallbackTask = createRenderTask(
                      request,
                      null,
                      fallback,
                      -1,
                      parentBoundary,
                      boundarySegment,
                      newBoundary.fallbackPreamble,
                      newBoundary.fallbackState,
                      fallbackAbortSet,
                      [keyPath[0], "Suspense Fallback", keyPath[2]],
                      task.formatContext,
                      task.context,
                      task.treeContext,
                      task.componentStack,
                      true,
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedFallbackTask);
                    request.pingedTasks.push(suspendedFallbackTask);
                  }
                }
              return;
          }
          if ("object" === typeof type6 && null !== type6)
            switch (type6.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                if ("ref" in props) {
                  var propsWithoutRef = {};
                  for (var key in props)
                    "ref" !== key && (propsWithoutRef[key] = props[key]);
                } else
                  propsWithoutRef = props;
                var children$jscomp$0 = renderWithHooks(
                  request,
                  task,
                  keyPath,
                  type6.render,
                  propsWithoutRef,
                  ref
                );
                finishFunctionComponent(
                  request,
                  task,
                  keyPath,
                  children$jscomp$0,
                  0 !== localIdCounter,
                  actionStateCounter,
                  actionStateMatchingIndex
                );
                return;
              case REACT_MEMO_TYPE:
                renderElement(request, task, keyPath, type6.type, props, ref);
                return;
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE:
                var value$jscomp$0 = props.value, children$jscomp$1 = props.children;
                var prevSnapshot = task.context;
                var prevKeyPath$jscomp$4 = task.keyPath;
                var prevValue = type6._currentValue;
                type6._currentValue = value$jscomp$0;
                void 0 !== type6._currentRenderer && null !== type6._currentRenderer && type6._currentRenderer !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type6._currentRenderer = rendererSigil;
                var prevNode = currentActiveSnapshot, newNode = {
                  parent: prevNode,
                  depth: null === prevNode ? 0 : prevNode.depth + 1,
                  context: type6,
                  parentValue: prevValue,
                  value: value$jscomp$0
                };
                currentActiveSnapshot = newNode;
                task.context = newNode;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, children$jscomp$1, -1);
                var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                if (null === prevSnapshot$jscomp$0)
                  throw Error(
                    "Tried to pop a Context at the root of the app. This is a bug in React."
                  );
                prevSnapshot$jscomp$0.context !== type6 && console.error(
                  "The parent context is not the expected context. This is probably a bug in React."
                );
                prevSnapshot$jscomp$0.context._currentValue = prevSnapshot$jscomp$0.parentValue;
                void 0 !== type6._currentRenderer && null !== type6._currentRenderer && type6._currentRenderer !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type6._currentRenderer = rendererSigil;
                var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                task.context = JSCompiler_inline_result$jscomp$0;
                task.keyPath = prevKeyPath$jscomp$4;
                prevSnapshot !== task.context && console.error(
                  "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                );
                return;
              case REACT_CONSUMER_TYPE:
                var context$jscomp$0 = type6._context, render = props.children;
                "function" !== typeof render && console.error(
                  "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                );
                var newChildren = render(context$jscomp$0._currentValue), prevKeyPath$jscomp$5 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, newChildren, -1);
                task.keyPath = prevKeyPath$jscomp$5;
                return;
              case REACT_LAZY_TYPE:
                var Component3 = callLazyInitInDEV(type6);
                if (12 === request.status)
                  throw null;
                renderElement(request, task, keyPath, Component3, props, ref);
                return;
            }
          var info = "";
          if (void 0 === type6 || "object" === typeof type6 && null !== type6 && 0 === Object.keys(type6).length)
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          throw Error(
            "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type6 ? type6 : typeof type6) + "." + info)
          );
        }
      }
      __name(renderElement, "renderElement");
      __name2(renderElement, "renderElement");
      function resumeNode(request, task, segmentId, node, childIndex) {
        var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
          request,
          0,
          null,
          task.formatContext,
          false,
          false
        );
        resumedSegment.id = segmentId;
        resumedSegment.parentFlushed = true;
        try {
          task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
        } finally {
          task.replay = prevReplay, task.blockedSegment = null;
        }
      }
      __name(resumeNode, "resumeNode");
      __name2(resumeNode, "resumeNode");
      function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type6, props, ref, replay) {
        childIndex = replay.nodes;
        for (var i2 = 0; i2 < childIndex.length; i2++) {
          var node = childIndex[i2];
          if (keyOrIndex === node[1]) {
            if (4 === node.length) {
              if (null !== name && name !== node[0])
                throw Error(
                  "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering."
                );
              var childNodes = node[2];
              node = node[3];
              name = task.node;
              task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
              try {
                renderElement(request, task, keyPath, type6, props, ref);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x2) {
                if ("object" === typeof x2 && null !== x2 && (x2 === SuspenseException || "function" === typeof x2.then))
                  throw task.node === name && (task.replay = replay), x2;
                task.replay.pendingTasks--;
                type6 = getThrownInfo(task.componentStack);
                props = request;
                request = task.blockedBoundary;
                keyPath = x2;
                ref = node;
                node = logRecoverableError(props, keyPath, type6, task.debugTask);
                abortRemainingReplayNodes(
                  props,
                  request,
                  childNodes,
                  ref,
                  keyPath,
                  node,
                  type6,
                  false
                );
              }
              task.replay = replay;
            } else {
              if (type6 !== REACT_SUSPENSE_TYPE)
                throw Error(
                  "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type6) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                );
              a: {
                replay = void 0;
                type6 = node[5];
                ref = node[2];
                name = node[3];
                keyOrIndex = null === node[4] ? [] : node[4][2];
                node = null === node[4] ? null : node[4][3];
                var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                props.parentFlushed = true;
                props.rootSegmentID = type6;
                task.blockedBoundary = props;
                task.hoistableState = props.contentState;
                task.keyPath = keyPath;
                task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
                try {
                  renderNode(request, task, content, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  if (0 === props.pendingTasks && props.status === PENDING) {
                    props.status = COMPLETED;
                    request.completedBoundaries.push(props);
                    break a;
                  }
                } catch (error) {
                  props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                    request,
                    error,
                    childNodes,
                    task.debugTask
                  ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                } finally {
                  task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                }
                props = createReplayTask(
                  request,
                  null,
                  { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                  fallback,
                  -1,
                  parentBoundary,
                  props.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true,
                  emptyContextObject,
                  task.debugTask
                );
                pushComponentStack(props);
                request.pingedTasks.push(props);
              }
            }
            childIndex.splice(i2, 1);
            break;
          }
        }
      }
      __name(replayElement, "replayElement");
      __name2(replayElement, "replayElement");
      function renderNodeDestructive(request, task, node, childIndex) {
        null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
      }
      __name(renderNodeDestructive, "renderNodeDestructive");
      __name2(renderNodeDestructive, "renderNodeDestructive");
      function retryNode(request, task) {
        var node = task.node, childIndex = task.childIndex;
        if (null !== node) {
          if ("object" === typeof node) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type6 = node.type, key = node.key;
                node = node.props;
                var refProp = node.ref;
                refProp = void 0 !== refProp ? refProp : null;
                var debugTask = task.debugTask, name = getComponentNameFromType(type6);
                key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                var keyPath = [task.keyPath, name, key];
                null !== task.replay ? debugTask ? debugTask.run(
                  replayElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    name,
                    key,
                    childIndex,
                    type6,
                    node,
                    refProp,
                    task.replay
                  )
                ) : replayElement(
                  request,
                  task,
                  keyPath,
                  name,
                  key,
                  childIndex,
                  type6,
                  node,
                  refProp,
                  task.replay
                ) : debugTask ? debugTask.run(
                  renderElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    type6,
                    node,
                    refProp
                  )
                ) : renderElement(request, task, keyPath, type6, node, refProp);
                return;
              case REACT_PORTAL_TYPE:
                throw Error(
                  "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                );
              case REACT_LAZY_TYPE:
                node = callLazyInitInDEV(node);
                if (12 === request.status)
                  throw null;
                renderNodeDestructive(request, task, node, childIndex);
                return;
            }
            if (isArrayImpl(node)) {
              renderChildrenArray(request, task, node, childIndex);
              return;
            }
            null === node || "object" !== typeof node ? key = null : (type6 = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], key = "function" === typeof type6 ? type6 : null);
            if (key && (type6 = key.call(node))) {
              if (type6 === node) {
                if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(type6))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                node.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              node = type6.next();
              if (!node.done) {
                key = [];
                do
                  key.push(node.value), node = type6.next();
                while (!node.done);
                renderChildrenArray(request, task, key, childIndex);
              }
              return;
            }
            if ("function" === typeof node.then)
              return task.thenableState = null, renderNodeDestructive(
                request,
                task,
                unwrapThenable(node),
                childIndex
              );
            if (node.$$typeof === REACT_CONTEXT_TYPE)
              return renderNodeDestructive(
                request,
                task,
                node._currentValue,
                childIndex
              );
            request = Object.prototype.toString.call(node);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            node,
            request.renderState,
            task.lastPushedText
          ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            "" + node,
            request.renderState,
            task.lastPushedText
          ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
            request,
            request
          )), "symbol" === typeof node && console.error(
            "Symbols are not valid as a React child.\n  %s",
            String(node)
          ));
        }
      }
      __name(retryNode, "retryNode");
      __name2(retryNode, "retryNode");
      function renderChildrenArray(request, task, children, childIndex) {
        var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
        var previousDebugTask = task.debugTask;
        pushServerComponentStack(task, task.node._debugInfo);
        if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
          for (var replay = task.replay, replayNodes = replay.nodes, j2 = 0; j2 < replayNodes.length; j2++) {
            var node = replayNodes[j2];
            if (node[1] === childIndex) {
              childIndex = node[2];
              node = node[3];
              task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
              try {
                renderChildrenArray(request, task, children, -1);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x2) {
                if ("object" === typeof x2 && null !== x2 && (x2 === SuspenseException || "function" === typeof x2.then))
                  throw x2;
                task.replay.pendingTasks--;
                var thrownInfo = getThrownInfo(task.componentStack);
                children = task.blockedBoundary;
                var error = x2, resumeSlots = node;
                node = logRecoverableError(
                  request,
                  error,
                  thrownInfo,
                  task.debugTask
                );
                abortRemainingReplayNodes(
                  request,
                  children,
                  childIndex,
                  resumeSlots,
                  error,
                  node,
                  thrownInfo,
                  false
                );
              }
              task.replay = replay;
              replayNodes.splice(j2, 1);
              break;
            }
          }
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        replay = task.treeContext;
        replayNodes = children.length;
        if (null !== task.replay && (j2 = task.replay.slots, null !== j2 && "object" === typeof j2)) {
          for (childIndex = 0; childIndex < replayNodes; childIndex++)
            node = children[childIndex], task.treeContext = pushTreeContext(
              replay,
              replayNodes,
              childIndex
            ), error = j2[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j2[childIndex]) : renderNode(request, task, node, childIndex);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        for (j2 = 0; j2 < replayNodes; j2++) {
          childIndex = children[j2];
          resumeSlots = request;
          node = task;
          error = childIndex;
          if (null !== error && "object" === typeof error && (error.$$typeof === REACT_ELEMENT_TYPE || error.$$typeof === REACT_PORTAL_TYPE) && error._store && (!error._store.validated && null == error.key || 2 === error._store.validated)) {
            if ("object" !== typeof error._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            error._store.validated = 1;
            thrownInfo = resumeSlots.didWarnForKey;
            null == thrownInfo && (thrownInfo = resumeSlots.didWarnForKey = /* @__PURE__ */ new WeakSet());
            resumeSlots = node.componentStack;
            if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {
              thrownInfo.add(resumeSlots);
              var componentName = getComponentNameFromType(error.type);
              thrownInfo = error._owner;
              var parentOwner = resumeSlots.owner;
              resumeSlots = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name = getComponentNameFromType(parentOwner.type);
                name && (resumeSlots = "\n\nCheck the render method of `" + name + "`.");
              }
              resumeSlots || componentName && (resumeSlots = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != thrownInfo && parentOwner !== thrownInfo && (parentOwner = null, "undefined" !== typeof thrownInfo.type ? parentOwner = getComponentNameFromType(thrownInfo.type) : "string" === typeof thrownInfo.name && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              thrownInfo = node.componentStack;
              node.componentStack = {
                parent: node.componentStack,
                type: error.type,
                owner: error._owner,
                stack: error._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                resumeSlots,
                componentName
              );
              node.componentStack = thrownInfo;
            }
          }
          task.treeContext = pushTreeContext(replay, replayNodes, j2);
          renderNode(request, task, childIndex, j2);
        }
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
      }
      __name(renderChildrenArray, "renderChildrenArray");
      __name2(renderChildrenArray, "renderChildrenArray");
      function untrackBoundary(request, boundary) {
        request = request.trackedPostpones;
        null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
      }
      __name(untrackBoundary, "untrackBoundary");
      __name2(untrackBoundary, "untrackBoundary");
      function spawnNewSuspendedReplayTask(request, task, thenableState2) {
        return createReplayTask(
          request,
          thenableState2,
          task.replay,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
      __name2(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
      function spawnNewSuspendedRenderTask(request, task, thenableState2) {
        var segment = task.blockedSegment, newSegment = createPendingSegment(
          request,
          segment.chunks.length,
          null,
          task.formatContext,
          segment.lastPushedText,
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        return createRenderTask(
          request,
          thenableState2,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          newSegment,
          task.blockedPreamble,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
      __name2(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
      function renderNode(request, task, node, childIndex) {
        var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
        if (null === segment)
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue) {
            if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedReplayTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedReplayTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        else {
          var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue$3) {
            if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedRenderTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedRenderTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        }
        task.formatContext = previousFormatContext;
        task.context = previousContext;
        task.keyPath = previousKeyPath;
        task.treeContext = previousTreeContext;
        switchContext(previousContext);
        throw node;
      }
      __name(renderNode, "renderNode");
      __name2(renderNode, "renderNode");
      function abortTaskSoft(task) {
        var boundary = task.blockedBoundary;
        task = task.blockedSegment;
        null !== task && (task.status = 3, finishedTask(this, boundary, task));
      }
      __name(abortTaskSoft, "abortTaskSoft");
      __name2(abortTaskSoft, "abortTaskSoft");
      function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
        for (var i2 = 0; i2 < nodes.length; i2++) {
          var node = nodes[i2];
          if (4 === node.length)
            abortRemainingReplayNodes(
              request$jscomp$0,
              boundary,
              node[2],
              node[3],
              error$jscomp$0,
              errorDigest$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            );
          else {
            var request = request$jscomp$0;
            node = node[5];
            var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
              request,
              /* @__PURE__ */ new Set(),
              null,
              null
            );
            resumedBoundary.parentFlushed = true;
            resumedBoundary.rootSegmentID = node;
            resumedBoundary.status = CLIENT_RENDERED;
            encodeErrorForBoundary(
              resumedBoundary,
              errorDigest,
              error,
              errorInfo,
              wasAborted
            );
            resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
          }
        }
        nodes.length = 0;
        if (null !== slots) {
          if (null === boundary)
            throw Error(
              "We should not have any resumable nodes in the shell. This is a bug in React."
            );
          boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
            boundary,
            errorDigest$jscomp$0,
            error$jscomp$0,
            errorInfo$jscomp$0,
            aborted
          ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
          if ("object" === typeof slots)
            for (var index in slots)
              delete slots[index];
        }
      }
      __name(abortRemainingReplayNodes, "abortRemainingReplayNodes");
      __name2(abortRemainingReplayNodes, "abortRemainingReplayNodes");
      function abortTask(task, request, error) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (null !== segment) {
          if (6 === segment.status)
            return;
          segment.status = 3;
        }
        segment = getThrownInfo(task.componentStack);
        if (null === boundary) {
          if (13 !== request.status && request.status !== CLOSED) {
            boundary = task.replay;
            if (null === boundary) {
              logRecoverableError(request, error, segment, null);
              fatalError(request, error, segment, null);
              return;
            }
            boundary.pendingTasks--;
            0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment, null), abortRemainingReplayNodes(
              request,
              null,
              boundary.nodes,
              boundary.slots,
              error,
              task,
              segment,
              true
            ));
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          }
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, task = logRecoverableError(request, error, segment, null), boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, task, error, segment, true), untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error);
          }), boundary.fallbackAbortableTasks.clear();
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(abortTask, "abortTask");
      __name2(abortTask, "abortTask");
      function safelyEmitEarlyPreloads(request, shellComplete) {
        try {
          var renderState = request.renderState, onHeaders = renderState.onHeaders;
          if (onHeaders) {
            var headers = renderState.headers;
            if (headers) {
              renderState.headers = null;
              var linkHeader = headers.preconnects;
              headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
              headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
              if (!shellComplete) {
                var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                b:
                  for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                    for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                      var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                      var header = getPreloadAsHeader(
                        props$jscomp$0.href,
                        "style",
                        {
                          crossOrigin: props$jscomp$0.crossOrigin,
                          integrity: props$jscomp$0.integrity,
                          nonce: props$jscomp$0.nonce,
                          type: props$jscomp$0.type,
                          fetchPriority: props$jscomp$0.fetchPriority,
                          referrerPolicy: props$jscomp$0.referrerPolicy,
                          media: props$jscomp$0.media
                        }
                      );
                      if (0 <= (headers.remainingCapacity -= header.length + 2))
                        renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                      else
                        break b;
                    }
              }
              linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
            }
          }
        } catch (error) {
          logRecoverableError(request, error, {}, null);
        }
      }
      __name(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
      __name2(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
      function completeShell(request) {
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
        null === request.trackedPostpones && preparePreamble(request);
        request.onShellError = noop2;
        request = request.onShellReady;
        request();
      }
      __name(completeShell, "completeShell");
      __name2(completeShell, "completeShell");
      function completeAll(request) {
        safelyEmitEarlyPreloads(
          request,
          null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
        );
        preparePreamble(request);
        request = request.onAllReady;
        request();
      }
      __name(completeAll, "completeAll");
      __name2(completeAll, "completeAll");
      function queueCompletedSegment(boundary, segment) {
        if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else
          boundary.completedSegments.push(segment);
      }
      __name(queueCompletedSegment, "queueCompletedSegment");
      __name2(queueCompletedSegment, "queueCompletedSegment");
      function finishedTask(request, boundary, segment) {
        if (null === boundary) {
          if (null !== segment && segment.parentFlushed) {
            if (null !== request.completedRootSegment)
              throw Error(
                "There can only be one root segment. This is a bug in React."
              );
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (0 === boundary.pendingTasks ? (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED && (boundary.fallbackAbortableTasks.forEach(
            abortTaskSoft,
            request
          ), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && segment.status === COMPLETED && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(finishedTask, "finishedTask");
      __name2(finishedTask, "finishedTask");
      function performWork(request$jscomp$2) {
        if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
          var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = HooksDispatcher;
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          var prevRequest = currentRequest;
          currentRequest = request$jscomp$2;
          var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
          var prevResumableState = currentResumableState;
          currentResumableState = request$jscomp$2.resumableState;
          try {
            var pingedTasks = request$jscomp$2.pingedTasks, i2;
            for (i2 = 0; i2 < pingedTasks.length; i2++) {
              var request = request$jscomp$2, task = pingedTasks[i2], segment = task.blockedSegment;
              if (null === segment) {
                var prevTaskInDEV = void 0, request$jscomp$0 = request;
                request = task;
                if (0 !== request.replay.pendingTasks) {
                  switchContext(request.context);
                  prevTaskInDEV = currentTaskInDEV;
                  currentTaskInDEV = request;
                  try {
                    "number" === typeof request.replay.slots ? resumeNode(
                      request$jscomp$0,
                      request,
                      request.replay.slots,
                      request.node,
                      request.childIndex
                    ) : retryNode(request$jscomp$0, request);
                    if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    finishedTask(request$jscomp$0, request.blockedBoundary, null);
                  } catch (thrownValue) {
                    resetHooksState();
                    var x2 = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if ("object" === typeof x2 && null !== x2 && "function" === typeof x2.then) {
                      var ping = request.ping;
                      x2.then(ping, ping);
                      request.thenableState = getThenableStateAfterSuspending();
                    } else {
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x2, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                      errorDigest = logRecoverableError(
                        request$jscomp$1,
                        error$jscomp$0,
                        errorInfo$jscomp$0,
                        request.debugTask
                      );
                      abortRemainingReplayNodes(
                        request$jscomp$1,
                        boundary,
                        replayNodes,
                        resumeSlots,
                        error$jscomp$0,
                        errorDigest,
                        errorInfo$jscomp$0,
                        false
                      );
                      request$jscomp$0.pendingRootTasks--;
                      0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                      request$jscomp$0.allPendingTasks--;
                      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                    }
                  } finally {
                    currentTaskInDEV = prevTaskInDEV;
                  }
                }
              } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                request$jscomp$1.status = 6;
                switchContext(errorDigest.context);
                request$jscomp$0 = currentTaskInDEV;
                currentTaskInDEV = errorDigest;
                var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                try {
                  retryNode(request, errorDigest), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(
                    request,
                    errorDigest.blockedBoundary,
                    request$jscomp$1
                  );
                } catch (thrownValue) {
                  resetHooksState();
                  request$jscomp$1.children.length = childrenLength;
                  request$jscomp$1.chunks.length = chunkLength;
                  var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                    request$jscomp$1.status = PENDING;
                    errorDigest.thenableState = getThenableStateAfterSuspending();
                    var ping$jscomp$0 = errorDigest.ping;
                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                  } else {
                    var errorInfo$jscomp$1 = getThrownInfo(
                      errorDigest.componentStack
                    );
                    errorDigest.abortSet.delete(errorDigest);
                    request$jscomp$1.status = 4;
                    var boundary$jscomp$0 = errorDigest.blockedBoundary, debugTask = errorDigest.debugTask;
                    prevTaskInDEV = logRecoverableError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    );
                    null === boundary$jscomp$0 ? fatalError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    ) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED && (boundary$jscomp$0.status = CLIENT_RENDERED, encodeErrorForBoundary(
                      boundary$jscomp$0,
                      prevTaskInDEV,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      false
                    ), untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(
                      boundary$jscomp$0
                    ), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                    request.allPendingTasks--;
                    0 === request.allPendingTasks && completeAll(request);
                  }
                } finally {
                  currentTaskInDEV = request$jscomp$0;
                }
              }
            }
            pingedTasks.splice(0, i2);
            null !== request$jscomp$2.destination && flushCompletedQueues(
              request$jscomp$2,
              request$jscomp$2.destination
            );
          } catch (error) {
            pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
          } finally {
            currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
          }
        }
      }
      __name(performWork, "performWork");
      __name2(performWork, "performWork");
      function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
        segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
        for (var pendingPreambles = false, i2 = 0; i2 < segment.children.length; i2++)
          pendingPreambles = preparePreambleFromSegment(
            request,
            segment.children[i2],
            collectedPreambleSegments
          ) || pendingPreambles;
        return pendingPreambles;
      }
      __name(preparePreambleFromSubtree, "preparePreambleFromSubtree");
      __name2(preparePreambleFromSubtree, "preparePreambleFromSubtree");
      function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
        var boundary = segment.boundary;
        if (null === boundary)
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
        if (null === preamble || null === fallbackPreamble)
          return false;
        switch (boundary.status) {
          case COMPLETED:
            hoistPreambleState(request.renderState, preamble);
            segment = boundary.completedSegments[0];
            if (!segment)
              throw Error(
                "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
              );
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          case POSTPONED:
            if (null !== request.trackedPostpones)
              return true;
          case CLIENT_RENDERED:
            if (segment.status === COMPLETED)
              return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
          default:
            return true;
        }
      }
      __name(preparePreambleFromSegment, "preparePreambleFromSegment");
      __name2(preparePreambleFromSegment, "preparePreambleFromSegment");
      function preparePreamble(request) {
        if (request.completedRootSegment && null === request.completedPreambleSegments) {
          var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
            request,
            request.completedRootSegment,
            collectedPreambleSegments
          ), preamble = request.renderState.preamble;
          if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
            request.completedPreambleSegments = collectedPreambleSegments;
        }
      }
      __name(preparePreamble, "preparePreamble");
      __name2(preparePreamble, "preparePreamble");
      function flushSubtree(request, destination, segment, hoistableState) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING:
            segment.id = request.nextSegmentId++;
          case POSTPONED:
            return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = stringToChunk(hoistableState.toString(16)), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);
          case COMPLETED:
            segment.status = FLUSHED;
            var r3 = true, chunks = segment.chunks, chunkIdx = 0;
            segment = segment.children;
            for (var childIdx = 0; childIdx < segment.length; childIdx++) {
              for (r3 = segment[childIdx]; chunkIdx < r3.index; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              r3 = flushSegment(request, destination, r3, hoistableState);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            chunkIdx < chunks.length && (r3 = writeChunkAndReturn(destination, chunks[chunkIdx]));
            return r3;
          default:
            throw Error(
              "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
            );
        }
      }
      __name(flushSubtree, "flushSubtree");
      __name2(flushSubtree, "flushSubtree");
      function flushSegment(request, destination, segment, hoistableState) {
        var boundary = segment.boundary;
        if (null === boundary)
          return flushSubtree(request, destination, segment, hoistableState);
        boundary.parentFlushed = true;
        if (boundary.status === CLIENT_RENDERED) {
          var errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
          writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorDigest))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorMessage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorMessage))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorStack))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1D), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorComponentStack))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          flushSubtree(request, destination, segment, hoistableState);
          (request = boundary.fallbackPreamble) && writePreambleContribution(destination, request);
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        if (boundary.status !== COMPLETED)
          return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
            hoistStylesheetDependency,
            hoistableState
          )), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
        if (boundary.byteSize > request.progressiveChunkSize)
          return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
        hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
        writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        segment = boundary.completedSegments;
        if (1 !== segment.length)
          throw Error(
            "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
          );
        flushSegment(request, destination, segment[0], hoistableState);
        (request = boundary.contentPreamble) && writePreambleContribution(destination, request);
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      __name(flushSegment, "flushSegment");
      __name2(flushSegment, "flushSegment");
      function flushSegmentContainer(request, destination, segment, hoistableState) {
        writeStartSegment(
          destination,
          request.renderState,
          segment.parentFormatContext,
          segment.id
        );
        flushSegment(request, destination, segment, hoistableState);
        return writeEndSegment(destination, segment.parentFormatContext);
      }
      __name(flushSegmentContainer, "flushSegmentContainer");
      __name2(flushSegmentContainer, "flushSegmentContainer");
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++)
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            completedSegments[i2]
          );
        completedSegments.length = 0;
        writeHoistablesForBoundary(
          destination,
          boundary.contentState,
          request.renderState
        );
        completedSegments = request.resumableState;
        request = request.renderState;
        i2 = boundary.rootSegmentID;
        boundary = boundary.contentState;
        var requiresStyleInsertion = request.stylesToHoist;
        request.stylesToHoist = false;
        writeChunk(destination, request.startInlineScript);
        requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction | SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryWithStylesScript1FullBoth)) : (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, writeChunk(
          destination,
          completeBoundaryWithStylesScript1FullPartial
        )) : writeChunk(destination, completeBoundaryWithStylesScript1Partial) : (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScript1Full)) : writeChunk(destination, completeBoundaryScript1Partial);
        completedSegments = stringToChunk(i2.toString(16));
        writeChunk(destination, request.boundaryPrefix);
        writeChunk(destination, completedSegments);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, request.segmentPrefix);
        writeChunk(destination, completedSegments);
        requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
        boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
        return writeBootstrap(destination, request) && boundary;
      }
      __name(flushCompletedBoundary, "flushCompletedBoundary");
      __name2(flushCompletedBoundary, "flushCompletedBoundary");
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED)
          return true;
        var hoistableState = boundary.contentState, segmentID = segment.id;
        if (-1 === segmentID) {
          if (-1 === (segment.id = boundary.rootSegmentID))
            throw Error(
              "A root segment ID must have been assigned by now. This is a bug in React."
            );
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        }
        if (segmentID === boundary.rootSegmentID)
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        flushSegmentContainer(request, destination, segment, hoistableState);
        boundary = request.resumableState;
        request = request.renderState;
        writeChunk(destination, request.startInlineScript);
        (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
        writeChunk(destination, request.segmentPrefix);
        segmentID = stringToChunk(segmentID.toString(16));
        writeChunk(destination, segmentID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, request.placeholderPrefix);
        writeChunk(destination, segmentID);
        destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
        return destination;
      }
      __name(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
      __name2(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
      function flushCompletedQueues(request, destination) {
        currentView = new Uint8Array(2048);
        writtenBytes = 0;
        try {
          if (!(0 < request.pendingRootTasks)) {
            var i2, completedRootSegment = request.completedRootSegment;
            if (null !== completedRootSegment) {
              if (completedRootSegment.status === POSTPONED)
                return;
              var completedPreambleSegments = request.completedPreambleSegments;
              if (null === completedPreambleSegments)
                return;
              var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
              if (htmlChunks) {
                for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                  writeChunk(destination, htmlChunks[i$jscomp$0]);
                if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    writeChunk(destination, headChunks[i$jscomp$0]);
                else
                  writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
              } else if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  writeChunk(destination, headChunks[i$jscomp$0]);
              var charsetChunks = renderState.charsetChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                writeChunk(destination, charsetChunks[i$jscomp$0]);
              charsetChunks.length = 0;
              renderState.preconnects.forEach(flushResource, destination);
              renderState.preconnects.clear();
              var viewportChunks = renderState.viewportChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                writeChunk(destination, viewportChunks[i$jscomp$0]);
              viewportChunks.length = 0;
              renderState.fontPreloads.forEach(flushResource, destination);
              renderState.fontPreloads.clear();
              renderState.highImagePreloads.forEach(flushResource, destination);
              renderState.highImagePreloads.clear();
              renderState.styles.forEach(flushStylesInPreamble, destination);
              var importMapChunks = renderState.importMapChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                writeChunk(destination, importMapChunks[i$jscomp$0]);
              importMapChunks.length = 0;
              renderState.bootstrapScripts.forEach(flushResource, destination);
              renderState.scripts.forEach(flushResource, destination);
              renderState.scripts.clear();
              renderState.bulkPreloads.forEach(flushResource, destination);
              renderState.bulkPreloads.clear();
              var hoistableChunks = renderState.hoistableChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                writeChunk(destination, hoistableChunks[i$jscomp$0]);
              for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
                var segments = completedPreambleSegments[renderState];
                for (preamble = 0; preamble < segments.length; preamble++)
                  flushSegment(request, destination, segments[preamble], null);
              }
              var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
              (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
              var bodyChunks = preamble$jscomp$0.bodyChunks;
              if (bodyChunks)
                for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                  writeChunk(destination, bodyChunks[completedPreambleSegments]);
              flushSegment(request, destination, completedRootSegment, null);
              request.completedRootSegment = null;
              writeBootstrap(destination, request.renderState);
            }
            var renderState$jscomp$0 = request.renderState;
            completedRootSegment = 0;
            var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
            for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
              writeChunk(
                destination,
                viewportChunks$jscomp$0[completedRootSegment]
              );
            viewportChunks$jscomp$0.length = 0;
            renderState$jscomp$0.preconnects.forEach(flushResource, destination);
            renderState$jscomp$0.preconnects.clear();
            renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.fontPreloads.clear();
            renderState$jscomp$0.highImagePreloads.forEach(
              flushResource,
              destination
            );
            renderState$jscomp$0.highImagePreloads.clear();
            renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
            renderState$jscomp$0.scripts.forEach(flushResource, destination);
            renderState$jscomp$0.scripts.clear();
            renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.bulkPreloads.clear();
            var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
            for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
              writeChunk(
                destination,
                hoistableChunks$jscomp$0[completedRootSegment]
              );
            hoistableChunks$jscomp$0.length = 0;
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            for (i2 = 0; i2 < clientRenderedBoundaries.length; i2++) {
              var boundary = clientRenderedBoundaries[i2];
              renderState$jscomp$0 = destination;
              var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id3 = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
              writeChunk(
                renderState$jscomp$0,
                renderState$jscomp$1.startInlineScript
              );
              (resumableState.instructions & SentClientRenderFunction) === NothingSent ? (resumableState.instructions |= SentClientRenderFunction, writeChunk(renderState$jscomp$0, clientRenderScript1Full)) : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
              writeChunk(
                renderState$jscomp$0,
                renderState$jscomp$1.boundaryPrefix
              );
              writeChunk(renderState$jscomp$0, stringToChunk(id3.toString(16)));
              writeChunk(renderState$jscomp$0, clientRenderScript1A);
              if (errorDigest || errorMessage || errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  stringToChunk(
                    escapeJSStringsForInstructionScripts(errorDigest || "")
                  )
                );
              if (errorMessage || errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  stringToChunk(
                    escapeJSStringsForInstructionScripts(errorMessage || "")
                  )
                );
              if (errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  stringToChunk(
                    escapeJSStringsForInstructionScripts(errorStack || "")
                  )
                );
              errorComponentStack && (writeChunk(
                renderState$jscomp$0,
                clientRenderErrorScriptArgInterstitial
              ), writeChunk(
                renderState$jscomp$0,
                stringToChunk(
                  escapeJSStringsForInstructionScripts(errorComponentStack)
                )
              ));
              var JSCompiler_inline_result = writeChunkAndReturn(
                renderState$jscomp$0,
                clientRenderScriptEnd
              );
              if (!JSCompiler_inline_result) {
                request.destination = null;
                i2++;
                clientRenderedBoundaries.splice(0, i2);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i2);
            var completedBoundaries = request.completedBoundaries;
            for (i2 = 0; i2 < completedBoundaries.length; i2++)
              if (!flushCompletedBoundary(
                request,
                destination,
                completedBoundaries[i2]
              )) {
                request.destination = null;
                i2++;
                completedBoundaries.splice(0, i2);
                return;
              }
            completedBoundaries.splice(0, i2);
            completeWriting(destination);
            currentView = new Uint8Array(2048);
            writtenBytes = 0;
            var partialBoundaries = request.partialBoundaries;
            for (i2 = 0; i2 < partialBoundaries.length; i2++) {
              a: {
                clientRenderedBoundaries = request;
                boundary = destination;
                var boundary$jscomp$0 = partialBoundaries[i2], completedSegments = boundary$jscomp$0.completedSegments;
                for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                  if (!flushPartiallyCompletedSegment(
                    clientRenderedBoundaries,
                    boundary,
                    boundary$jscomp$0,
                    completedSegments[JSCompiler_inline_result]
                  )) {
                    JSCompiler_inline_result++;
                    completedSegments.splice(0, JSCompiler_inline_result);
                    var JSCompiler_inline_result$jscomp$0 = false;
                    break a;
                  }
                completedSegments.splice(0, JSCompiler_inline_result);
                JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                  boundary,
                  boundary$jscomp$0.contentState,
                  clientRenderedBoundaries.renderState
                );
              }
              if (!JSCompiler_inline_result$jscomp$0) {
                request.destination = null;
                i2++;
                partialBoundaries.splice(0, i2);
                return;
              }
            }
            partialBoundaries.splice(0, i2);
            var largeBoundaries = request.completedBoundaries;
            for (i2 = 0; i2 < largeBoundaries.length; i2++)
              if (!flushCompletedBoundary(request, destination, largeBoundaries[i2])) {
                request.destination = null;
                i2++;
                largeBoundaries.splice(0, i2);
                return;
              }
            largeBoundaries.splice(0, i2);
          }
        } finally {
          0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = false, i2 = request.resumableState, i2.hasBody && writeChunk(destination, endChunkForTag("body")), i2.hasHtml && writeChunk(destination, endChunkForTag("html")), completeWriting(destination), 0 !== request.abortableTasks.size && console.error(
            "There was still abortable task at the root when we closed. This is a bug in React."
          ), request.status = CLOSED, destination.close(), request.destination = null) : completeWriting(destination);
        }
      }
      __name(flushCompletedQueues, "flushCompletedQueues");
      __name2(flushCompletedQueues, "flushCompletedQueues");
      function startWork(request) {
        request.flushScheduled = null !== request.destination;
        supportsRequestStorage ? scheduleMicrotask(function() {
          return requestStorage.run(request, performWork, request);
        }) : scheduleMicrotask(function() {
          return performWork(request);
        });
        setTimeout(function() {
          10 === request.status && (request.status = 11);
          null === request.trackedPostpones && (supportsRequestStorage ? requestStorage.run(
            request,
            enqueueEarlyPreloadsAfterInitialWork,
            request
          ) : enqueueEarlyPreloadsAfterInitialWork(request));
        }, 0);
      }
      __name(startWork, "startWork");
      __name2(startWork, "startWork");
      function enqueueEarlyPreloadsAfterInitialWork(request) {
        safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
      }
      __name(enqueueEarlyPreloadsAfterInitialWork, "enqueueEarlyPreloadsAfterInitialWork");
      __name2(enqueueEarlyPreloadsAfterInitialWork, "enqueueEarlyPreloadsAfterInitialWork");
      function enqueueFlush(request) {
        false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = true, setTimeout(function() {
          var destination = request.destination;
          destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
        }, 0));
      }
      __name(enqueueFlush, "enqueueFlush");
      __name2(enqueueFlush, "enqueueFlush");
      function startFlowing(request, destination) {
        if (13 === request.status)
          request.status = CLOSED, closeWithError(destination, request.fatalError);
        else if (request.status !== CLOSED && null === request.destination) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error) {
            destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
          }
        }
      }
      __name(startFlowing, "startFlowing");
      __name2(startFlowing, "startFlowing");
      function abort(request, reason) {
        if (11 === request.status || 10 === request.status)
          request.status = 12;
        try {
          var abortableTasks = request.abortableTasks;
          if (0 < abortableTasks.size) {
            var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
            request.fatalError = error;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, error);
            });
            abortableTasks.clear();
          }
          null !== request.destination && flushCompletedQueues(request, request.destination);
        } catch (error$4) {
          reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
        }
      }
      __name(abort, "abort");
      __name2(abort, "abort");
      function ensureCorrectIsomorphicReactVersion() {
        var isomorphicReactPackageVersion = React31.version;
        if ("19.1.0" !== isomorphicReactPackageVersion)
          throw Error(
            'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.0\nLearn more: https://react.dev/warnings/version-mismatch")
          );
      }
      __name(ensureCorrectIsomorphicReactVersion, "ensureCorrectIsomorphicReactVersion");
      __name2(ensureCorrectIsomorphicReactVersion, "ensureCorrectIsomorphicReactVersion");
      var React31 = require_react(), ReactDOM4 = require_react_dom(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), LocalPromise = Promise, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : function(callback) {
        LocalPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      }, currentView = null, writtenBytes = 0, textEncoder = new TextEncoder(), assign = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ), aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties$1 = {}, rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), didWarnValueNull = false, possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React31.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM4.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: false,
        data: null,
        method: null,
        action: null
      }), previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: previousDispatcher.f,
        r: previousDispatcher.r,
        D: function(href) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              if (!resumableState.dnsResources.hasOwnProperty(href)) {
                resumableState.dnsResources[href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                  JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
              }
              enqueueFlush(request);
            }
          } else
            previousDispatcher.D(href);
        },
        C: function(href, crossOrigin) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
              if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                resumableState.connectResources[bucket][href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                  JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                  if ("string" === typeof crossOrigin) {
                    var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                      crossOrigin,
                      "crossOrigin"
                    );
                    JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                  }
                  JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                }
                JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                  rel: "preconnect",
                  href,
                  crossOrigin
                }), renderState.preconnects.add(bucket));
              }
              enqueueFlush(request);
            }
          } else
            previousDispatcher.C(href, crossOrigin);
        },
        L: function(href, as, options2) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (as && href) {
              switch (as) {
                case "image":
                  if (options2) {
                    var imageSrcSet = options2.imageSrcSet;
                    var imageSizes = options2.imageSizes;
                    var fetchPriority = options2.fetchPriority;
                  }
                  var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                  if (resumableState.imageResources.hasOwnProperty(key))
                    return;
                  resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                  resumableState = renderState.headers;
                  var header;
                  resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as, options2), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                    resumableState,
                    assign(
                      {
                        rel: "preload",
                        href: imageSrcSet ? void 0 : href,
                        as
                      },
                      options2
                    )
                  ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                  break;
                case "style":
                  if (resumableState.styleResources.hasOwnProperty(href))
                    return;
                  imageSrcSet = [];
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as }, options2)
                  );
                  resumableState.styleResources[href] = !options2 || "string" !== typeof options2.crossOrigin && "string" !== typeof options2.integrity ? PRELOAD_NO_CREDS : [options2.crossOrigin, options2.integrity];
                  renderState.preloads.stylesheets.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  break;
                case "script":
                  if (resumableState.scriptResources.hasOwnProperty(href))
                    return;
                  imageSrcSet = [];
                  renderState.preloads.scripts.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as }, options2)
                  );
                  resumableState.scriptResources[href] = !options2 || "string" !== typeof options2.crossOrigin && "string" !== typeof options2.integrity ? PRELOAD_NO_CREDS : [options2.crossOrigin, options2.integrity];
                  break;
                default:
                  if (resumableState.unknownResources.hasOwnProperty(as)) {
                    if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
                      return;
                  } else
                    imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
                  imageSrcSet[href] = PRELOAD_NO_CREDS;
                  if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader(href, as, options2), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                    renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                  else
                    switch (resumableState = [], href = assign(
                      { rel: "preload", href, as },
                      options2
                    ), pushLinkImpl(resumableState, href), as) {
                      case "font":
                        renderState.fontPreloads.add(resumableState);
                        break;
                      default:
                        renderState.bulkPreloads.add(resumableState);
                    }
              }
              enqueueFlush(request);
            }
          } else
            previousDispatcher.L(href, as, options2);
        },
        m: function(href, options2) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              var as = options2 && "string" === typeof options2.as ? options2.as : "script";
              switch (as) {
                case "script":
                  if (resumableState.moduleScriptResources.hasOwnProperty(href))
                    return;
                  as = [];
                  resumableState.moduleScriptResources[href] = !options2 || "string" !== typeof options2.crossOrigin && "string" !== typeof options2.integrity ? PRELOAD_NO_CREDS : [options2.crossOrigin, options2.integrity];
                  renderState.preloads.moduleScripts.set(href, as);
                  break;
                default:
                  if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
                    var resources = resumableState.unknownResources[as];
                    if (resources.hasOwnProperty(href))
                      return;
                  } else
                    resources = {}, resumableState.moduleUnknownResources[as] = resources;
                  as = [];
                  resources[href] = PRELOAD_NO_CREDS;
              }
              pushLinkImpl(
                as,
                assign({ rel: "modulepreload", href }, options2)
              );
              renderState.bulkPreloads.add(as);
              enqueueFlush(request);
            }
          } else
            previousDispatcher.m(href, options2);
        },
        X: function(src, options2) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.scriptResources.hasOwnProperty(
                src
              ) ? resumableState.scriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options2 = assign({ src, async: true }, options2), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options2, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options2), enqueueFlush(request));
            }
          } else
            previousDispatcher.X(src, options2);
        },
        S: function(href, precedence, options2) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              precedence = precedence || "default";
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                precedence: stringToChunk(escapeTextForBrowser(precedence)),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue)), precedence = {
                state: PENDING$1,
                props: assign(
                  {
                    rel: "stylesheet",
                    href,
                    "data-precedence": precedence
                  },
                  options2
                )
              }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
            }
          } else
            previousDispatcher.S(href, precedence, options2);
        },
        M: function(src, options2) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options2 = assign(
                { src, type: "module", async: true },
                options2
              ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options2, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options2), enqueueFlush(request));
            }
          } else
            previousDispatcher.M(src, options2);
        }
      };
      var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, EXISTS = null, PRELOAD_NO_CREDS = [];
      Object.freeze(PRELOAD_NO_CREDS);
      stringToPrecomputedChunk('"></template>');
      var startInlineScript = stringToPrecomputedChunk("<script>"), endInlineScript = stringToPrecomputedChunk("<\/script>"), startScriptSrc = stringToPrecomputedChunk('<script src="'), startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'), scriptNonce = stringToPrecomputedChunk('" nonce="'), scriptIntegirty = stringToPrecomputedChunk('" integrity="'), scriptCrossOrigin = stringToPrecomputedChunk('" crossorigin="'), endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>'), scriptRegex = /(<\/|<)(s)(cript)/gi, importMapScriptStart = stringToPrecomputedChunk(
        '<script type="importmap">'
      ), importMapScriptEnd = stringToPrecomputedChunk("<\/script>");
      var didWarnForNewBooleanPropsWithEmptyValue = {};
      var NoContribution = 0, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, textSeparator = stringToPrecomputedChunk("<!-- -->"), styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = stringToPrecomputedChunk(' style="'), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";"), attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk('="'), attributeEnd = stringToPrecomputedChunk('"'), attributeEmptyString = stringToPrecomputedChunk('=""'), actionJavaScriptURL = stringToPrecomputedChunk(
        escapeTextForBrowser(
          "javascript:throw new Error('React form unexpectedly submitted.')"
        )
      ), startHiddenInputChunk = stringToPrecomputedChunk('<input type="hidden"'), endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>"), didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'), formReplayingRuntimeScript = stringToPrecomputedChunk(
        `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`
      ), formStateMarkerIsMatching = stringToPrecomputedChunk("<!--F!-->"), formStateMarkerIsNotMatching = stringToPrecomputedChunk("<!--F-->"), styleRegex = /(<\/|<)(s)(tyle)/gi, leadingNewline = stringToPrecomputedChunk("\n"), VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), doctypeChunk = stringToPrecomputedChunk("<!DOCTYPE html>"), endTagCache = /* @__PURE__ */ new Map(), placeholder1 = stringToPrecomputedChunk('<template id="'), placeholder2 = stringToPrecomputedChunk('"></template>'), startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
        '<!--$?--><template id="'
      ), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="'), clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="'), clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="'), clientRenderedSuspenseBoundaryError1D = stringToPrecomputedChunk(' data-cstck="'), clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>"), boundaryPreambleContributionChunkStart = stringToPrecomputedChunk("<!--"), boundaryPreambleContributionChunkEnd = stringToPrecomputedChunk("-->"), startSegmentHTML = stringToPrecomputedChunk('<div hidden id="'), startSegmentHTML2 = stringToPrecomputedChunk('">'), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk(
        '<svg aria-hidden="true" style="display:none" id="'
      ), startSegmentSVG2 = stringToPrecomputedChunk('">'), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk(
        '<math aria-hidden="true" style="display:none" id="'
      ), startSegmentMathML2 = stringToPrecomputedChunk('">'), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk('<table hidden id="'), startSegmentTable2 = stringToPrecomputedChunk('">'), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk(
        '<table hidden><tbody id="'
      ), startSegmentTableBody2 = stringToPrecomputedChunk('">'), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="'), startSegmentTableRow2 = stringToPrecomputedChunk('">'), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk(
        '<table hidden><colgroup id="'
      ), startSegmentColGroup2 = stringToPrecomputedChunk('">'), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>"), completeSegmentScript1Full = stringToPrecomputedChunk(
        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
      ), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'), completeSegmentScript2 = stringToPrecomputedChunk('","'), completeSegmentScriptEnd = stringToPrecomputedChunk('")<\/script>');
      stringToPrecomputedChunk('<template data-rsi="" data-sid="');
      stringToPrecomputedChunk('" data-pid="');
      var completeBoundaryScript1Full = stringToPrecomputedChunk(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
      ), completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'), completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      ), completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(
        '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      ), completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR("'), completeBoundaryScript2 = stringToPrecomputedChunk('","'), completeBoundaryScript3a = stringToPrecomputedChunk('",'), completeBoundaryScript3b = stringToPrecomputedChunk('"'), completeBoundaryScriptEnd = stringToPrecomputedChunk(")<\/script>");
      stringToPrecomputedChunk('<template data-rci="" data-bid="');
      stringToPrecomputedChunk('<template data-rri="" data-bid="');
      stringToPrecomputedChunk('" data-sid="');
      stringToPrecomputedChunk('" data-sty="');
      var clientRenderScript1Full = stringToPrecomputedChunk(
        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
      ), clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'), clientRenderScript1A = stringToPrecomputedChunk('"'), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","), clientRenderScriptEnd = stringToPrecomputedChunk(")<\/script>");
      stringToPrecomputedChunk('<template data-rxi="" data-bid="');
      stringToPrecomputedChunk('" data-dgst="');
      stringToPrecomputedChunk('" data-msg="');
      stringToPrecomputedChunk('" data-stck="');
      stringToPrecomputedChunk('" data-cstck="');
      var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
        '<style media="not all" data-precedence="'
      ), lateStyleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), lateStyleTagResourceOpen3 = stringToPrecomputedChunk('">'), lateStyleTagTemplateClose = stringToPrecomputedChunk("</style>"), currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = stringToPrecomputedChunk(
        '<style data-precedence="'
      ), styleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), spaceSeparator = stringToPrecomputedChunk(" "), styleTagResourceOpen3 = stringToPrecomputedChunk('">'), styleTagResourceClose = stringToPrecomputedChunk("</style>"), arrayFirstOpenBracket = stringToPrecomputedChunk("["), arraySubsequentOpenBracket = stringToPrecomputedChunk(",["), arrayInterstitial = stringToPrecomputedChunk(","), arrayCloseBracket = stringToPrecomputedChunk("]"), PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, bind = Function.prototype.bind, supportsRequestStorage = "function" === typeof AsyncLocalStorage, requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var rendererSigil = {};
      var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          var internals = inst._reactInternals;
          null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          inst.replace = true;
          inst.queue = [payload];
          void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        },
        enqueueForceUpdate: function(inst, callback) {
          null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }
      }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
        readContext,
        use: function(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then)
              return unwrapThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE)
              return readContext(usable);
          }
          throw Error(
            "An unsupported type was passed to use(): " + String(usable)
          );
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          resolveCurrentlyRenderingComponent();
          return context._currentValue;
        },
        useMemo: useMemo14,
        useReducer: useReducer3,
        useRef: function(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          return useReducer3(basicStateReducer, initialState);
        },
        useInsertionEffect: noop$1,
        useLayoutEffect: noop$1,
        useCallback: function(callback, deps) {
          return useMemo14(function() {
            return callback;
          }, deps);
        },
        useImperativeHandle: noop$1,
        useEffect: noop$1,
        useDebugValue: noop$1,
        useDeferredValue: function(value, initialValue) {
          resolveCurrentlyRenderingComponent();
          return void 0 !== initialValue ? initialValue : value;
        },
        useTransition: function() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        },
        useId: function() {
          var treeId = currentlyRenderingTask.treeContext;
          var overflow = treeId.overflow;
          treeId = treeId.id;
          treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
          var resumableState = currentResumableState;
          if (null === resumableState)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component."
            );
          overflow = localIdCounter++;
          treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
          0 < overflow && (treeId += "H" + overflow.toString(32));
          return treeId + "\xBB";
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          return getServerSnapshot();
        },
        useOptimistic: function(passthrough) {
          resolveCurrentlyRenderingComponent();
          return [passthrough, unsupportedSetOptimisticState];
        },
        useActionState,
        useFormState: useActionState,
        useHostTransitionStatus: function() {
          resolveCurrentlyRenderingComponent();
          return NotPending;
        },
        useMemoCache: function(size3) {
          for (var data = Array(size3), i2 = 0; i2 < size3; i2++)
            data[i2] = REACT_MEMO_CACHE_SENTINEL;
          return data;
        },
        useCacheRefresh: function() {
          return unsupportedRefresh;
        }
      }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
        getCacheForType: function() {
          throw Error("Not implemented.");
        },
        getOwner: function() {
          return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
        }
      }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var callComponent = {
        "react-stack-bottom-frame": function(Component3, props, secondArg) {
          return Component3(props, secondArg);
        }
      }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
        "react-stack-bottom-frame": function(instance) {
          return instance.render();
        }
      }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callLazyInit = {
        "react-stack-bottom-frame": function(lazy) {
          var init2 = lazy._init;
          return init2(lazy._payload);
        }
      }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = /* @__PURE__ */ __name2(function() {
          return localPerformance.now();
        }, "getCurrentTime");
      } else {
        var localDate = Date;
        getCurrentTime = /* @__PURE__ */ __name2(function() {
          return localDate.now();
        }, "getCurrentTime");
      }
      var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false;
      ensureCorrectIsomorphicReactVersion();
      ensureCorrectIsomorphicReactVersion();
      exports.prerender = function(children, options2) {
        return new Promise(function(resolve, reject) {
          var onHeaders = options2 ? options2.onHeaders : void 0, onHeadersImpl;
          onHeaders && (onHeadersImpl = /* @__PURE__ */ __name2(function(headersDescriptor) {
            onHeaders(new Headers(headersDescriptor));
          }, "onHeadersImpl"));
          var resources = createResumableState(
            options2 ? options2.identifierPrefix : void 0,
            options2 ? options2.unstable_externalRuntimeSrc : void 0,
            options2 ? options2.bootstrapScriptContent : void 0,
            options2 ? options2.bootstrapScripts : void 0,
            options2 ? options2.bootstrapModules : void 0
          ), request = createPrerenderRequest(
            children,
            resources,
            createRenderState(
              resources,
              void 0,
              options2 ? options2.unstable_externalRuntimeSrc : void 0,
              options2 ? options2.importMap : void 0,
              onHeadersImpl,
              options2 ? options2.maxHeadersLength : void 0
            ),
            createRootFormatContext(options2 ? options2.namespaceURI : void 0),
            options2 ? options2.progressiveChunkSize : void 0,
            options2 ? options2.onError : void 0,
            function() {
              var result = {
                prelude: new ReadableStream(
                  {
                    type: "bytes",
                    pull: function(controller) {
                      startFlowing(request, controller);
                    },
                    cancel: function(reason) {
                      request.destination = null;
                      abort(request, reason);
                    }
                  },
                  { highWaterMark: 0 }
                )
              };
              resolve(result);
            },
            void 0,
            void 0,
            reject,
            options2 ? options2.onPostpone : void 0
          );
          if (options2 && options2.signal) {
            var signal = options2.signal;
            if (signal.aborted)
              abort(request, signal.reason);
            else {
              var listener = /* @__PURE__ */ __name2(function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              }, "listener");
              signal.addEventListener("abort", listener);
            }
          }
          startWork(request);
        });
      };
      exports.renderToReadableStream = function(children, options2) {
        return new Promise(function(resolve, reject) {
          var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
            onAllReady = res;
            onFatalError = rej;
          }), onHeaders = options2 ? options2.onHeaders : void 0, onHeadersImpl;
          onHeaders && (onHeadersImpl = /* @__PURE__ */ __name2(function(headersDescriptor) {
            onHeaders(new Headers(headersDescriptor));
          }, "onHeadersImpl"));
          var resumableState = createResumableState(
            options2 ? options2.identifierPrefix : void 0,
            options2 ? options2.unstable_externalRuntimeSrc : void 0,
            options2 ? options2.bootstrapScriptContent : void 0,
            options2 ? options2.bootstrapScripts : void 0,
            options2 ? options2.bootstrapModules : void 0
          ), request = createRequest(
            children,
            resumableState,
            createRenderState(
              resumableState,
              options2 ? options2.nonce : void 0,
              options2 ? options2.unstable_externalRuntimeSrc : void 0,
              options2 ? options2.importMap : void 0,
              onHeadersImpl,
              options2 ? options2.maxHeadersLength : void 0
            ),
            createRootFormatContext(options2 ? options2.namespaceURI : void 0),
            options2 ? options2.progressiveChunkSize : void 0,
            options2 ? options2.onError : void 0,
            onAllReady,
            function() {
              var stream = new ReadableStream(
                {
                  type: "bytes",
                  pull: function(controller) {
                    startFlowing(request, controller);
                  },
                  cancel: function(reason) {
                    request.destination = null;
                    abort(request, reason);
                  }
                },
                { highWaterMark: 0 }
              );
              stream.allReady = allReady;
              resolve(stream);
            },
            function(error) {
              allReady.catch(function() {
              });
              reject(error);
            },
            onFatalError,
            options2 ? options2.onPostpone : void 0,
            options2 ? options2.formState : void 0
          );
          if (options2 && options2.signal) {
            var signal = options2.signal;
            if (signal.aborted)
              abort(request, signal.reason);
            else {
              var listener = /* @__PURE__ */ __name2(function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              }, "listener");
              signal.addEventListener("abort", listener);
            }
          }
          startWork(request);
        });
      };
      exports.version = "19.1.0";
    })();
  }
});
var require_react_dom_server_legacy_browser_development = __commonJS({
  "../node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    (function() {
      function styleReplacer(match2, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
      }
      __name(styleReplacer, "styleReplacer");
      __name2(styleReplacer, "styleReplacer");
      function scriptReplacer(match2, prefix2, s2, suffix2) {
        return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
      }
      __name(scriptReplacer, "scriptReplacer");
      __name2(scriptReplacer, "scriptReplacer");
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m2, p0) {
          return p0;
        });
      }
      __name(objectName, "objectName");
      __name2(objectName, "objectName");
      function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
      }
      __name(describeKeyForErrorMessage, "describeKeyForErrorMessage");
      __name2(describeKeyForErrorMessage, "describeKeyForErrorMessage");
      function describeValueForErrorMessage(value) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(
              10 >= value.length ? value : value.slice(0, 10) + "..."
            );
          case "object":
            if (isArrayImpl(value))
              return "[...]";
            if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
              return "client";
            value = objectName(value);
            return "Object" === value ? "{...}" : value;
          case "function":
            return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
          default:
            return String(value);
        }
      }
      __name(describeValueForErrorMessage, "describeValueForErrorMessage");
      __name2(describeValueForErrorMessage, "describeValueForErrorMessage");
      function describeElementType(type6) {
        if ("string" === typeof type6)
          return type6;
        switch (type6) {
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type6)
          switch (type6.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeElementType(type6.render);
            case REACT_MEMO_TYPE:
              return describeElementType(type6.type);
            case REACT_LAZY_TYPE:
              var payload = type6._payload;
              type6 = type6._init;
              try {
                return describeElementType(type6(payload));
              } catch (x2) {
              }
          }
        return "";
      }
      __name(describeElementType, "describeElementType");
      __name2(describeElementType, "describeElementType");
      function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind)
          return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray))
          if (jsxChildrenParents.has(objectOrArray)) {
            var type6 = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type6) + ">";
            for (var i2 = 0; i2 < objectOrArray.length; i2++) {
              var value = objectOrArray[i2];
              value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
              "" + i2 === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type6) + ">";
          } else {
            objKind = "[";
            for (type6 = 0; type6 < objectOrArray.length; type6++)
              0 < type6 && (objKind += ", "), i2 = objectOrArray[type6], i2 = "object" === typeof i2 && null !== i2 ? describeObjectForErrorMessage(i2) : describeValueForErrorMessage(i2), "" + type6 === expandedName ? (start = objKind.length, length = i2.length, objKind += i2) : objKind = 10 > i2.length && 40 > objKind.length + i2.length ? objKind + i2 : objKind + "...";
            objKind += "]";
          }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
          objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
          if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG)
            return "client";
          if (jsxPropsParents.has(objectOrArray)) {
            objKind = jsxPropsParents.get(objectOrArray);
            objKind = "<" + (describeElementType(objKind) || "...");
            type6 = Object.keys(objectOrArray);
            for (i2 = 0; i2 < type6.length; i2++) {
              objKind += " ";
              value = type6[i2];
              objKind += describeKeyForErrorMessage(value) + "=";
              var _value2 = objectOrArray[value];
              var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
              "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
              value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
            }
            objKind += ">";
          } else {
            objKind = "{";
            type6 = Object.keys(objectOrArray);
            for (i2 = 0; i2 < type6.length; i2++)
              0 < i2 && (objKind += ", "), value = type6[i2], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
            objKind += "}";
          }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
      }
      __name(describeObjectForErrorMessage, "describeObjectForErrorMessage");
      __name2(describeObjectForErrorMessage, "describeObjectForErrorMessage");
      function murmurhash3_32_gc(key, seed) {
        var remainder = key.length & 3;
        var bytes = key.length - remainder;
        var h1 = seed;
        for (seed = 0; seed < bytes; ) {
          var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
          ++seed;
          k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        }
        h1 ^= key.length;
        h1 ^= h1 >>> 16;
        h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        return (h1 ^ h1 >>> 16) >>> 0;
      }
      __name(murmurhash3_32_gc, "murmurhash3_32_gc");
      __name2(murmurhash3_32_gc, "murmurhash3_32_gc");
      function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      }
      __name(typeName, "typeName");
      __name2(typeName, "typeName");
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), false;
        } catch (e2) {
          return true;
        }
      }
      __name(willCoercionThrow, "willCoercionThrow");
      __name2(willCoercionThrow, "willCoercionThrow");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      __name2(testStringCoercion, "testStringCoercion");
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkAttributeStringCoercion, "checkAttributeStringCoercion");
      __name2(checkAttributeStringCoercion, "checkAttributeStringCoercion");
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkCSSPropertyStringCoercion, "checkCSSPropertyStringCoercion");
      __name2(checkCSSPropertyStringCoercion, "checkCSSPropertyStringCoercion");
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkHtmlStringCoercion, "checkHtmlStringCoercion");
      __name2(checkHtmlStringCoercion, "checkHtmlStringCoercion");
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        console.error("Invalid attribute name: `%s`", attributeName);
        return false;
      }
      __name(isAttributeNameSafe, "isAttributeNameSafe");
      __name2(isAttributeNameSafe, "isAttributeNameSafe");
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
        ) : console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
        ));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
      }
      __name(checkControlledValueProps, "checkControlledValueProps");
      __name2(checkControlledValueProps, "checkControlledValueProps");
      function validateProperty$1(tagName, name) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
          return true;
        if (rARIACamel$1.test(name)) {
          tagName = "aria-" + name.slice(4).toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ), warnedProperties$1[name] = true;
          if (name !== tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true;
        }
        if (rARIA$1.test(name)) {
          tagName = name.toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return warnedProperties$1[name] = true, false;
          name !== tagName && (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ), warnedProperties$1[name] = true);
        }
        return true;
      }
      __name(validateProperty$1, "validateProperty$1");
      __name2(validateProperty$1, "validateProperty$1");
      function validateProperties$2(type6, props) {
        var invalidProps = [], key;
        for (key in props)
          validateProperty$1(type6, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error(
          "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type6
        ) : 1 < invalidProps.length && console.error(
          "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type6
        );
      }
      __name(validateProperties$2, "validateProperties$2");
      __name2(validateProperties$2, "validateProperties$2");
      function validateProperty(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
          return true;
        var lowerCasedName = name.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
          return console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ), warnedProperties[name] = true;
        if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
          return true;
        if (null != eventRegistry) {
          tagName = eventRegistry.possibleRegistrationNames;
          if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
            return true;
          eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
          if (null != eventRegistry)
            return console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ), warnedProperties[name] = true;
          if (EVENT_NAME_REGEX.test(name))
            return console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ), warnedProperties[name] = true;
        } else if (EVENT_NAME_REGEX.test(name))
          return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
            "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
            name
          ), warnedProperties[name] = true;
        if (rARIA.test(name) || rARIACamel.test(name))
          return true;
        if ("innerhtml" === lowerCasedName)
          return console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ), warnedProperties[name] = true;
        if ("aria" === lowerCasedName)
          return console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ), warnedProperties[name] = true;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
          return console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ), warnedProperties[name] = true;
        if ("number" === typeof value && isNaN(value))
          return console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ), warnedProperties[name] = true;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
            return console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
        } else if (name !== lowerCasedName)
          return console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ), warnedProperties[name] = true;
        switch (name) {
          case "dangerouslySetInnerHTML":
          case "children":
          case "style":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            return true;
          case "innerText":
          case "textContent":
            return true;
        }
        switch (typeof value) {
          case "boolean":
            switch (name) {
              case "autoFocus":
              case "checked":
              case "multiple":
              case "muted":
              case "selected":
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "capture":
              case "download":
              case "inert":
                return true;
              default:
                lowerCasedName = name.toLowerCase().slice(0, 5);
                if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                  return true;
                value ? console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                  value,
                  name,
                  name,
                  value,
                  name
                ) : console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  value,
                  name,
                  name,
                  value,
                  name,
                  name,
                  name
                );
                return warnedProperties[name] = true;
            }
          case "function":
          case "symbol":
            return warnedProperties[name] = true, false;
          case "string":
            if ("false" === value || "true" === value) {
              switch (name) {
                case "checked":
                case "selected":
                case "multiple":
                case "muted":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "inert":
                  break;
                default:
                  return true;
              }
              console.error(
                "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                value,
                name,
                "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                name,
                value
              );
              warnedProperties[name] = true;
            }
        }
        return true;
      }
      __name(validateProperty, "validateProperty");
      __name2(validateProperty, "validateProperty");
      function warnUnknownProperties(type6, props, eventRegistry) {
        var unknownProps = [], key;
        for (key in props)
          validateProperty(type6, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error(
          "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type6
        ) : 1 < unknownProps.length && console.error(
          "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type6
        );
      }
      __name(warnUnknownProperties, "warnUnknownProperties");
      __name2(warnUnknownProperties, "warnUnknownProperties");
      function camelize(string) {
        return string.replace(hyphenPattern, function(_, character) {
          return character.toUpperCase();
        });
      }
      __name(camelize, "camelize");
      __name2(camelize, "camelize");
      function escapeTextForBrowser(text) {
        if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
          return "" + text;
        checkHtmlStringCoercion(text);
        text = "" + text;
        var match2 = matchHtmlRegExp.exec(text);
        if (match2) {
          var html = "", index, lastIndex = 0;
          for (index = match2.index; index < text.length; index++) {
            switch (text.charCodeAt(index)) {
              case 34:
                match2 = "&quot;";
                break;
              case 38:
                match2 = "&amp;";
                break;
              case 39:
                match2 = "&#x27;";
                break;
              case 60:
                match2 = "&lt;";
                break;
              case 62:
                match2 = "&gt;";
                break;
              default:
                continue;
            }
            lastIndex !== index && (html += text.slice(lastIndex, index));
            lastIndex = index + 1;
            html += match2;
          }
          text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
        }
        return text;
      }
      __name(escapeTextForBrowser, "escapeTextForBrowser");
      __name2(escapeTextForBrowser, "escapeTextForBrowser");
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      __name(sanitizeURL, "sanitizeURL");
      __name2(sanitizeURL, "sanitizeURL");
      function escapeEntireInlineScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      __name(escapeEntireInlineScriptContent, "escapeEntireInlineScriptContent");
      __name2(escapeEntireInlineScriptContent, "escapeEntireInlineScriptContent");
      function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        return {
          idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
          nextFormID: 0,
          streamingFormat: 0,
          bootstrapScriptContent,
          bootstrapScripts,
          bootstrapModules,
          instructions: NothingSent,
          hasBody: false,
          hasHtml: false,
          unknownResources: {},
          dnsResources: {},
          connectResources: { default: {}, anonymous: {}, credentials: {} },
          imageResources: {},
          styleResources: {},
          scriptResources: {},
          moduleUnknownResources: {},
          moduleScriptResources: {}
        };
      }
      __name(createResumableState, "createResumableState");
      __name2(createResumableState, "createResumableState");
      function createPreambleState() {
        return {
          htmlChunks: null,
          headChunks: null,
          bodyChunks: null,
          contribution: NoContribution
        };
      }
      __name(createPreambleState, "createPreambleState");
      __name2(createPreambleState, "createPreambleState");
      function createFormatContext(insertionMode, selectedValue, tagScope) {
        return {
          insertionMode,
          selectedValue,
          tagScope
        };
      }
      __name(createFormatContext, "createFormatContext");
      __name2(createFormatContext, "createFormatContext");
      function getChildFormatContext(parentContext, type6, props) {
        switch (type6) {
          case "noscript":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 1
            );
          case "select":
            return createFormatContext(
              HTML_MODE,
              null != props.value ? props.value : props.defaultValue,
              parentContext.tagScope
            );
          case "svg":
            return createFormatContext(SVG_MODE, null, parentContext.tagScope);
          case "picture":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 2
            );
          case "math":
            return createFormatContext(MATHML_MODE, null, parentContext.tagScope);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null, parentContext.tagScope);
          case "table":
            return createFormatContext(
              HTML_TABLE_MODE,
              null,
              parentContext.tagScope
            );
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(
              HTML_TABLE_BODY_MODE,
              null,
              parentContext.tagScope
            );
          case "colgroup":
            return createFormatContext(
              HTML_COLGROUP_MODE,
              null,
              parentContext.tagScope
            );
          case "tr":
            return createFormatContext(
              HTML_TABLE_ROW_MODE,
              null,
              parentContext.tagScope
            );
          case "head":
            if (parentContext.insertionMode < HTML_MODE)
              return createFormatContext(
                HTML_HEAD_MODE,
                null,
                parentContext.tagScope
              );
            break;
          case "html":
            if (parentContext.insertionMode === ROOT_HTML_MODE)
              return createFormatContext(
                HTML_HTML_MODE,
                null,
                parentContext.tagScope
              );
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, parentContext.tagScope) : parentContext;
      }
      __name(getChildFormatContext, "getChildFormatContext");
      __name2(getChildFormatContext, "getChildFormatContext");
      function pushStyleAttribute(target, style) {
        if ("object" !== typeof style)
          throw Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        var isFirst = true, styleName;
        for (styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
              if (0 === styleName.indexOf("--")) {
                var nameChunk = escapeTextForBrowser(styleName);
                checkCSSPropertyStringCoercion(styleValue, styleName);
                styleValue = escapeTextForBrowser(("" + styleValue).trim());
              } else {
                nameChunk = styleName;
                var value = styleValue;
                if (-1 < nameChunk.indexOf("-")) {
                  var name = nameChunk;
                  warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported style property %s. Did you mean %s?",
                    name,
                    camelize(name.replace(msPattern$1, "ms-"))
                  ));
                } else if (badVendoredStyleNamePattern.test(nameChunk))
                  name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                    name,
                    name.charAt(0).toUpperCase() + name.slice(1)
                  ));
                else if (badStyleValueWithSemicolonPattern.test(value)) {
                  name = nameChunk;
                  var value$jscomp$0 = value;
                  warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                    `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                    name,
                    value$jscomp$0.replace(
                      badStyleValueWithSemicolonPattern,
                      ""
                    )
                  ));
                }
                "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                  "`NaN` is an invalid value for the `%s` css style property.",
                  nameChunk
                )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                  "`Infinity` is an invalid value for the `%s` css style property.",
                  nameChunk
                )));
                nameChunk = styleName;
                value = styleNameCache.get(nameChunk);
                void 0 !== value ? nameChunk = value : (value = escapeTextForBrowser(
                  nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                ), styleNameCache.set(nameChunk, value), nameChunk = value);
                "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser(
                  ("" + styleValue).trim()
                ));
              }
              isFirst ? (isFirst = false, target.push(
                styleAttributeStart,
                nameChunk,
                styleAssign,
                styleValue
              )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      __name(pushStyleAttribute, "pushStyleAttribute");
      __name2(pushStyleAttribute, "pushStyleAttribute");
      function pushBooleanAttribute(target, name, value) {
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
      }
      __name(pushBooleanAttribute, "pushBooleanAttribute");
      __name2(pushBooleanAttribute, "pushBooleanAttribute");
      function pushStringAttribute(target, name, value) {
        "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
          attributeSeparator,
          name,
          attributeAssign,
          escapeTextForBrowser(value),
          attributeEnd
        );
      }
      __name(pushStringAttribute, "pushStringAttribute");
      __name2(pushStringAttribute, "pushStringAttribute");
      function pushAdditionalFormField(value, key) {
        this.push('<input type="hidden"');
        validateAdditionalFormField(value);
        pushStringAttribute(this, "name", key);
        pushStringAttribute(this, "value", value);
        this.push(endOfStartTagSelfClosing);
      }
      __name(pushAdditionalFormField, "pushAdditionalFormField");
      __name2(pushAdditionalFormField, "pushAdditionalFormField");
      function validateAdditionalFormField(value) {
        if ("string" !== typeof value)
          throw Error(
            "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
          );
      }
      __name(validateAdditionalFormField, "validateAdditionalFormField");
      __name2(validateAdditionalFormField, "validateAdditionalFormField");
      function getCustomFormFields(resumableState, formAction) {
        if ("function" === typeof formAction.$$FORM_ACTION) {
          var id3 = resumableState.nextFormID++;
          resumableState = resumableState.idPrefix + id3;
          try {
            var customFields = formAction.$$FORM_ACTION(resumableState);
            if (customFields) {
              var formData = customFields.data;
              null != formData && formData.forEach(validateAdditionalFormField);
            }
            return customFields;
          } catch (x2) {
            if ("object" === typeof x2 && null !== x2 && "function" === typeof x2.then)
              throw x2;
            console.error(
              "Failed to serialize an action for progressive enhancement:\n%s",
              x2
            );
          }
        }
        return null;
      }
      __name(getCustomFormFields, "getCustomFormFields");
      __name2(getCustomFormFields, "getCustomFormFields");
      function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
        var formData = null;
        if ("function" === typeof formAction) {
          null === name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          ));
          null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          ));
          null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ));
          var customFields = getCustomFormFields(resumableState, formAction);
          null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
            attributeSeparator,
            "formAction",
            attributeAssign,
            actionJavaScriptURL,
            attributeEnd
          ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != name && pushAttribute(target, "name", name);
        null != formAction && pushAttribute(target, "formAction", formAction);
        null != formEncType && pushAttribute(target, "formEncType", formEncType);
        null != formMethod && pushAttribute(target, "formMethod", formMethod);
        null != formTarget && pushAttribute(target, "formTarget", formTarget);
        return formData;
      }
      __name(pushFormActionAttribute, "pushFormActionAttribute");
      __name2(pushFormActionAttribute, "pushFormActionAttribute");
      function pushAttribute(target, name, value) {
        switch (name) {
          case "className":
            pushStringAttribute(target, "class", value);
            break;
          case "tabIndex":
            pushStringAttribute(target, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            pushStringAttribute(target, name, value);
            break;
          case "style":
            pushStyleAttribute(target, value);
            break;
          case "src":
          case "href":
            if ("" === value) {
              "src" === name ? console.error(
                'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              ) : console.error(
                'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              );
              break;
            }
          case "action":
          case "formAction":
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "ref":
            break;
          case "autoFocus":
          case "multiple":
          case "muted":
            pushBooleanAttribute(target, name.toLowerCase(), value);
            break;
          case "xlinkHref":
            if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              "xlink:href",
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "inert":
            "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = true, console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              name
            ));
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
            break;
          case "capture":
          case "download":
            true === value ? target.push(attributeSeparator, name, attributeEmptyString) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "rowSpan":
          case "start":
            "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "xlinkActuate":
            pushStringAttribute(target, "xlink:actuate", value);
            break;
          case "xlinkArcrole":
            pushStringAttribute(target, "xlink:arcrole", value);
            break;
          case "xlinkRole":
            pushStringAttribute(target, "xlink:role", value);
            break;
          case "xlinkShow":
            pushStringAttribute(target, "xlink:show", value);
            break;
          case "xlinkTitle":
            pushStringAttribute(target, "xlink:title", value);
            break;
          case "xlinkType":
            pushStringAttribute(target, "xlink:type", value);
            break;
          case "xmlBase":
            pushStringAttribute(target, "xml:base", value);
            break;
          case "xmlLang":
            pushStringAttribute(target, "xml:lang", value);
            break;
          case "xmlSpace":
            pushStringAttribute(target, "xml:space", value);
            break;
          default:
            if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
              if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
                switch (typeof value) {
                  case "function":
                  case "symbol":
                    return;
                  case "boolean":
                    var prefix2 = name.toLowerCase().slice(0, 5);
                    if ("data-" !== prefix2 && "aria-" !== prefix2)
                      return;
                }
                target.push(
                  attributeSeparator,
                  name,
                  attributeAssign,
                  escapeTextForBrowser(value),
                  attributeEnd
                );
              }
            }
        }
      }
      __name(pushAttribute, "pushAttribute");
      __name2(pushAttribute, "pushAttribute");
      function pushInnerHTML(target, innerHTML, children) {
        if (null != innerHTML) {
          if (null != children)
            throw Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          if ("object" !== typeof innerHTML || !("__html" in innerHTML))
            throw Error(
              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
            );
          innerHTML = innerHTML.__html;
          null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
        }
      }
      __name(pushInnerHTML, "pushInnerHTML");
      __name2(pushInnerHTML, "pushInnerHTML");
      function checkSelectProp(props, propName) {
        var value = props[propName];
        null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
          "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
          propName
        ) : !props.multiple && value && console.error(
          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
          propName
        ));
      }
      __name(checkSelectProp, "checkSelectProp");
      __name2(checkSelectProp, "checkSelectProp");
      function flattenOptionChildren(children) {
        var content = "";
        React31.Children.forEach(children, function(child) {
          null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
            "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
          )));
        });
        return content;
      }
      __name(flattenOptionChildren, "flattenOptionChildren");
      __name2(flattenOptionChildren, "flattenOptionChildren");
      function injectFormReplayingRuntime(resumableState, renderState) {
        (resumableState.instructions & 16) === NothingSent && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
          renderState.startInlineScript,
          formReplayingRuntimeScript,
          "<\/script>"
        ));
      }
      __name(injectFormReplayingRuntime, "injectFormReplayingRuntime");
      __name2(injectFormReplayingRuntime, "injectFormReplayingRuntime");
      function pushLinkImpl(target, props) {
        target.push(startChunkForTag("link"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushLinkImpl, "pushLinkImpl");
      __name2(pushLinkImpl, "pushLinkImpl");
      function escapeStyleTextContent(styleText) {
        checkHtmlStringCoercion(styleText);
        return ("" + styleText).replace(styleRegex, styleReplacer);
      }
      __name(escapeStyleTextContent, "escapeStyleTextContent");
      __name2(escapeStyleTextContent, "escapeStyleTextContent");
      function pushSelfClosing(target, props, tag) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushSelfClosing, "pushSelfClosing");
      __name2(pushSelfClosing, "pushSelfClosing");
      function pushTitleImpl(target, props) {
        target.push(startChunkForTag("title"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
        "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
        pushInnerHTML(target, innerHTML, children);
        target.push(endChunkForTag("title"));
        return null;
      }
      __name(pushTitleImpl, "pushTitleImpl");
      __name2(pushTitleImpl, "pushTitleImpl");
      function pushScriptImpl(target, props) {
        target.push(startChunkForTag("script"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
          "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
          props
        ));
        pushInnerHTML(target, innerHTML, children);
        "string" === typeof children && target.push(escapeEntireInlineScriptContent(children));
        target.push(endChunkForTag("script"));
        return null;
      }
      __name(pushScriptImpl, "pushScriptImpl");
      __name2(pushScriptImpl, "pushScriptImpl");
      function pushStartSingletonElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return tag;
      }
      __name(pushStartSingletonElement, "pushStartSingletonElement");
      __name2(pushStartSingletonElement, "pushStartSingletonElement");
      function pushStartGenericElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
      }
      __name(pushStartGenericElement, "pushStartGenericElement");
      __name2(pushStartGenericElement, "pushStartGenericElement");
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (void 0 === tagStartChunk) {
          if (!VALID_TAG_REGEX.test(tag))
            throw Error("Invalid tag: " + tag);
          tagStartChunk = "<" + tag;
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      __name(startChunkForTag, "startChunkForTag");
      __name2(startChunkForTag, "startChunkForTag");
      function pushStartInstance(target$jscomp$0, type6, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
        validateProperties$2(type6, props);
        "input" !== type6 && "textarea" !== type6 && "select" !== type6 || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type6 && props.multiple ? console.error(
          "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
          type6
        ) : console.error(
          "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
          type6
        ));
        b:
          if (-1 === type6.indexOf("-"))
            var JSCompiler_inline_result = false;
          else
            switch (type6) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                JSCompiler_inline_result = false;
                break b;
              default:
                JSCompiler_inline_result = true;
            }
        JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type6, props, null);
        !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
        formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type6.indexOf("-") && type6.toLowerCase() !== type6 && console.error(
          "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
          type6
        );
        switch (type6) {
          case "div":
          case "span":
          case "svg":
          case "path":
            break;
          case "a":
            target$jscomp$0.push(startChunkForTag("a"));
            var children = null, innerHTML = null, propKey;
            for (propKey in props)
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "children":
                      children = propValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML = propValue;
                      break;
                    case "href":
                      "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                      break;
                    default:
                      pushAttribute(target$jscomp$0, propKey, propValue);
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML, children);
            if ("string" === typeof children) {
              target$jscomp$0.push(escapeTextForBrowser(children));
              var JSCompiler_inline_result$jscomp$0 = null;
            } else
              JSCompiler_inline_result$jscomp$0 = children;
            return JSCompiler_inline_result$jscomp$0;
          case "g":
          case "p":
          case "li":
            break;
          case "select":
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
              "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultSelectValue = true);
            target$jscomp$0.push(startChunkForTag("select"));
            var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
            for (propKey$jscomp$0 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                var propValue$jscomp$0 = props[propKey$jscomp$0];
                if (null != propValue$jscomp$0)
                  switch (propKey$jscomp$0) {
                    case "children":
                      children$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "defaultValue":
                    case "value":
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$0,
                        propValue$jscomp$0
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
            return children$jscomp$0;
          case "option":
            var selectedValue = formatContext.selectedValue;
            target$jscomp$0.push(startChunkForTag("option"));
            var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
            for (propKey$jscomp$1 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                var propValue$jscomp$1 = props[propKey$jscomp$1];
                if (null != propValue$jscomp$1)
                  switch (propKey$jscomp$1) {
                    case "children":
                      children$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "selected":
                      selected = propValue$jscomp$1;
                      didWarnSelectedSetOnOption || (console.error(
                        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                      ), didWarnSelectedSetOnOption = true);
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "value":
                      value = propValue$jscomp$1;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$1,
                        propValue$jscomp$1
                      );
                  }
              }
            if (null != selectedValue) {
              if (null !== value) {
                checkAttributeStringCoercion(value, "value");
                var stringValue = "" + value;
              } else
                null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                  "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                )), stringValue = flattenOptionChildren(children$jscomp$1);
              if (isArrayImpl(selectedValue))
                for (var i2 = 0; i2 < selectedValue.length; i2++) {
                  if (checkAttributeStringCoercion(selectedValue[i2], "value"), "" + selectedValue[i2] === stringValue) {
                    target$jscomp$0.push(' selected=""');
                    break;
                  }
                }
              else
                checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
            } else
              selected && target$jscomp$0.push(' selected=""');
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
            return children$jscomp$1;
          case "textarea":
            checkControlledValueProps("textarea", props);
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
              "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultTextareaValue = true);
            target$jscomp$0.push(startChunkForTag("textarea"));
            var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
            for (propKey$jscomp$2 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                var propValue$jscomp$2 = props[propKey$jscomp$2];
                if (null != propValue$jscomp$2)
                  switch (propKey$jscomp$2) {
                    case "children":
                      children$jscomp$2 = propValue$jscomp$2;
                      break;
                    case "value":
                      value$jscomp$0 = propValue$jscomp$2;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$jscomp$2;
                      break;
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$2,
                        propValue$jscomp$2
                      );
                  }
              }
            null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
            target$jscomp$0.push(endOfStartTag);
            if (null != children$jscomp$2) {
              console.error(
                "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
              );
              if (null != value$jscomp$0)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children$jscomp$2)) {
                if (1 < children$jscomp$2.length)
                  throw Error("<textarea> can only have at most one child.");
                checkHtmlStringCoercion(children$jscomp$2[0]);
                value$jscomp$0 = "" + children$jscomp$2[0];
              }
              checkHtmlStringCoercion(children$jscomp$2);
              value$jscomp$0 = "" + children$jscomp$2;
            }
            "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
            null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0)));
            return null;
          case "input":
            checkControlledValueProps("input", props);
            target$jscomp$0.push(startChunkForTag("input"));
            var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
            for (propKey$jscomp$3 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                var propValue$jscomp$3 = props[propKey$jscomp$3];
                if (null != propValue$jscomp$3)
                  switch (propKey$jscomp$3) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    case "name":
                      name = propValue$jscomp$3;
                      break;
                    case "formAction":
                      formAction = propValue$jscomp$3;
                      break;
                    case "formEncType":
                      formEncType = propValue$jscomp$3;
                      break;
                    case "formMethod":
                      formMethod = propValue$jscomp$3;
                      break;
                    case "formTarget":
                      formTarget = propValue$jscomp$3;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$jscomp$3;
                      break;
                    case "defaultValue":
                      defaultValue$jscomp$0 = propValue$jscomp$3;
                      break;
                    case "checked":
                      checked = propValue$jscomp$3;
                      break;
                    case "value":
                      value$jscomp$1 = propValue$jscomp$3;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$3,
                        propValue$jscomp$3
                      );
                  }
              }
            null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'An input can only specify a formAction along with type="submit" or type="image".'
            ));
            var formData = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction,
              formEncType,
              formMethod,
              formTarget,
              name
            );
            null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
              "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultChecked = true);
            null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
              "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultInputValue = true);
            null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
            null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
            target$jscomp$0.push(endOfStartTagSelfClosing);
            null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
            return null;
          case "button":
            target$jscomp$0.push(startChunkForTag("button"));
            var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
            for (propKey$jscomp$4 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                var propValue$jscomp$4 = props[propKey$jscomp$4];
                if (null != propValue$jscomp$4)
                  switch (propKey$jscomp$4) {
                    case "children":
                      children$jscomp$3 = propValue$jscomp$4;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$2 = propValue$jscomp$4;
                      break;
                    case "name":
                      name$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formAction":
                      formAction$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formEncType":
                      formEncType$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formMethod":
                      formMethod$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formTarget":
                      formTarget$jscomp$0 = propValue$jscomp$4;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$4,
                        propValue$jscomp$4
                      );
                  }
              }
            null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'A button can only specify a formAction along with type="submit" or no type.'
            ));
            var formData$jscomp$0 = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction$jscomp$0,
              formEncType$jscomp$0,
              formMethod$jscomp$0,
              formTarget$jscomp$0,
              name$jscomp$0
            );
            target$jscomp$0.push(endOfStartTag);
            null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
            if ("string" === typeof children$jscomp$3) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
              var JSCompiler_inline_result$jscomp$1 = null;
            } else
              JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
            return JSCompiler_inline_result$jscomp$1;
          case "form":
            target$jscomp$0.push(startChunkForTag("form"));
            var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
            for (propKey$jscomp$5 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                var propValue$jscomp$5 = props[propKey$jscomp$5];
                if (null != propValue$jscomp$5)
                  switch (propKey$jscomp$5) {
                    case "children":
                      children$jscomp$4 = propValue$jscomp$5;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$3 = propValue$jscomp$5;
                      break;
                    case "action":
                      formAction$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "encType":
                      formEncType$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "method":
                      formMethod$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "target":
                      formTarget$jscomp$1 = propValue$jscomp$5;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$5,
                        propValue$jscomp$5
                      );
                  }
              }
            var formData$jscomp$1 = null, formActionName = null;
            if ("function" === typeof formAction$jscomp$1) {
              null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              ));
              null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ));
              var customFields = getCustomFormFields(
                resumableState,
                formAction$jscomp$1
              );
              null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                attributeSeparator,
                "action",
                attributeAssign,
                actionJavaScriptURL,
                attributeEnd
              ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
            }
            null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
            null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
            null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
            null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
            target$jscomp$0.push(endOfStartTag);
            null !== formActionName && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
              pushAdditionalFormField,
              target$jscomp$0
            ));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
            if ("string" === typeof children$jscomp$4) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
              var JSCompiler_inline_result$jscomp$2 = null;
            } else
              JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
            return JSCompiler_inline_result$jscomp$2;
          case "menuitem":
            target$jscomp$0.push(startChunkForTag("menuitem"));
            for (var propKey$jscomp$6 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                var propValue$jscomp$6 = props[propKey$jscomp$6];
                if (null != propValue$jscomp$6)
                  switch (propKey$jscomp$6) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$6,
                        propValue$jscomp$6
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            return null;
          case "object":
            target$jscomp$0.push(startChunkForTag("object"));
            var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
            for (propKey$jscomp$7 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                var propValue$jscomp$7 = props[propKey$jscomp$7];
                if (null != propValue$jscomp$7)
                  switch (propKey$jscomp$7) {
                    case "children":
                      children$jscomp$5 = propValue$jscomp$7;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$4 = propValue$jscomp$7;
                      break;
                    case "data":
                      checkAttributeStringCoercion(propValue$jscomp$7, "data");
                      var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                      if ("" === sanitizedValue) {
                        console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          propKey$jscomp$7,
                          propKey$jscomp$7
                        );
                        break;
                      }
                      target$jscomp$0.push(
                        attributeSeparator,
                        "data",
                        attributeAssign,
                        escapeTextForBrowser(sanitizedValue),
                        attributeEnd
                      );
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$7,
                        propValue$jscomp$7
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
            if ("string" === typeof children$jscomp$5) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
              var JSCompiler_inline_result$jscomp$3 = null;
            } else
              JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
            return JSCompiler_inline_result$jscomp$3;
          case "title":
            var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
              Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                children$jscomp$6.length
              ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                "function" === typeof child ? "a Function" : "a Sybmol"
              ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
              ) : console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
              ));
            }
            if (insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                target$jscomp$0,
                props
              );
            else
              isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
            return JSCompiler_inline_result$jscomp$4;
          case "link":
            var rel = props.rel, href = props.href, precedence = props.precedence;
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
              "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
              ));
              pushLinkImpl(target$jscomp$0, props);
              var JSCompiler_inline_result$jscomp$5 = null;
            } else if ("stylesheet" === props.rel)
              if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                if ("string" === typeof precedence) {
                  if (null != props.disabled)
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                    );
                  else if (props.onLoad || props.onError) {
                    var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                      propDescription,
                      propDescription
                    );
                  }
                }
                JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                );
              } else {
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                  href
                ) ? resumableState.styleResources[href] : void 0;
                if (resourceState !== EXISTS) {
                  resumableState.styleResources[href] = EXISTS;
                  styleQueue || (styleQueue = {
                    precedence: escapeTextForBrowser(precedence),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(precedence, styleQueue));
                  var resource = {
                    state: PENDING$1,
                    props: assign({}, props, {
                      "data-precedence": props.precedence,
                      precedence: null
                    })
                  };
                  if (resourceState) {
                    2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                    var preloadResource = renderState.preloads.stylesheets.get(href);
                    preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                  }
                  styleQueue.sheets.set(href, resource);
                  hoistableState && hoistableState.stylesheets.add(resource);
                } else if (styleQueue) {
                  var _resource = styleQueue.sheets.get(href);
                  _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                }
                textEmbedded && target$jscomp$0.push("<!-- -->");
                JSCompiler_inline_result$jscomp$5 = null;
              }
            else
              props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                target$jscomp$0,
                props
              ) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
            return JSCompiler_inline_result$jscomp$5;
          case "script":
            var asyncProp = props.async;
            if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                target$jscomp$0,
                props
              );
            else {
              var key = props.src;
              if ("module" === props.type) {
                var resources = resumableState.moduleScriptResources;
                var preloads = renderState.preloads.moduleScripts;
              } else
                resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
              var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
              if (resourceState$jscomp$0 !== EXISTS) {
                resources[key] = EXISTS;
                var scriptProps = props;
                if (resourceState$jscomp$0) {
                  2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                  var preloadResource$jscomp$0 = preloads.get(key);
                  preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                }
                var resource$jscomp$0 = [];
                renderState.scripts.add(resource$jscomp$0);
                pushScriptImpl(resource$jscomp$0, scriptProps);
              }
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$6 = null;
            }
            return JSCompiler_inline_result$jscomp$6;
          case "style":
            var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
              );
            }
            var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
            if (insertionMode$jscomp$0 === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
              target$jscomp$0.push(startChunkForTag("style"));
              var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
              for (propKey$jscomp$8 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                  var propValue$jscomp$8 = props[propKey$jscomp$8];
                  if (null != propValue$jscomp$8)
                    switch (propKey$jscomp$8) {
                      case "children":
                        children$jscomp$8 = propValue$jscomp$8;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$5 = propValue$jscomp$8;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$8,
                          propValue$jscomp$8
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
              "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$5,
                children$jscomp$8
              );
              target$jscomp$0.push(endChunkForTag("style"));
              var JSCompiler_inline_result$jscomp$7 = null;
            } else {
              href$jscomp$0.includes(" ") && console.error(
                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                href$jscomp$0
              );
              var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
              if (resourceState$jscomp$1 !== EXISTS) {
                resumableState.styleResources[href$jscomp$0] = EXISTS;
                resourceState$jscomp$1 && console.error(
                  'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                  href$jscomp$0
                );
                styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                  escapeTextForBrowser(href$jscomp$0)
                ) : (styleQueue$jscomp$0 = {
                  precedence: escapeTextForBrowser(precedence$jscomp$0),
                  rules: [],
                  hrefs: [escapeTextForBrowser(href$jscomp$0)],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(
                  precedence$jscomp$0,
                  styleQueue$jscomp$0
                ));
                var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                for (propKey$jscomp$9 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                    var propValue$jscomp$9 = props[propKey$jscomp$9];
                    if (null != propValue$jscomp$9)
                      switch (propKey$jscomp$9) {
                        case "children":
                          children$jscomp$9 = propValue$jscomp$9;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$6 = propValue$jscomp$9;
                      }
                  }
                var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(escapeStyleTextContent(child$jscomp$2));
                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
              }
              styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$7 = void 0;
            }
            return JSCompiler_inline_result$jscomp$7;
          case "meta":
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                target$jscomp$0,
                props,
                "meta"
              );
            else
              textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                renderState.hoistableChunks,
                props,
                "meta"
              );
            return JSCompiler_inline_result$jscomp$8;
          case "listing":
          case "pre":
            target$jscomp$0.push(startChunkForTag(type6));
            var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
            for (propKey$jscomp$10 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                var propValue$jscomp$10 = props[propKey$jscomp$10];
                if (null != propValue$jscomp$10)
                  switch (propKey$jscomp$10) {
                    case "children":
                      children$jscomp$10 = propValue$jscomp$10;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$7 = propValue$jscomp$10;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$10,
                        propValue$jscomp$10
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            if (null != innerHTML$jscomp$7) {
              if (null != children$jscomp$10)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              var html = innerHTML$jscomp$7.__html;
              null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
            }
            "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
            return children$jscomp$10;
          case "img":
            var src = props.src, srcSet = props.srcSet;
            if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
              var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
              if (resource$jscomp$1) {
                if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                  promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
              } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                var input = props.crossOrigin;
                var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                var headers = renderState.headers, header;
                headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                  imageSrcSet: props.srcSet,
                  imageSizes: props.sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  nonce: props.nonce,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.refererPolicy
                }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                  rel: "preload",
                  as: "image",
                  href: srcSet ? void 0 : src,
                  imageSrcSet: srcSet,
                  imageSizes: sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.referrerPolicy
                }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
              }
            }
            return pushSelfClosing(target$jscomp$0, props, "img");
          case "base":
          case "area":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target$jscomp$0, props, type6);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            break;
          case "head":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble = preambleState || renderState.preamble;
              if (preamble.headChunks)
                throw Error("The `<head>` tag may only be rendered once.");
              preamble.headChunks = [];
              var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                preamble.headChunks,
                props,
                "head"
              );
            } else
              JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "head"
              );
            return JSCompiler_inline_result$jscomp$9;
          case "body":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble$jscomp$0 = preambleState || renderState.preamble;
              if (preamble$jscomp$0.bodyChunks)
                throw Error("The `<body>` tag may only be rendered once.");
              preamble$jscomp$0.bodyChunks = [];
              var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                preamble$jscomp$0.bodyChunks,
                props,
                "body"
              );
            } else
              JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "body"
              );
            return JSCompiler_inline_result$jscomp$10;
          case "html":
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              var preamble$jscomp$1 = preambleState || renderState.preamble;
              if (preamble$jscomp$1.htmlChunks)
                throw Error("The `<html>` tag may only be rendered once.");
              preamble$jscomp$1.htmlChunks = [doctypeChunk];
              var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                preamble$jscomp$1.htmlChunks,
                props,
                "html"
              );
            } else
              JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "html"
              );
            return JSCompiler_inline_result$jscomp$11;
          default:
            if (-1 !== type6.indexOf("-")) {
              target$jscomp$0.push(startChunkForTag(type6));
              var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
              for (propKey$jscomp$11 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                  var propValue$jscomp$11 = props[propKey$jscomp$11];
                  if (null != propValue$jscomp$11) {
                    var attributeName = propKey$jscomp$11;
                    switch (propKey$jscomp$11) {
                      case "children":
                        children$jscomp$11 = propValue$jscomp$11;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$8 = propValue$jscomp$11;
                        break;
                      case "style":
                        pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                        break;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "ref":
                        break;
                      case "className":
                        attributeName = "class";
                      default:
                        if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                          if (true === propValue$jscomp$11)
                            propValue$jscomp$11 = "";
                          else if ("object" === typeof propValue$jscomp$11)
                            continue;
                          target$jscomp$0.push(
                            attributeSeparator,
                            attributeName,
                            attributeAssign,
                            escapeTextForBrowser(propValue$jscomp$11),
                            attributeEnd
                          );
                        }
                    }
                  }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$8,
                children$jscomp$11
              );
              return children$jscomp$11;
            }
        }
        return pushStartGenericElement(target$jscomp$0, props, type6);
      }
      __name(pushStartInstance, "pushStartInstance");
      __name2(pushStartInstance, "pushStartInstance");
      function endChunkForTag(tag) {
        var chunk = endTagCache.get(tag);
        void 0 === chunk && (chunk = "</" + tag + ">", endTagCache.set(tag, chunk));
        return chunk;
      }
      __name(endChunkForTag, "endChunkForTag");
      __name2(endChunkForTag, "endChunkForTag");
      function hoistPreambleState(renderState, preambleState) {
        renderState = renderState.preamble;
        null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
        null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
        null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
      }
      __name(hoistPreambleState, "hoistPreambleState");
      __name2(hoistPreambleState, "hoistPreambleState");
      function writeBootstrap(destination, renderState) {
        renderState = renderState.bootstrapChunks;
        for (var i2 = 0; i2 < renderState.length - 1; i2++)
          destination.push(renderState[i2]);
        return i2 < renderState.length ? (i2 = renderState[i2], renderState.length = 0, destination.push(i2)) : true;
      }
      __name(writeBootstrap, "writeBootstrap");
      __name2(writeBootstrap, "writeBootstrap");
      function writeStartPendingSuspenseBoundary(destination, renderState, id3) {
        destination.push(startPendingSuspenseBoundary1);
        if (null === id3)
          throw Error(
            "An ID must have been assigned before we can complete the boundary."
          );
        destination.push(renderState.boundaryPrefix);
        renderState = id3.toString(16);
        destination.push(renderState);
        return destination.push(startPendingSuspenseBoundary2);
      }
      __name(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
      __name2(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
      function writePreambleContribution(destination, preambleState) {
        preambleState = preambleState.contribution;
        preambleState !== NoContribution && (destination.push(boundaryPreambleContributionChunkStart), destination.push("" + preambleState), destination.push(boundaryPreambleContributionChunkEnd));
      }
      __name(writePreambleContribution, "writePreambleContribution");
      __name2(writePreambleContribution, "writePreambleContribution");
      function writeStartSegment(destination, renderState, formatContext, id3) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return destination.push(startSegmentHTML), destination.push(renderState.segmentPrefix), renderState = id3.toString(16), destination.push(renderState), destination.push(startSegmentHTML2);
          case SVG_MODE:
            return destination.push(startSegmentSVG), destination.push(renderState.segmentPrefix), renderState = id3.toString(16), destination.push(renderState), destination.push(startSegmentSVG2);
          case MATHML_MODE:
            return destination.push(startSegmentMathML), destination.push(renderState.segmentPrefix), renderState = id3.toString(16), destination.push(renderState), destination.push(startSegmentMathML2);
          case HTML_TABLE_MODE:
            return destination.push(startSegmentTable), destination.push(renderState.segmentPrefix), renderState = id3.toString(16), destination.push(renderState), destination.push(startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return destination.push(startSegmentTableBody), destination.push(renderState.segmentPrefix), renderState = id3.toString(16), destination.push(renderState), destination.push(startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return destination.push(startSegmentTableRow), destination.push(renderState.segmentPrefix), renderState = id3.toString(16), destination.push(renderState), destination.push(startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return destination.push(startSegmentColGroup), destination.push(renderState.segmentPrefix), renderState = id3.toString(16), destination.push(renderState), destination.push(startSegmentColGroup2);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeStartSegment, "writeStartSegment");
      __name2(writeStartSegment, "writeStartSegment");
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return destination.push(endSegmentHTML);
          case SVG_MODE:
            return destination.push(endSegmentSVG);
          case MATHML_MODE:
            return destination.push(endSegmentMathML);
          case HTML_TABLE_MODE:
            return destination.push(endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return destination.push(endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return destination.push(endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return destination.push(endSegmentColGroup);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeEndSegment, "writeEndSegment");
      __name2(writeEndSegment, "writeEndSegment");
      function escapeJSStringsForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInInstructionScripts,
          function(match2) {
            switch (match2) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
      __name2(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
      function escapeJSObjectForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInScripts,
          function(match2) {
            switch (match2) {
              case "&":
                return "\\u0026";
              case ">":
                return "\\u003e";
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
      __name2(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
      function flushStyleTagsLateForBoundary(styleQueue) {
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        0 < rules.length && 0 === hrefs.length && console.error(
          "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
        );
        var i2 = 0;
        if (hrefs.length) {
          this.push(lateStyleTagResourceOpen1);
          this.push(styleQueue.precedence);
          for (this.push(lateStyleTagResourceOpen2); i2 < hrefs.length - 1; i2++)
            this.push(hrefs[i2]), this.push(spaceSeparator);
          this.push(hrefs[i2]);
          this.push(lateStyleTagResourceOpen3);
          for (i2 = 0; i2 < rules.length; i2++)
            this.push(rules[i2]);
          destinationHasCapacity = this.push(lateStyleTagTemplateClose);
          currentlyRenderingBoundaryHasStylesToHoist = true;
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
      __name2(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
      function hasStylesToHoist(stylesheet) {
        return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
      }
      __name(hasStylesToHoist, "hasStylesToHoist");
      __name2(hasStylesToHoist, "hasStylesToHoist");
      function writeHoistablesForBoundary(destination, hoistableState, renderState) {
        currentlyRenderingBoundaryHasStylesToHoist = false;
        destinationHasCapacity = true;
        hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
        hoistableState.stylesheets.forEach(hasStylesToHoist);
        currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
        return destinationHasCapacity;
      }
      __name(writeHoistablesForBoundary, "writeHoistablesForBoundary");
      __name2(writeHoistablesForBoundary, "writeHoistablesForBoundary");
      function flushResource(resource) {
        for (var i2 = 0; i2 < resource.length; i2++)
          this.push(resource[i2]);
        resource.length = 0;
      }
      __name(flushResource, "flushResource");
      __name2(flushResource, "flushResource");
      function flushStyleInPreamble(stylesheet) {
        pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
        for (var i2 = 0; i2 < stylesheetFlushingQueue.length; i2++)
          this.push(stylesheetFlushingQueue[i2]);
        stylesheetFlushingQueue.length = 0;
        stylesheet.state = PREAMBLE;
      }
      __name(flushStyleInPreamble, "flushStyleInPreamble");
      __name2(flushStyleInPreamble, "flushStyleInPreamble");
      function flushStylesInPreamble(styleQueue) {
        var hasStylesheets = 0 < styleQueue.sheets.size;
        styleQueue.sheets.forEach(flushStyleInPreamble, this);
        styleQueue.sheets.clear();
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        if (!hasStylesheets || hrefs.length) {
          this.push(styleTagResourceOpen1);
          this.push(styleQueue.precedence);
          styleQueue = 0;
          if (hrefs.length) {
            for (this.push(styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
              this.push(hrefs[styleQueue]), this.push(spaceSeparator);
            this.push(hrefs[styleQueue]);
          }
          this.push(styleTagResourceOpen3);
          for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
            this.push(rules[styleQueue]);
          this.push(styleTagResourceClose);
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStylesInPreamble, "flushStylesInPreamble");
      __name2(flushStylesInPreamble, "flushStylesInPreamble");
      function preloadLateStyle(stylesheet) {
        if (stylesheet.state === PENDING$1) {
          stylesheet.state = PRELOADED;
          var props = stylesheet.props;
          pushLinkImpl(stylesheetFlushingQueue, {
            rel: "preload",
            as: "style",
            href: stylesheet.props.href,
            crossOrigin: props.crossOrigin,
            fetchPriority: props.fetchPriority,
            integrity: props.integrity,
            media: props.media,
            hrefLang: props.hrefLang,
            referrerPolicy: props.referrerPolicy
          });
          for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
            this.push(stylesheetFlushingQueue[stylesheet]);
          stylesheetFlushingQueue.length = 0;
        }
      }
      __name(preloadLateStyle, "preloadLateStyle");
      __name2(preloadLateStyle, "preloadLateStyle");
      function preloadLateStyles(styleQueue) {
        styleQueue.sheets.forEach(preloadLateStyle, this);
        styleQueue.sheets.clear();
      }
      __name(preloadLateStyles, "preloadLateStyles");
      __name2(preloadLateStyles, "preloadLateStyles");
      function writeStyleResourceDependenciesInJS(destination, hoistableState) {
        destination.push(arrayFirstOpenBracket);
        var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
        hoistableState.stylesheets.forEach(function(resource) {
          if (resource.state !== PREAMBLE)
            if (resource.state === LATE)
              destination.push(nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), resource = escapeJSObjectForInstructionScripts("" + resource), destination.push(resource), destination.push(arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
            else {
              destination.push(nextArrayOpenBrackChunk);
              var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
              coercedHref = escapeJSObjectForInstructionScripts(coercedHref);
              destination.push(coercedHref);
              checkAttributeStringCoercion(precedence, "precedence");
              precedence = "" + precedence;
              destination.push(arrayInterstitial);
              precedence = escapeJSObjectForInstructionScripts(precedence);
              destination.push(precedence);
              for (var propKey in props)
                if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                  switch (propKey) {
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      writeStyleResourceAttributeInJS(
                        destination,
                        propKey,
                        precedence
                      );
                  }
              destination.push(arrayCloseBracket);
              nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              resource.state = LATE;
            }
        });
        destination.push(arrayCloseBracket);
      }
      __name(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
      __name2(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
      function writeStyleResourceAttributeInJS(destination, name, value) {
        var attributeName = name.toLowerCase();
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        switch (name) {
          case "innerHTML":
          case "dangerouslySetInnerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "style":
          case "ref":
            return;
          case "className":
            attributeName = "class";
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          case "hidden":
            if (false === value)
              return;
            name = "";
            break;
          case "src":
          case "href":
            value = sanitizeURL(value);
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          default:
            if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
              return;
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
        }
        destination.push(arrayInterstitial);
        attributeName = escapeJSObjectForInstructionScripts(attributeName);
        destination.push(attributeName);
        destination.push(arrayInterstitial);
        attributeName = escapeJSObjectForInstructionScripts(name);
        destination.push(attributeName);
      }
      __name(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
      __name2(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
      function createHoistableState() {
        return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
      }
      __name(createHoistableState, "createHoistableState");
      __name2(createHoistableState, "createHoistableState");
      function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
        (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
          'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
          href
        );
        resumableState.scriptResources[href] = EXISTS;
        resumableState.moduleScriptResources[href] = EXISTS;
        resumableState = [];
        pushLinkImpl(resumableState, props);
        renderState.bootstrapScripts.add(resumableState);
      }
      __name(preloadBootstrapScriptOrModule, "preloadBootstrapScriptOrModule");
      __name2(preloadBootstrapScriptOrModule, "preloadBootstrapScriptOrModule");
      function adoptPreloadCredentials(target, preloadState) {
        null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
        null == target.integrity && (target.integrity = preloadState[1]);
      }
      __name(adoptPreloadCredentials, "adoptPreloadCredentials");
      __name2(adoptPreloadCredentials, "adoptPreloadCredentials");
      function getPreloadAsHeader(href, as, params) {
        href = escapeHrefForLinkHeaderURLContext(href);
        as = escapeStringForLinkHeaderQuotedParamValueContext(as, "as");
        as = "<" + href + '>; rel=preload; as="' + as + '"';
        for (var paramName in params)
          hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
            href,
            paramName
          ) + '"'));
        return as;
      }
      __name(getPreloadAsHeader, "getPreloadAsHeader");
      __name2(getPreloadAsHeader, "getPreloadAsHeader");
      function escapeHrefForLinkHeaderURLContext(hrefInput) {
        checkAttributeStringCoercion(hrefInput, "href");
        return ("" + hrefInput).replace(
          regexForHrefInLinkHeaderURLContext,
          escapeHrefForLinkHeaderURLContextReplacer
        );
      }
      __name(escapeHrefForLinkHeaderURLContext, "escapeHrefForLinkHeaderURLContext");
      __name2(escapeHrefForLinkHeaderURLContext, "escapeHrefForLinkHeaderURLContext");
      function escapeHrefForLinkHeaderURLContextReplacer(match2) {
        switch (match2) {
          case "<":
            return "%3C";
          case ">":
            return "%3E";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
      __name2(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
      function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
        willCoercionThrow(value) && (console.error(
          "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
          name,
          typeName(value)
        ), testStringCoercion(value));
        return ("" + value).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        );
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContext, "escapeStringForLinkHeaderQuotedParamValueContext");
      __name2(escapeStringForLinkHeaderQuotedParamValueContext, "escapeStringForLinkHeaderQuotedParamValueContext");
      function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match2) {
        switch (match2) {
          case '"':
            return "%22";
          case "'":
            return "%27";
          case ";":
            return "%3B";
          case ",":
            return "%2C";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
      __name2(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
      function hoistStyleQueueDependency(styleQueue) {
        this.styles.add(styleQueue);
      }
      __name(hoistStyleQueueDependency, "hoistStyleQueueDependency");
      __name2(hoistStyleQueueDependency, "hoistStyleQueueDependency");
      function hoistStylesheetDependency(stylesheet) {
        this.stylesheets.add(stylesheet);
      }
      __name(hoistStylesheetDependency, "hoistStylesheetDependency");
      __name2(hoistStylesheetDependency, "hoistStylesheetDependency");
      function createRenderState(resumableState, generateStaticMarkup) {
        var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
        void 0 !== bootstrapScriptContent && bootstrapChunks.push(
          "<script>",
          escapeEntireInlineScriptContent(bootstrapScriptContent),
          "<\/script>"
        );
        idPrefix = {
          placeholderPrefix: idPrefix + "P:",
          segmentPrefix: idPrefix + "S:",
          boundaryPrefix: idPrefix + "B:",
          startInlineScript: "<script>",
          preamble: createPreambleState(),
          externalRuntimeScript: null,
          bootstrapChunks,
          importMapChunks: [],
          onHeaders: void 0,
          headers: null,
          resets: {
            font: {},
            dns: {},
            connect: { default: {}, anonymous: {}, credentials: {} },
            image: {},
            style: {}
          },
          charsetChunks: [],
          viewportChunks: [],
          hoistableChunks: [],
          preconnects: /* @__PURE__ */ new Set(),
          fontPreloads: /* @__PURE__ */ new Set(),
          highImagePreloads: /* @__PURE__ */ new Set(),
          styles: /* @__PURE__ */ new Map(),
          bootstrapScripts: /* @__PURE__ */ new Set(),
          scripts: /* @__PURE__ */ new Set(),
          bulkPreloads: /* @__PURE__ */ new Set(),
          preloads: {
            images: /* @__PURE__ */ new Map(),
            stylesheets: /* @__PURE__ */ new Map(),
            scripts: /* @__PURE__ */ new Map(),
            moduleScripts: /* @__PURE__ */ new Map()
          },
          nonce: void 0,
          hoistableState: null,
          stylesToHoist: false
        };
        if (void 0 !== bootstrapScripts)
          for (bootstrapScriptContent = 0; bootstrapScriptContent < bootstrapScripts.length; bootstrapScriptContent++) {
            var scriptConfig = bootstrapScripts[bootstrapScriptContent], src, crossOrigin = void 0, integrity = void 0, props = {
              rel: "preload",
              as: "script",
              fetchPriority: "low",
              nonce: void 0
            };
            "string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
            preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);
            bootstrapChunks.push('<script src="', escapeTextForBrowser(src));
            "string" === typeof integrity && bootstrapChunks.push(
              '" integrity="',
              escapeTextForBrowser(integrity)
            );
            "string" === typeof crossOrigin && bootstrapChunks.push(
              '" crossorigin="',
              escapeTextForBrowser(crossOrigin)
            );
            bootstrapChunks.push('" async=""><\/script>');
          }
        if (void 0 !== bootstrapModules)
          for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
            bootstrapScriptContent = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
              rel: "modulepreload",
              fetchPriority: "low",
              nonce: void 0
            }, "string" === typeof bootstrapScriptContent ? integrity.href = scriptConfig = bootstrapScriptContent : (integrity.href = scriptConfig = bootstrapScriptContent.src, integrity.integrity = crossOrigin = "string" === typeof bootstrapScriptContent.integrity ? bootstrapScriptContent.integrity : void 0, integrity.crossOrigin = src = "string" === typeof bootstrapScriptContent || null == bootstrapScriptContent.crossOrigin ? void 0 : "use-credentials" === bootstrapScriptContent.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
              resumableState,
              idPrefix,
              scriptConfig,
              integrity
            ), bootstrapChunks.push(
              '<script type="module" src="',
              escapeTextForBrowser(scriptConfig)
            ), "string" === typeof crossOrigin && bootstrapChunks.push(
              '" integrity="',
              escapeTextForBrowser(crossOrigin)
            ), "string" === typeof src && bootstrapChunks.push(
              '" crossorigin="',
              escapeTextForBrowser(src)
            ), bootstrapChunks.push('" async=""><\/script>');
        return {
          placeholderPrefix: idPrefix.placeholderPrefix,
          segmentPrefix: idPrefix.segmentPrefix,
          boundaryPrefix: idPrefix.boundaryPrefix,
          startInlineScript: idPrefix.startInlineScript,
          preamble: idPrefix.preamble,
          externalRuntimeScript: idPrefix.externalRuntimeScript,
          bootstrapChunks: idPrefix.bootstrapChunks,
          importMapChunks: idPrefix.importMapChunks,
          onHeaders: idPrefix.onHeaders,
          headers: idPrefix.headers,
          resets: idPrefix.resets,
          charsetChunks: idPrefix.charsetChunks,
          viewportChunks: idPrefix.viewportChunks,
          hoistableChunks: idPrefix.hoistableChunks,
          preconnects: idPrefix.preconnects,
          fontPreloads: idPrefix.fontPreloads,
          highImagePreloads: idPrefix.highImagePreloads,
          styles: idPrefix.styles,
          bootstrapScripts: idPrefix.bootstrapScripts,
          scripts: idPrefix.scripts,
          bulkPreloads: idPrefix.bulkPreloads,
          preloads: idPrefix.preloads,
          stylesToHoist: idPrefix.stylesToHoist,
          generateStaticMarkup
        };
      }
      __name(createRenderState, "createRenderState");
      __name2(createRenderState, "createRenderState");
      function pushTextInstance(target, text, renderState, textEmbedded) {
        if (renderState.generateStaticMarkup)
          return target.push(escapeTextForBrowser(text)), false;
        "" === text ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser(text)), target = true);
        return target;
      }
      __name(pushTextInstance, "pushTextInstance");
      __name2(pushTextInstance, "pushTextInstance");
      function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
        renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
      }
      __name(pushSegmentFinale, "pushSegmentFinale");
      __name2(pushSegmentFinale, "pushSegmentFinale");
      function getComponentNameFromType(type6) {
        if (null == type6)
          return null;
        if ("function" === typeof type6)
          return type6.$$typeof === REACT_CLIENT_REFERENCE ? null : type6.displayName || type6.name || null;
        if ("string" === typeof type6)
          return type6;
        switch (type6) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type6)
          switch ("number" === typeof type6.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type6.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type6.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type6._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type6.render;
              type6 = type6.displayName;
              type6 || (type6 = innerType.displayName || innerType.name || "", type6 = "" !== type6 ? "ForwardRef(" + type6 + ")" : "ForwardRef");
              return type6;
            case REACT_MEMO_TYPE:
              return innerType = type6.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type6.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type6._payload;
              type6 = type6._init;
              try {
                return getComponentNameFromType(type6(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      __name2(getComponentNameFromType, "getComponentNameFromType");
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          prev.context._currentValue2 = prev.parentValue;
          prev = prev.parent;
          var parentNext = next.parent;
          if (null === prev) {
            if (null !== parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
          } else {
            if (null === parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
            popToNearestCommonAncestor(prev, parentNext);
          }
          next.context._currentValue2 = next.value;
        }
      }
      __name(popToNearestCommonAncestor, "popToNearestCommonAncestor");
      __name2(popToNearestCommonAncestor, "popToNearestCommonAncestor");
      function popAllPrevious(prev) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        null !== prev && popAllPrevious(prev);
      }
      __name(popAllPrevious, "popAllPrevious");
      __name2(popAllPrevious, "popAllPrevious");
      function pushAllNext(next) {
        var parentNext = next.parent;
        null !== parentNext && pushAllNext(parentNext);
        next.context._currentValue2 = next.value;
      }
      __name(pushAllNext, "pushAllNext");
      __name2(pushAllNext, "pushAllNext");
      function popPreviousToCommonLevel(prev, next) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        if (null === prev)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
      }
      __name(popPreviousToCommonLevel, "popPreviousToCommonLevel");
      __name2(popPreviousToCommonLevel, "popPreviousToCommonLevel");
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (null === parentNext)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
        next.context._currentValue2 = next.value;
      }
      __name(popNextToCommonLevel, "popNextToCommonLevel");
      __name2(popNextToCommonLevel, "popNextToCommonLevel");
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
      }
      __name(switchContext, "switchContext");
      __name2(switchContext, "switchContext");
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      __name(warnOnInvalidCallback, "warnOnInvalidCallback");
      __name2(warnOnInvalidCallback, "warnOnInvalidCallback");
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
          "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
          callerName,
          publicInstance
        ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
      }
      __name(warnNoop, "warnNoop");
      __name2(warnNoop, "warnNoop");
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        baseContext = baseContext.overflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          return {
            id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
            overflow: length + baseContext
          };
        }
        return {
          id: 1 << length | index << baseLength | baseIdWithLeadingBit,
          overflow: baseContext
        };
      }
      __name(pushTreeContext, "pushTreeContext");
      __name2(pushTreeContext, "pushTreeContext");
      function clz32Fallback(x2) {
        x2 >>>= 0;
        return 0 === x2 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
      }
      __name(clz32Fallback, "clz32Fallback");
      __name2(clz32Fallback, "clz32Fallback");
      function noop$2() {
      }
      __name(noop$2, "noop$2");
      __name2(noop$2, "noop$2");
      function trackUsedThenable(thenableState2, thenable, index) {
        index = thenableState2[index];
        void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            ));
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      __name(trackUsedThenable, "trackUsedThenable");
      __name2(trackUsedThenable, "trackUsedThenable");
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      __name(getSuspendedThenable, "getSuspendedThenable");
      __name2(getSuspendedThenable, "getSuspendedThenable");
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      __name(is, "is");
      __name2(is, "is");
      function resolveCurrentlyRenderingComponent() {
        if (null === currentlyRenderingComponent)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        isInHookUserCodeInDev && console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
        return currentlyRenderingComponent;
      }
      __name(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
      __name2(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
      function createHook() {
        if (0 < numberOfReRenders)
          throw Error("Rendered more hooks than during the previous render");
        return { memoizedState: null, queue: null, next: null };
      }
      __name(createHook, "createHook");
      __name2(createHook, "createHook");
      function createWorkInProgressHook() {
        null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
        return workInProgressHook;
      }
      __name(createWorkInProgressHook, "createWorkInProgressHook");
      __name2(createWorkInProgressHook, "createWorkInProgressHook");
      function getThenableStateAfterSuspending() {
        var state = thenableState;
        thenableState = null;
        return state;
      }
      __name(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
      __name2(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
      function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        workInProgressHook = renderPhaseUpdates = null;
      }
      __name(resetHooksState, "resetHooksState");
      __name2(resetHooksState, "resetHooksState");
      function readContext(context) {
        isInHookUserCodeInDev && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return context._currentValue2;
      }
      __name(readContext, "readContext");
      __name2(readContext, "readContext");
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      __name(basicStateReducer, "basicStateReducer");
      __name2(basicStateReducer, "basicStateReducer");
      function useReducer3(reducer, initialArg, init2) {
        reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          init2 = workInProgressHook.queue;
          initialArg = init2.dispatch;
          if (null !== renderPhaseUpdates) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(init2);
            if (void 0 !== firstRenderPhaseUpdate) {
              renderPhaseUpdates.delete(init2);
              init2 = workInProgressHook.memoizedState;
              do {
                var action = firstRenderPhaseUpdate.action;
                isInHookUserCodeInDev = true;
                init2 = reducer(init2, action);
                isInHookUserCodeInDev = false;
                firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
              } while (null !== firstRenderPhaseUpdate);
              workInProgressHook.memoizedState = init2;
              return [init2, initialArg];
            }
          }
          return [workInProgressHook.memoizedState, initialArg];
        }
        isInHookUserCodeInDev = true;
        reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init2 ? init2(initialArg) : initialArg;
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = reducer;
        reducer = workInProgressHook.queue = { last: null, dispatch: null };
        reducer = reducer.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingComponent,
          reducer
        );
        return [workInProgressHook.memoizedState, reducer];
      }
      __name(useReducer3, "useReducer3");
      __name2(useReducer3, "useReducer");
      function useMemo14(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        if (null !== workInProgressHook) {
          var prevState = workInProgressHook.memoizedState;
          if (null !== prevState && null !== deps) {
            a: {
              var JSCompiler_inline_result = prevState[1];
              if (null === JSCompiler_inline_result)
                console.error(
                  "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                  currentHookNameInDev
                ), JSCompiler_inline_result = false;
              else {
                deps.length !== JSCompiler_inline_result.length && console.error(
                  "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                  currentHookNameInDev,
                  "[" + deps.join(", ") + "]",
                  "[" + JSCompiler_inline_result.join(", ") + "]"
                );
                for (var i2 = 0; i2 < JSCompiler_inline_result.length && i2 < deps.length; i2++)
                  if (!objectIs(deps[i2], JSCompiler_inline_result[i2])) {
                    JSCompiler_inline_result = false;
                    break a;
                  }
                JSCompiler_inline_result = true;
              }
            }
            if (JSCompiler_inline_result)
              return prevState[0];
          }
        }
        isInHookUserCodeInDev = true;
        nextCreate = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [nextCreate, deps];
        return nextCreate;
      }
      __name(useMemo14, "useMemo14");
      __name2(useMemo14, "useMemo");
      function dispatchAction(componentIdentity, queue, action) {
        if (25 <= numberOfReRenders)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (componentIdentity === currentlyRenderingComponent)
          if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
            renderPhaseUpdates.set(queue, componentIdentity);
          else {
            for (queue = action; null !== queue.next; )
              queue = queue.next;
            queue.next = componentIdentity;
          }
      }
      __name(dispatchAction, "dispatchAction");
      __name2(dispatchAction, "dispatchAction");
      function unsupportedStartTransition() {
        throw Error("startTransition cannot be called during server rendering.");
      }
      __name(unsupportedStartTransition, "unsupportedStartTransition");
      __name2(unsupportedStartTransition, "unsupportedStartTransition");
      function unsupportedSetOptimisticState() {
        throw Error("Cannot update optimistic state while rendering.");
      }
      __name(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
      __name2(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
      function useActionState(action, initialState, permalink) {
        resolveCurrentlyRenderingComponent();
        var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
        if ("function" === typeof action.$$FORM_ACTION) {
          var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
          request = request.formState;
          var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
          if (null !== request && "function" === typeof isSignatureEqual) {
            var postbackKey = request[1];
            isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
          }
          var boundAction = action.bind(null, initialState);
          action = /* @__PURE__ */ __name2(function(payload) {
            boundAction(payload);
          }, "action");
          "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
            prefix2 = boundAction.$$FORM_ACTION(prefix2);
            void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix2.action = permalink);
            var formData = prefix2.data;
            formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            )), formData.append("$ACTION_KEY", nextPostbackStateKey));
            return prefix2;
          });
          return [initialState, action, false];
        }
        var _boundAction = action.bind(null, initialState);
        return [
          initialState,
          function(payload) {
            _boundAction(payload);
          },
          false
        ];
      }
      __name(useActionState, "useActionState");
      __name2(useActionState, "useActionState");
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      __name(unwrapThenable, "unwrapThenable");
      __name2(unwrapThenable, "unwrapThenable");
      function unsupportedRefresh() {
        throw Error("Cache cannot be refreshed during server rendering.");
      }
      __name(unsupportedRefresh, "unsupportedRefresh");
      __name2(unsupportedRefresh, "unsupportedRefresh");
      function noop$1() {
      }
      __name(noop$1, "noop$1");
      __name2(noop$1, "noop$1");
      function disabledLog() {
      }
      __name(disabledLog, "disabledLog");
      __name2(disabledLog, "disabledLog");
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      __name(disableLogs, "disableLogs");
      __name2(disableLogs, "disableLogs");
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      __name(reenableLogs, "reenableLogs");
      __name2(reenableLogs, "reenableLogs");
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x2) {
            var match2 = x2.stack.trim().match(/\n( *(at )?)/);
            prefix = match2 && match2[1] || "";
            suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
      __name2(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        var frame2 = componentFrameCache.get(fn);
        if (void 0 !== frame2)
          return frame2;
        reentry = true;
        frame2 = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher2 = null;
        previousDispatcher2 = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = /* @__PURE__ */ __name2(function() {
                    throw Error();
                  }, "Fake");
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x2) {
                      var control = x2;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame2;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      __name(describeNativeComponentFrame, "describeNativeComponentFrame");
      __name2(describeNativeComponentFrame, "describeNativeComponentFrame");
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else
          return "";
        return error;
      }
      __name(formatOwnerStack, "formatOwnerStack");
      __name2(formatOwnerStack, "formatOwnerStack");
      function describeComponentStackByType(type6) {
        if ("string" === typeof type6)
          return describeBuiltInComponentFrame(type6);
        if ("function" === typeof type6)
          return type6.prototype && type6.prototype.isReactComponent ? describeNativeComponentFrame(type6, true) : describeNativeComponentFrame(type6, false);
        if ("object" === typeof type6 && null !== type6) {
          switch (type6.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeNativeComponentFrame(type6.render, false);
            case REACT_MEMO_TYPE:
              return describeNativeComponentFrame(type6.type, false);
            case REACT_LAZY_TYPE:
              var lazyComponent = type6, payload = lazyComponent._payload;
              lazyComponent = lazyComponent._init;
              try {
                type6 = lazyComponent(payload);
              } catch (x2) {
                return describeBuiltInComponentFrame("Lazy");
              }
              return describeComponentStackByType(type6);
          }
          if ("string" === typeof type6.name)
            return payload = type6.env, describeBuiltInComponentFrame(
              type6.name + (payload ? " [" + payload + "]" : "")
            );
        }
        switch (type6) {
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
        }
        return "";
      }
      __name(describeComponentStackByType, "describeComponentStackByType");
      __name2(describeComponentStackByType, "describeComponentStackByType");
      function defaultErrorHandler(error) {
        if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
          var JSCompiler_inline_result = error.environmentName;
          error = [error].slice(0);
          "string" === typeof error[0] ? error.splice(
            0,
            1,
            "[%s] " + error[0],
            " " + JSCompiler_inline_result + " "
          ) : error.splice(0, 0, "[%s] ", " " + JSCompiler_inline_result + " ");
          error.unshift(console);
          JSCompiler_inline_result = bind.apply(console.error, error);
          JSCompiler_inline_result();
        } else
          console.error(error);
        return null;
      }
      __name(defaultErrorHandler, "defaultErrorHandler");
      __name2(defaultErrorHandler, "defaultErrorHandler");
      function noop2() {
      }
      __name(noop2, "noop2");
      __name2(noop2, "noop");
      function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var abortSet = /* @__PURE__ */ new Set();
        this.destination = null;
        this.flushScheduled = false;
        this.resumableState = resumableState;
        this.renderState = renderState;
        this.rootFormatContext = rootFormatContext;
        this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
        this.status = 10;
        this.fatalError = null;
        this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
        this.completedPreambleSegments = this.completedRootSegment = null;
        this.abortableTasks = abortSet;
        this.pingedTasks = [];
        this.clientRenderedBoundaries = [];
        this.completedBoundaries = [];
        this.partialBoundaries = [];
        this.trackedPostpones = null;
        this.onError = void 0 === onError2 ? defaultErrorHandler : onError2;
        this.onPostpone = void 0 === onPostpone ? noop2 : onPostpone;
        this.onAllReady = void 0 === onAllReady ? noop2 : onAllReady;
        this.onShellReady = void 0 === onShellReady ? noop2 : onShellReady;
        this.onShellError = void 0 === onShellError ? noop2 : onShellError;
        this.onFatalError = void 0 === onFatalError ? noop2 : onFatalError;
        this.formState = void 0 === formState ? null : formState;
        this.didWarnForKey = null;
      }
      __name(RequestInstance, "RequestInstance");
      __name2(RequestInstance, "RequestInstance");
      function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var now2 = getCurrentTime();
        1e3 < now2 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now2);
        resumableState = new RequestInstance(
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError2,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          formState
        );
        renderState = createPendingSegment(
          resumableState,
          0,
          null,
          rootFormatContext,
          false,
          false
        );
        renderState.parentFlushed = true;
        children = createRenderTask(
          resumableState,
          null,
          children,
          -1,
          null,
          renderState,
          null,
          null,
          resumableState.abortableTasks,
          null,
          rootFormatContext,
          null,
          emptyTreeContext,
          null,
          false,
          emptyContextObject,
          null
        );
        pushComponentStack(children);
        resumableState.pingedTasks.push(children);
        return resumableState;
      }
      __name(createRequest, "createRequest");
      __name2(createRequest, "createRequest");
      function pingTask(request, task) {
        request.pingedTasks.push(task);
        1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork(request));
      }
      __name(pingTask, "pingTask");
      __name2(pingTask, "pingTask");
      function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
        return {
          status: PENDING,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
          contentState: createHoistableState(),
          fallbackState: createHoistableState(),
          contentPreamble,
          fallbackPreamble,
          trackedContentKeyPath: null,
          trackedFallbackNode: null,
          errorMessage: null,
          errorStack: null,
          errorComponentStack: null
        };
      }
      __name(createSuspenseBoundary, "createSuspenseBoundary");
      __name2(createSuspenseBoundary, "createSuspenseBoundary");
      function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          replay: null,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          blockedPreamble,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createRenderTask, "createRenderTask");
      __name2(createRenderTask, "createRenderTask");
      function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        replay.pendingTasks++;
        var task = {
          replay,
          node,
          childIndex,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment: null,
          blockedPreamble: null,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createReplayTask, "createReplayTask");
      __name2(createReplayTask, "createReplayTask");
      function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          parentFlushed: false,
          id: -1,
          index,
          chunks: [],
          children: [],
          preambleChildren: [],
          parentFormatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      __name(createPendingSegment, "createPendingSegment");
      __name2(createPendingSegment, "createPendingSegment");
      function getCurrentStackInDEV() {
        if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
          return "";
        var componentStack = currentTaskInDEV.componentStack;
        try {
          var info = "";
          if ("string" === typeof componentStack.type)
            info += describeBuiltInComponentFrame(componentStack.type);
          else if ("function" === typeof componentStack.type) {
            if (!componentStack.owner) {
              var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
              var JSCompiler_inline_result = name ? describeBuiltInComponentFrame(name) : "";
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          } else
            componentStack.owner || (info += describeComponentStackByType(componentStack.type));
          for (; componentStack; )
            JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
              componentStack.debugStack
            ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
              JSCompiler_inline_result.stack
            ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
          var JSCompiler_inline_result$jscomp$0 = info;
        } catch (x2) {
          JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x2.message + "\n" + x2.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
      }
      __name(getCurrentStackInDEV, "getCurrentStackInDEV");
      __name2(getCurrentStackInDEV, "getCurrentStackInDEV");
      function pushServerComponentStack(task, debugInfo) {
        if (null != debugInfo)
          for (var i2 = 0; i2 < debugInfo.length; i2++) {
            var componentInfo = debugInfo[i2];
            "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
              parent: task.componentStack,
              type: componentInfo,
              owner: componentInfo.owner,
              stack: componentInfo.debugStack
            }, task.debugTask = componentInfo.debugTask);
          }
      }
      __name(pushServerComponentStack, "pushServerComponentStack");
      __name2(pushServerComponentStack, "pushServerComponentStack");
      function pushComponentStack(task) {
        var node = task.node;
        if ("object" === typeof node && null !== node)
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type6 = node.type, owner = node._owner, stack = node._debugStack;
              pushServerComponentStack(task, node._debugInfo);
              task.debugTask = node._debugTask;
              task.componentStack = {
                parent: task.componentStack,
                type: type6,
                owner,
                stack
              };
              break;
            case REACT_LAZY_TYPE:
              pushServerComponentStack(task, node._debugInfo);
              break;
            default:
              "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
          }
      }
      __name(pushComponentStack, "pushComponentStack");
      __name2(pushComponentStack, "pushComponentStack");
      function getThrownInfo(node$jscomp$0) {
        var errorInfo = {};
        node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
          configurable: true,
          enumerable: true,
          get: function() {
            try {
              var info = "", node = node$jscomp$0;
              do
                info += describeComponentStackByType(node.type), node = node.parent;
              while (node);
              var stack = info;
            } catch (x2) {
              stack = "\nError generating stack: " + x2.message + "\n" + x2.stack;
            }
            Object.defineProperty(errorInfo, "componentStack", {
              value: stack
            });
            return stack;
          }
        });
        return errorInfo;
      }
      __name(getThrownInfo, "getThrownInfo");
      __name2(getThrownInfo, "getThrownInfo");
      function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
        boundary.errorDigest = digest;
        error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
        wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
        boundary.errorMessage = wasAborted + digest;
        boundary.errorStack = null !== error ? wasAborted + error : null;
        boundary.errorComponentStack = thrownInfo.componentStack;
      }
      __name(encodeErrorForBoundary, "encodeErrorForBoundary");
      __name2(encodeErrorForBoundary, "encodeErrorForBoundary");
      function logRecoverableError(request, error, errorInfo, debugTask) {
        request = request.onError;
        error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
        if (null != error && "string" !== typeof error)
          console.error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
            typeof error
          );
        else
          return error;
      }
      __name(logRecoverableError, "logRecoverableError");
      __name2(logRecoverableError, "logRecoverableError");
      function fatalError(request, error, errorInfo, debugTask) {
        errorInfo = request.onShellError;
        var onFatalError = request.onFatalError;
        debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
        null !== request.destination ? (request.status = CLOSED, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
      }
      __name(fatalError, "fatalError");
      __name2(fatalError, "fatalError");
      function renderWithHooks(request, task, keyPath, Component3, props, secondArg) {
        var prevThenableState = task.thenableState;
        task.thenableState = null;
        currentlyRenderingComponent = {};
        currentlyRenderingTask = task;
        currentlyRenderingRequest = request;
        currentlyRenderingKeyPath = keyPath;
        isInHookUserCodeInDev = false;
        actionStateCounter = localIdCounter = 0;
        actionStateMatchingIndex = -1;
        thenableIndexCounter = 0;
        thenableState = prevThenableState;
        for (request = callComponentInDEV(Component3, props, secondArg); didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component3(props, secondArg);
        resetHooksState();
        return request;
      }
      __name(renderWithHooks, "renderWithHooks");
      __name2(renderWithHooks, "renderWithHooks");
      function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
        var didEmitActionStateMarkers = false;
        if (0 !== actionStateCount && null !== request.formState) {
          var segment = task.blockedSegment;
          if (null !== segment) {
            didEmitActionStateMarkers = true;
            segment = segment.chunks;
            for (var i2 = 0; i2 < actionStateCount; i2++)
              i2 === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
          }
        }
        actionStateCount = task.keyPath;
        task.keyPath = keyPath;
        hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
        task.keyPath = actionStateCount;
      }
      __name(finishFunctionComponent, "finishFunctionComponent");
      __name2(finishFunctionComponent, "finishFunctionComponent");
      function renderElement(request, task, keyPath, type6, props, ref) {
        if ("function" === typeof type6)
          if (type6.prototype && type6.prototype.isReactComponent) {
            var newProps = props;
            if ("ref" in props) {
              newProps = {};
              for (var propName in props)
                "ref" !== propName && (newProps[propName] = props[propName]);
            }
            var defaultProps = type6.defaultProps;
            if (defaultProps) {
              newProps === props && (newProps = assign({}, newProps, props));
              for (var _propName in defaultProps)
                void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
            }
            var resolvedProps = newProps;
            var context = emptyContextObject, contextType = type6.contextType;
            if ("contextType" in type6 && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type6)) {
              didWarnAboutInvalidateContextType.add(type6);
              var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              console.error(
                "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                getComponentNameFromType(type6) || "Component",
                addendum
              );
            }
            "object" === typeof contextType && null !== contextType && (context = contextType._currentValue2);
            var instance = new type6(resolvedProps, context);
            if ("function" === typeof type6.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
              var componentName = getComponentNameFromType(type6) || "Component";
              didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                componentName,
                null === instance.state ? "null" : "undefined",
                componentName
              ));
            }
            if ("function" === typeof type6.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
              var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
              "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
              "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
              "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                var _componentName = getComponentNameFromType(type6) || "Component", newApiName = "function" === typeof type6.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                  _componentName
                ), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _componentName,
                  newApiName,
                  null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                  null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            var name = getComponentNameFromType(type6) || "Component";
            instance.render || (type6.prototype && "function" === typeof type6.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              name
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              name
            ));
            !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              name
            );
            instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              name
            );
            instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              name
            );
            type6.childContextTypes && !didWarnAboutChildContextTypes.has(type6) && (didWarnAboutChildContextTypes.add(type6), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              name
            ));
            type6.contextTypes && !didWarnAboutContextTypes$1.has(type6) && (didWarnAboutContextTypes$1.add(type6), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              name
            ));
            "function" === typeof instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              name
            );
            type6.prototype && type6.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(type6) || "A pure component"
            );
            "function" === typeof instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              name
            );
            "function" === typeof instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              name
            );
            "function" === typeof instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              name
            );
            "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              name
            );
            var hasMutatedProps = instance.props !== resolvedProps;
            void 0 !== instance.props && hasMutatedProps && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name
            );
            instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              name,
              name
            );
            "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type6) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type6), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(type6)
            ));
            "function" === typeof instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof type6.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              name
            );
            var state = instance.state;
            state && ("object" !== typeof state || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name);
            "function" === typeof instance.getChildContext && "object" !== typeof type6.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              name
            );
            var initialState = void 0 !== instance.state ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = resolvedProps;
            instance.state = initialState;
            var internalInstance = { queue: [], replace: false };
            instance._reactInternals = internalInstance;
            var contextType$jscomp$0 = type6.contextType;
            instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue2 : emptyContextObject;
            if (instance.state === resolvedProps) {
              var componentName$jscomp$0 = getComponentNameFromType(type6) || "Component";
              didWarnAboutDirectlyAssigningPropsToState.has(
                componentName$jscomp$0
              ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                componentName$jscomp$0
              ), console.error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName$jscomp$0
              ));
            }
            var getDerivedStateFromProps = type6.getDerivedStateFromProps;
            if ("function" === typeof getDerivedStateFromProps) {
              var partialState = getDerivedStateFromProps(
                resolvedProps,
                initialState
              );
              if (void 0 === partialState) {
                var componentName$jscomp$1 = getComponentNameFromType(type6) || "Component";
                didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                  "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                  componentName$jscomp$1
                ));
              }
              var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign({}, initialState, partialState);
              instance.state = JSCompiler_inline_result;
            }
            if ("function" !== typeof type6.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
              var oldState = instance.state;
              if ("function" === typeof instance.componentWillMount) {
                if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                  var componentName$jscomp$2 = getComponentNameFromType(type6) || "Unknown";
                  didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName$jscomp$2
                  ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                }
                instance.componentWillMount();
              }
              "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
              oldState !== instance.state && (console.error(
                "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                getComponentNameFromType(type6) || "Component"
              ), classComponentUpdater.enqueueReplaceState(
                instance,
                instance.state,
                null
              ));
              if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                internalInstance.queue = null;
                internalInstance.replace = false;
                if (oldReplace && 1 === oldQueue.length)
                  instance.state = oldQueue[0];
                else {
                  for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2], partialState$jscomp$0 = "function" === typeof partial ? partial.call(
                      instance,
                      nextState,
                      resolvedProps,
                      void 0
                    ) : partial;
                    null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign(
                      {},
                      nextState,
                      partialState$jscomp$0
                    )) : assign(nextState, partialState$jscomp$0));
                  }
                  instance.state = nextState;
                }
              } else
                internalInstance.queue = null;
            }
            var nextChildren = callRenderInDEV(instance);
            if (12 === request.status)
              throw null;
            instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
              "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
              getComponentNameFromType(type6) || "a component"
            ), didWarnAboutReassigningProps = true);
            var prevKeyPath = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, nextChildren, -1);
            task.keyPath = prevKeyPath;
          } else {
            if (type6.prototype && "function" === typeof type6.prototype.render) {
              var componentName$jscomp$3 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName$jscomp$3,
                componentName$jscomp$3
              ), didWarnAboutBadClass[componentName$jscomp$3] = true);
            }
            var value = renderWithHooks(
              request,
              task,
              keyPath,
              type6,
              props,
              void 0
            );
            if (12 === request.status)
              throw null;
            var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
            if (type6.contextTypes) {
              var _componentName$jscomp$0 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                _componentName$jscomp$0
              ));
            }
            type6 && type6.childContextTypes && console.error(
              "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
              type6.displayName || type6.name || "Component"
            );
            if ("function" === typeof type6.getDerivedStateFromProps) {
              var _componentName2 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] || (console.error(
                "%s: Function components do not support getDerivedStateFromProps.",
                _componentName2
              ), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true);
            }
            if ("object" === typeof type6.contextType && null !== type6.contextType) {
              var _componentName3 = getComponentNameFromType(type6) || "Unknown";
              didWarnAboutContextTypeOnFunctionComponent[_componentName3] || (console.error(
                "%s: Function components do not support contextType.",
                _componentName3
              ), didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true);
            }
            finishFunctionComponent(
              request,
              task,
              keyPath,
              value,
              hasId,
              actionStateCount,
              actionStateMatchingIndex$jscomp$0
            );
          }
        else if ("string" === typeof type6) {
          var segment = task.blockedSegment;
          if (null === segment) {
            var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
            task.formatContext = getChildFormatContext(prevContext, type6, props);
            task.keyPath = keyPath;
            renderNode(request, task, children, -1);
            task.formatContext = prevContext;
            task.keyPath = prevKeyPath$jscomp$0;
          } else {
            var _children = pushStartInstance(
              segment.chunks,
              type6,
              props,
              request.resumableState,
              request.renderState,
              task.blockedPreamble,
              task.hoistableState,
              task.formatContext,
              segment.lastPushedText,
              task.isFallback
            );
            segment.lastPushedText = false;
            var _prevContext = task.formatContext, _prevKeyPath2 = task.keyPath;
            task.keyPath = keyPath;
            if ((task.formatContext = getChildFormatContext(
              _prevContext,
              type6,
              props
            )).insertionMode === HTML_HEAD_MODE) {
              var preambleSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              segment.preambleChildren.push(preambleSegment);
              var preambleTask = createRenderTask(
                request,
                null,
                _children,
                -1,
                task.blockedBoundary,
                preambleSegment,
                task.blockedPreamble,
                task.hoistableState,
                request.abortableTasks,
                task.keyPath,
                task.formatContext,
                task.context,
                task.treeContext,
                task.componentStack,
                task.isFallback,
                emptyContextObject,
                task.debugTask
              );
              pushComponentStack(preambleTask);
              request.pingedTasks.push(preambleTask);
            } else
              renderNode(request, task, _children, -1);
            task.formatContext = _prevContext;
            task.keyPath = _prevKeyPath2;
            a: {
              var target = segment.chunks, resumableState = request.resumableState;
              switch (type6) {
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                  break a;
                case "body":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) {
                    resumableState.hasBody = true;
                    break a;
                  }
                  break;
                case "html":
                  if (_prevContext.insertionMode === ROOT_HTML_MODE) {
                    resumableState.hasHtml = true;
                    break a;
                  }
                  break;
                case "head":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE)
                    break a;
              }
              target.push(endChunkForTag(type6));
            }
            segment.lastPushedText = false;
          }
        } else {
          switch (type6) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
              var prevKeyPath$jscomp$1 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = prevKeyPath$jscomp$1;
              return;
            case REACT_ACTIVITY_TYPE:
              if ("hidden" !== props.mode) {
                var prevKeyPath$jscomp$2 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$2;
              }
              return;
            case REACT_SUSPENSE_LIST_TYPE:
              var _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = _prevKeyPath3;
              return;
            case REACT_VIEW_TRANSITION_TYPE:
            case REACT_SCOPE_TYPE:
              throw Error(
                "ReactDOMServer does not yet support scope components."
              );
            case REACT_SUSPENSE_TYPE:
              a:
                if (null !== task.replay) {
                  var _prevKeyPath = task.keyPath;
                  task.keyPath = keyPath;
                  var _content = props.children;
                  try {
                    renderNode(request, task, _content, -1);
                  } finally {
                    task.keyPath = _prevKeyPath;
                  }
                } else {
                  var prevKeyPath$jscomp$3 = task.keyPath, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                  var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                    request,
                    fallbackAbortSet,
                    createPreambleState(),
                    createPreambleState()
                  ) : createSuspenseBoundary(
                    request,
                    fallbackAbortSet,
                    null,
                    null
                  );
                  null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                  var boundarySegment = createPendingSegment(
                    request,
                    parentSegment.chunks.length,
                    newBoundary,
                    task.formatContext,
                    false,
                    false
                  );
                  parentSegment.children.push(boundarySegment);
                  parentSegment.lastPushedText = false;
                  var contentRootSegment = createPendingSegment(
                    request,
                    0,
                    null,
                    task.formatContext,
                    false,
                    false
                  );
                  contentRootSegment.parentFlushed = true;
                  if (null !== request.trackedPostpones) {
                    var fallbackKeyPath = [
                      keyPath[0],
                      "Suspense Fallback",
                      keyPath[2]
                    ], fallbackReplayNode = [
                      fallbackKeyPath[1],
                      fallbackKeyPath[2],
                      [],
                      null
                    ];
                    request.trackedPostpones.workingMap.set(
                      fallbackKeyPath,
                      fallbackReplayNode
                    );
                    newBoundary.trackedFallbackNode = fallbackReplayNode;
                    task.blockedSegment = boundarySegment;
                    task.blockedPreamble = newBoundary.fallbackPreamble;
                    task.keyPath = fallbackKeyPath;
                    boundarySegment.status = 6;
                    try {
                      renderNode(request, task, fallback, -1), pushSegmentFinale(
                        boundarySegment.chunks,
                        request.renderState,
                        boundarySegment.lastPushedText,
                        boundarySegment.textEmbedded
                      ), boundarySegment.status = COMPLETED;
                    } catch (thrownValue) {
                      throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                    } finally {
                      task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
                    }
                    var suspendedPrimaryTask = createRenderTask(
                      request,
                      null,
                      content,
                      -1,
                      newBoundary,
                      contentRootSegment,
                      newBoundary.contentPreamble,
                      newBoundary.contentState,
                      task.abortSet,
                      keyPath,
                      task.formatContext,
                      task.context,
                      task.treeContext,
                      task.componentStack,
                      task.isFallback,
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedPrimaryTask);
                    request.pingedTasks.push(suspendedPrimaryTask);
                  } else {
                    task.blockedBoundary = newBoundary;
                    task.blockedPreamble = newBoundary.contentPreamble;
                    task.hoistableState = newBoundary.contentState;
                    task.blockedSegment = contentRootSegment;
                    task.keyPath = keyPath;
                    contentRootSegment.status = 6;
                    try {
                      if (renderNode(request, task, content, -1), pushSegmentFinale(
                        contentRootSegment.chunks,
                        request.renderState,
                        contentRootSegment.lastPushedText,
                        contentRootSegment.textEmbedded
                      ), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                        newBoundary.status = COMPLETED;
                        0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                        break a;
                      }
                    } catch (thrownValue$2) {
                      newBoundary.status = CLIENT_RENDERED;
                      if (12 === request.status) {
                        contentRootSegment.status = 3;
                        var error = request.fatalError;
                      } else
                        contentRootSegment.status = 4, error = thrownValue$2;
                      var thrownInfo = getThrownInfo(task.componentStack);
                      var errorDigest = logRecoverableError(
                        request,
                        error,
                        thrownInfo,
                        task.debugTask
                      );
                      encodeErrorForBoundary(
                        newBoundary,
                        errorDigest,
                        error,
                        thrownInfo,
                        false
                      );
                      untrackBoundary(request, newBoundary);
                    } finally {
                      task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
                    }
                    var suspendedFallbackTask = createRenderTask(
                      request,
                      null,
                      fallback,
                      -1,
                      parentBoundary,
                      boundarySegment,
                      newBoundary.fallbackPreamble,
                      newBoundary.fallbackState,
                      fallbackAbortSet,
                      [keyPath[0], "Suspense Fallback", keyPath[2]],
                      task.formatContext,
                      task.context,
                      task.treeContext,
                      task.componentStack,
                      true,
                      emptyContextObject,
                      task.debugTask
                    );
                    pushComponentStack(suspendedFallbackTask);
                    request.pingedTasks.push(suspendedFallbackTask);
                  }
                }
              return;
          }
          if ("object" === typeof type6 && null !== type6)
            switch (type6.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                if ("ref" in props) {
                  var propsWithoutRef = {};
                  for (var key in props)
                    "ref" !== key && (propsWithoutRef[key] = props[key]);
                } else
                  propsWithoutRef = props;
                var children$jscomp$0 = renderWithHooks(
                  request,
                  task,
                  keyPath,
                  type6.render,
                  propsWithoutRef,
                  ref
                );
                finishFunctionComponent(
                  request,
                  task,
                  keyPath,
                  children$jscomp$0,
                  0 !== localIdCounter,
                  actionStateCounter,
                  actionStateMatchingIndex
                );
                return;
              case REACT_MEMO_TYPE:
                renderElement(request, task, keyPath, type6.type, props, ref);
                return;
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE:
                var value$jscomp$0 = props.value, children$jscomp$1 = props.children;
                var prevSnapshot = task.context;
                var prevKeyPath$jscomp$4 = task.keyPath;
                var prevValue = type6._currentValue2;
                type6._currentValue2 = value$jscomp$0;
                void 0 !== type6._currentRenderer2 && null !== type6._currentRenderer2 && type6._currentRenderer2 !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type6._currentRenderer2 = rendererSigil;
                var prevNode = currentActiveSnapshot, newNode = {
                  parent: prevNode,
                  depth: null === prevNode ? 0 : prevNode.depth + 1,
                  context: type6,
                  parentValue: prevValue,
                  value: value$jscomp$0
                };
                currentActiveSnapshot = newNode;
                task.context = newNode;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, children$jscomp$1, -1);
                var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                if (null === prevSnapshot$jscomp$0)
                  throw Error(
                    "Tried to pop a Context at the root of the app. This is a bug in React."
                  );
                prevSnapshot$jscomp$0.context !== type6 && console.error(
                  "The parent context is not the expected context. This is probably a bug in React."
                );
                prevSnapshot$jscomp$0.context._currentValue2 = prevSnapshot$jscomp$0.parentValue;
                void 0 !== type6._currentRenderer2 && null !== type6._currentRenderer2 && type6._currentRenderer2 !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type6._currentRenderer2 = rendererSigil;
                var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                task.context = JSCompiler_inline_result$jscomp$0;
                task.keyPath = prevKeyPath$jscomp$4;
                prevSnapshot !== task.context && console.error(
                  "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                );
                return;
              case REACT_CONSUMER_TYPE:
                var context$jscomp$0 = type6._context, render = props.children;
                "function" !== typeof render && console.error(
                  "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                );
                var newChildren = render(context$jscomp$0._currentValue2), prevKeyPath$jscomp$5 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, newChildren, -1);
                task.keyPath = prevKeyPath$jscomp$5;
                return;
              case REACT_LAZY_TYPE:
                var Component3 = callLazyInitInDEV(type6);
                if (12 === request.status)
                  throw null;
                renderElement(request, task, keyPath, Component3, props, ref);
                return;
            }
          var info = "";
          if (void 0 === type6 || "object" === typeof type6 && null !== type6 && 0 === Object.keys(type6).length)
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          throw Error(
            "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type6 ? type6 : typeof type6) + "." + info)
          );
        }
      }
      __name(renderElement, "renderElement");
      __name2(renderElement, "renderElement");
      function resumeNode(request, task, segmentId, node, childIndex) {
        var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
          request,
          0,
          null,
          task.formatContext,
          false,
          false
        );
        resumedSegment.id = segmentId;
        resumedSegment.parentFlushed = true;
        try {
          task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
        } finally {
          task.replay = prevReplay, task.blockedSegment = null;
        }
      }
      __name(resumeNode, "resumeNode");
      __name2(resumeNode, "resumeNode");
      function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type6, props, ref, replay) {
        childIndex = replay.nodes;
        for (var i2 = 0; i2 < childIndex.length; i2++) {
          var node = childIndex[i2];
          if (keyOrIndex === node[1]) {
            if (4 === node.length) {
              if (null !== name && name !== node[0])
                throw Error(
                  "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering."
                );
              var childNodes = node[2];
              node = node[3];
              name = task.node;
              task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
              try {
                renderElement(request, task, keyPath, type6, props, ref);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x2) {
                if ("object" === typeof x2 && null !== x2 && (x2 === SuspenseException || "function" === typeof x2.then))
                  throw task.node === name && (task.replay = replay), x2;
                task.replay.pendingTasks--;
                type6 = getThrownInfo(task.componentStack);
                props = request;
                request = task.blockedBoundary;
                keyPath = x2;
                ref = node;
                node = logRecoverableError(props, keyPath, type6, task.debugTask);
                abortRemainingReplayNodes(
                  props,
                  request,
                  childNodes,
                  ref,
                  keyPath,
                  node,
                  type6,
                  false
                );
              }
              task.replay = replay;
            } else {
              if (type6 !== REACT_SUSPENSE_TYPE)
                throw Error(
                  "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type6) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                );
              a: {
                replay = void 0;
                type6 = node[5];
                ref = node[2];
                name = node[3];
                keyOrIndex = null === node[4] ? [] : node[4][2];
                node = null === node[4] ? null : node[4][3];
                var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                props.parentFlushed = true;
                props.rootSegmentID = type6;
                task.blockedBoundary = props;
                task.hoistableState = props.contentState;
                task.keyPath = keyPath;
                task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
                try {
                  renderNode(request, task, content, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  if (0 === props.pendingTasks && props.status === PENDING) {
                    props.status = COMPLETED;
                    request.completedBoundaries.push(props);
                    break a;
                  }
                } catch (error) {
                  props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                    request,
                    error,
                    childNodes,
                    task.debugTask
                  ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                } finally {
                  task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                }
                props = createReplayTask(
                  request,
                  null,
                  { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                  fallback,
                  -1,
                  parentBoundary,
                  props.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true,
                  emptyContextObject,
                  task.debugTask
                );
                pushComponentStack(props);
                request.pingedTasks.push(props);
              }
            }
            childIndex.splice(i2, 1);
            break;
          }
        }
      }
      __name(replayElement, "replayElement");
      __name2(replayElement, "replayElement");
      function renderNodeDestructive(request, task, node, childIndex) {
        null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
      }
      __name(renderNodeDestructive, "renderNodeDestructive");
      __name2(renderNodeDestructive, "renderNodeDestructive");
      function retryNode(request, task) {
        var node = task.node, childIndex = task.childIndex;
        if (null !== node) {
          if ("object" === typeof node) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type6 = node.type, key = node.key;
                node = node.props;
                var refProp = node.ref;
                refProp = void 0 !== refProp ? refProp : null;
                var debugTask = task.debugTask, name = getComponentNameFromType(type6);
                key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                var keyPath = [task.keyPath, name, key];
                null !== task.replay ? debugTask ? debugTask.run(
                  replayElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    name,
                    key,
                    childIndex,
                    type6,
                    node,
                    refProp,
                    task.replay
                  )
                ) : replayElement(
                  request,
                  task,
                  keyPath,
                  name,
                  key,
                  childIndex,
                  type6,
                  node,
                  refProp,
                  task.replay
                ) : debugTask ? debugTask.run(
                  renderElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    type6,
                    node,
                    refProp
                  )
                ) : renderElement(request, task, keyPath, type6, node, refProp);
                return;
              case REACT_PORTAL_TYPE:
                throw Error(
                  "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                );
              case REACT_LAZY_TYPE:
                node = callLazyInitInDEV(node);
                if (12 === request.status)
                  throw null;
                renderNodeDestructive(request, task, node, childIndex);
                return;
            }
            if (isArrayImpl(node)) {
              renderChildrenArray(request, task, node, childIndex);
              return;
            }
            null === node || "object" !== typeof node ? key = null : (type6 = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], key = "function" === typeof type6 ? type6 : null);
            if (key && (type6 = key.call(node))) {
              if (type6 === node) {
                if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(type6))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                node.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              node = type6.next();
              if (!node.done) {
                key = [];
                do
                  key.push(node.value), node = type6.next();
                while (!node.done);
                renderChildrenArray(request, task, key, childIndex);
              }
              return;
            }
            if ("function" === typeof node.then)
              return task.thenableState = null, renderNodeDestructive(
                request,
                task,
                unwrapThenable(node),
                childIndex
              );
            if (node.$$typeof === REACT_CONTEXT_TYPE)
              return renderNodeDestructive(
                request,
                task,
                node._currentValue2,
                childIndex
              );
            request = Object.prototype.toString.call(node);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            node,
            request.renderState,
            task.lastPushedText
          ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            "" + node,
            request.renderState,
            task.lastPushedText
          ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
            request,
            request
          )), "symbol" === typeof node && console.error(
            "Symbols are not valid as a React child.\n  %s",
            String(node)
          ));
        }
      }
      __name(retryNode, "retryNode");
      __name2(retryNode, "retryNode");
      function renderChildrenArray(request, task, children, childIndex) {
        var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
        var previousDebugTask = task.debugTask;
        pushServerComponentStack(task, task.node._debugInfo);
        if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
          for (var replay = task.replay, replayNodes = replay.nodes, j2 = 0; j2 < replayNodes.length; j2++) {
            var node = replayNodes[j2];
            if (node[1] === childIndex) {
              childIndex = node[2];
              node = node[3];
              task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
              try {
                renderChildrenArray(request, task, children, -1);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x2) {
                if ("object" === typeof x2 && null !== x2 && (x2 === SuspenseException || "function" === typeof x2.then))
                  throw x2;
                task.replay.pendingTasks--;
                var thrownInfo = getThrownInfo(task.componentStack);
                children = task.blockedBoundary;
                var error = x2, resumeSlots = node;
                node = logRecoverableError(
                  request,
                  error,
                  thrownInfo,
                  task.debugTask
                );
                abortRemainingReplayNodes(
                  request,
                  children,
                  childIndex,
                  resumeSlots,
                  error,
                  node,
                  thrownInfo,
                  false
                );
              }
              task.replay = replay;
              replayNodes.splice(j2, 1);
              break;
            }
          }
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        replay = task.treeContext;
        replayNodes = children.length;
        if (null !== task.replay && (j2 = task.replay.slots, null !== j2 && "object" === typeof j2)) {
          for (childIndex = 0; childIndex < replayNodes; childIndex++)
            node = children[childIndex], task.treeContext = pushTreeContext(
              replay,
              replayNodes,
              childIndex
            ), error = j2[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j2[childIndex]) : renderNode(request, task, node, childIndex);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        for (j2 = 0; j2 < replayNodes; j2++) {
          childIndex = children[j2];
          resumeSlots = request;
          node = task;
          error = childIndex;
          if (null !== error && "object" === typeof error && (error.$$typeof === REACT_ELEMENT_TYPE || error.$$typeof === REACT_PORTAL_TYPE) && error._store && (!error._store.validated && null == error.key || 2 === error._store.validated)) {
            if ("object" !== typeof error._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            error._store.validated = 1;
            thrownInfo = resumeSlots.didWarnForKey;
            null == thrownInfo && (thrownInfo = resumeSlots.didWarnForKey = /* @__PURE__ */ new WeakSet());
            resumeSlots = node.componentStack;
            if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {
              thrownInfo.add(resumeSlots);
              var componentName = getComponentNameFromType(error.type);
              thrownInfo = error._owner;
              var parentOwner = resumeSlots.owner;
              resumeSlots = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name = getComponentNameFromType(parentOwner.type);
                name && (resumeSlots = "\n\nCheck the render method of `" + name + "`.");
              }
              resumeSlots || componentName && (resumeSlots = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != thrownInfo && parentOwner !== thrownInfo && (parentOwner = null, "undefined" !== typeof thrownInfo.type ? parentOwner = getComponentNameFromType(thrownInfo.type) : "string" === typeof thrownInfo.name && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              thrownInfo = node.componentStack;
              node.componentStack = {
                parent: node.componentStack,
                type: error.type,
                owner: error._owner,
                stack: error._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                resumeSlots,
                componentName
              );
              node.componentStack = thrownInfo;
            }
          }
          task.treeContext = pushTreeContext(replay, replayNodes, j2);
          renderNode(request, task, childIndex, j2);
        }
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
      }
      __name(renderChildrenArray, "renderChildrenArray");
      __name2(renderChildrenArray, "renderChildrenArray");
      function untrackBoundary(request, boundary) {
        request = request.trackedPostpones;
        null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
      }
      __name(untrackBoundary, "untrackBoundary");
      __name2(untrackBoundary, "untrackBoundary");
      function spawnNewSuspendedReplayTask(request, task, thenableState2) {
        return createReplayTask(
          request,
          thenableState2,
          task.replay,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
      __name2(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
      function spawnNewSuspendedRenderTask(request, task, thenableState2) {
        var segment = task.blockedSegment, newSegment = createPendingSegment(
          request,
          segment.chunks.length,
          null,
          task.formatContext,
          segment.lastPushedText,
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        return createRenderTask(
          request,
          thenableState2,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          newSegment,
          task.blockedPreamble,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
      __name2(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
      function renderNode(request, task, node, childIndex) {
        var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
        if (null === segment)
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue) {
            if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedReplayTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedReplayTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        else {
          var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue$3) {
            if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedRenderTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedRenderTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        }
        task.formatContext = previousFormatContext;
        task.context = previousContext;
        task.keyPath = previousKeyPath;
        task.treeContext = previousTreeContext;
        switchContext(previousContext);
        throw node;
      }
      __name(renderNode, "renderNode");
      __name2(renderNode, "renderNode");
      function abortTaskSoft(task) {
        var boundary = task.blockedBoundary;
        task = task.blockedSegment;
        null !== task && (task.status = 3, finishedTask(this, boundary, task));
      }
      __name(abortTaskSoft, "abortTaskSoft");
      __name2(abortTaskSoft, "abortTaskSoft");
      function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
        for (var i2 = 0; i2 < nodes.length; i2++) {
          var node = nodes[i2];
          if (4 === node.length)
            abortRemainingReplayNodes(
              request$jscomp$0,
              boundary,
              node[2],
              node[3],
              error$jscomp$0,
              errorDigest$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            );
          else {
            var request = request$jscomp$0;
            node = node[5];
            var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
              request,
              /* @__PURE__ */ new Set(),
              null,
              null
            );
            resumedBoundary.parentFlushed = true;
            resumedBoundary.rootSegmentID = node;
            resumedBoundary.status = CLIENT_RENDERED;
            encodeErrorForBoundary(
              resumedBoundary,
              errorDigest,
              error,
              errorInfo,
              wasAborted
            );
            resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
          }
        }
        nodes.length = 0;
        if (null !== slots) {
          if (null === boundary)
            throw Error(
              "We should not have any resumable nodes in the shell. This is a bug in React."
            );
          boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
            boundary,
            errorDigest$jscomp$0,
            error$jscomp$0,
            errorInfo$jscomp$0,
            aborted
          ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
          if ("object" === typeof slots)
            for (var index in slots)
              delete slots[index];
        }
      }
      __name(abortRemainingReplayNodes, "abortRemainingReplayNodes");
      __name2(abortRemainingReplayNodes, "abortRemainingReplayNodes");
      function abortTask(task, request, error) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (null !== segment) {
          if (6 === segment.status)
            return;
          segment.status = 3;
        }
        segment = getThrownInfo(task.componentStack);
        if (null === boundary) {
          if (13 !== request.status && request.status !== CLOSED) {
            boundary = task.replay;
            if (null === boundary) {
              logRecoverableError(request, error, segment, null);
              fatalError(request, error, segment, null);
              return;
            }
            boundary.pendingTasks--;
            0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment, null), abortRemainingReplayNodes(
              request,
              null,
              boundary.nodes,
              boundary.slots,
              error,
              task,
              segment,
              true
            ));
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          }
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, task = logRecoverableError(request, error, segment, null), boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, task, error, segment, true), untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error);
          }), boundary.fallbackAbortableTasks.clear();
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(abortTask, "abortTask");
      __name2(abortTask, "abortTask");
      function safelyEmitEarlyPreloads(request, shellComplete) {
        try {
          var renderState = request.renderState, onHeaders = renderState.onHeaders;
          if (onHeaders) {
            var headers = renderState.headers;
            if (headers) {
              renderState.headers = null;
              var linkHeader = headers.preconnects;
              headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
              headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
              if (!shellComplete) {
                var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                b:
                  for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                    for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                      var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                      var header = getPreloadAsHeader(
                        props$jscomp$0.href,
                        "style",
                        {
                          crossOrigin: props$jscomp$0.crossOrigin,
                          integrity: props$jscomp$0.integrity,
                          nonce: props$jscomp$0.nonce,
                          type: props$jscomp$0.type,
                          fetchPriority: props$jscomp$0.fetchPriority,
                          referrerPolicy: props$jscomp$0.referrerPolicy,
                          media: props$jscomp$0.media
                        }
                      );
                      if (0 <= (headers.remainingCapacity -= header.length + 2))
                        renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                      else
                        break b;
                    }
              }
              linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
            }
          }
        } catch (error) {
          logRecoverableError(request, error, {}, null);
        }
      }
      __name(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
      __name2(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
      function completeShell(request) {
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
        null === request.trackedPostpones && preparePreamble(request);
        request.onShellError = noop2;
        request = request.onShellReady;
        request();
      }
      __name(completeShell, "completeShell");
      __name2(completeShell, "completeShell");
      function completeAll(request) {
        safelyEmitEarlyPreloads(
          request,
          null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
        );
        preparePreamble(request);
        request = request.onAllReady;
        request();
      }
      __name(completeAll, "completeAll");
      __name2(completeAll, "completeAll");
      function queueCompletedSegment(boundary, segment) {
        if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else
          boundary.completedSegments.push(segment);
      }
      __name(queueCompletedSegment, "queueCompletedSegment");
      __name2(queueCompletedSegment, "queueCompletedSegment");
      function finishedTask(request, boundary, segment) {
        if (null === boundary) {
          if (null !== segment && segment.parentFlushed) {
            if (null !== request.completedRootSegment)
              throw Error(
                "There can only be one root segment. This is a bug in React."
              );
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (0 === boundary.pendingTasks ? (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED && (boundary.fallbackAbortableTasks.forEach(
            abortTaskSoft,
            request
          ), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && segment.status === COMPLETED && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(finishedTask, "finishedTask");
      __name2(finishedTask, "finishedTask");
      function performWork(request$jscomp$2) {
        if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
          var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = HooksDispatcher;
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          var prevRequest = currentRequest;
          currentRequest = request$jscomp$2;
          var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
          var prevResumableState = currentResumableState;
          currentResumableState = request$jscomp$2.resumableState;
          try {
            var pingedTasks = request$jscomp$2.pingedTasks, i2;
            for (i2 = 0; i2 < pingedTasks.length; i2++) {
              var request = request$jscomp$2, task = pingedTasks[i2], segment = task.blockedSegment;
              if (null === segment) {
                var prevTaskInDEV = void 0, request$jscomp$0 = request;
                request = task;
                if (0 !== request.replay.pendingTasks) {
                  switchContext(request.context);
                  prevTaskInDEV = currentTaskInDEV;
                  currentTaskInDEV = request;
                  try {
                    "number" === typeof request.replay.slots ? resumeNode(
                      request$jscomp$0,
                      request,
                      request.replay.slots,
                      request.node,
                      request.childIndex
                    ) : retryNode(request$jscomp$0, request);
                    if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    finishedTask(request$jscomp$0, request.blockedBoundary, null);
                  } catch (thrownValue) {
                    resetHooksState();
                    var x2 = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if ("object" === typeof x2 && null !== x2 && "function" === typeof x2.then) {
                      var ping = request.ping;
                      x2.then(ping, ping);
                      request.thenableState = getThenableStateAfterSuspending();
                    } else {
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x2, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                      errorDigest = logRecoverableError(
                        request$jscomp$1,
                        error$jscomp$0,
                        errorInfo$jscomp$0,
                        request.debugTask
                      );
                      abortRemainingReplayNodes(
                        request$jscomp$1,
                        boundary,
                        replayNodes,
                        resumeSlots,
                        error$jscomp$0,
                        errorDigest,
                        errorInfo$jscomp$0,
                        false
                      );
                      request$jscomp$0.pendingRootTasks--;
                      0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                      request$jscomp$0.allPendingTasks--;
                      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                    }
                  } finally {
                    currentTaskInDEV = prevTaskInDEV;
                  }
                }
              } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                request$jscomp$1.status = 6;
                switchContext(errorDigest.context);
                request$jscomp$0 = currentTaskInDEV;
                currentTaskInDEV = errorDigest;
                var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                try {
                  retryNode(request, errorDigest), pushSegmentFinale(
                    request$jscomp$1.chunks,
                    request.renderState,
                    request$jscomp$1.lastPushedText,
                    request$jscomp$1.textEmbedded
                  ), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(
                    request,
                    errorDigest.blockedBoundary,
                    request$jscomp$1
                  );
                } catch (thrownValue) {
                  resetHooksState();
                  request$jscomp$1.children.length = childrenLength;
                  request$jscomp$1.chunks.length = chunkLength;
                  var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                    request$jscomp$1.status = PENDING;
                    errorDigest.thenableState = getThenableStateAfterSuspending();
                    var ping$jscomp$0 = errorDigest.ping;
                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                  } else {
                    var errorInfo$jscomp$1 = getThrownInfo(
                      errorDigest.componentStack
                    );
                    errorDigest.abortSet.delete(errorDigest);
                    request$jscomp$1.status = 4;
                    var boundary$jscomp$0 = errorDigest.blockedBoundary, debugTask = errorDigest.debugTask;
                    prevTaskInDEV = logRecoverableError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    );
                    null === boundary$jscomp$0 ? fatalError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    ) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED && (boundary$jscomp$0.status = CLIENT_RENDERED, encodeErrorForBoundary(
                      boundary$jscomp$0,
                      prevTaskInDEV,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      false
                    ), untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(
                      boundary$jscomp$0
                    ), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                    request.allPendingTasks--;
                    0 === request.allPendingTasks && completeAll(request);
                  }
                } finally {
                  currentTaskInDEV = request$jscomp$0;
                }
              }
            }
            pingedTasks.splice(0, i2);
            null !== request$jscomp$2.destination && flushCompletedQueues(
              request$jscomp$2,
              request$jscomp$2.destination
            );
          } catch (error) {
            pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
          } finally {
            currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
          }
        }
      }
      __name(performWork, "performWork");
      __name2(performWork, "performWork");
      function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
        segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
        for (var pendingPreambles = false, i2 = 0; i2 < segment.children.length; i2++)
          pendingPreambles = preparePreambleFromSegment(
            request,
            segment.children[i2],
            collectedPreambleSegments
          ) || pendingPreambles;
        return pendingPreambles;
      }
      __name(preparePreambleFromSubtree, "preparePreambleFromSubtree");
      __name2(preparePreambleFromSubtree, "preparePreambleFromSubtree");
      function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
        var boundary = segment.boundary;
        if (null === boundary)
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
        if (null === preamble || null === fallbackPreamble)
          return false;
        switch (boundary.status) {
          case COMPLETED:
            hoistPreambleState(request.renderState, preamble);
            segment = boundary.completedSegments[0];
            if (!segment)
              throw Error(
                "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
              );
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          case POSTPONED:
            if (null !== request.trackedPostpones)
              return true;
          case CLIENT_RENDERED:
            if (segment.status === COMPLETED)
              return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
          default:
            return true;
        }
      }
      __name(preparePreambleFromSegment, "preparePreambleFromSegment");
      __name2(preparePreambleFromSegment, "preparePreambleFromSegment");
      function preparePreamble(request) {
        if (request.completedRootSegment && null === request.completedPreambleSegments) {
          var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
            request,
            request.completedRootSegment,
            collectedPreambleSegments
          ), preamble = request.renderState.preamble;
          if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
            request.completedPreambleSegments = collectedPreambleSegments;
        }
      }
      __name(preparePreamble, "preparePreamble");
      __name2(preparePreamble, "preparePreamble");
      function flushSubtree(request, destination, segment, hoistableState) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING:
            segment.id = request.nextSegmentId++;
          case POSTPONED:
            return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push(placeholder1), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push(placeholder2);
          case COMPLETED:
            segment.status = FLUSHED;
            var r3 = true, chunks = segment.chunks, chunkIdx = 0;
            segment = segment.children;
            for (var childIdx = 0; childIdx < segment.length; childIdx++) {
              for (r3 = segment[childIdx]; chunkIdx < r3.index; chunkIdx++)
                destination.push(chunks[chunkIdx]);
              r3 = flushSegment(request, destination, r3, hoistableState);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              destination.push(chunks[chunkIdx]);
            chunkIdx < chunks.length && (r3 = destination.push(chunks[chunkIdx]));
            return r3;
          default:
            throw Error(
              "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
            );
        }
      }
      __name(flushSubtree, "flushSubtree");
      __name2(flushSubtree, "flushSubtree");
      function flushSegment(request, destination, segment, hoistableState) {
        var boundary = segment.boundary;
        if (null === boundary)
          return flushSubtree(request, destination, segment, hoistableState);
        boundary.parentFlushed = true;
        if (boundary.status === CLIENT_RENDERED) {
          if (!request.renderState.generateStaticMarkup) {
            var errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
            destination.push(startClientRenderedSuspenseBoundary);
            destination.push(clientRenderedSuspenseBoundaryError1);
            errorDigest && (destination.push(clientRenderedSuspenseBoundaryError1A), errorDigest = escapeTextForBrowser(errorDigest), destination.push(errorDigest), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorMessage && (destination.push(clientRenderedSuspenseBoundaryError1B), errorMessage = escapeTextForBrowser(errorMessage), destination.push(errorMessage), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorStack && (destination.push(clientRenderedSuspenseBoundaryError1C), errorStack = escapeTextForBrowser(errorStack), destination.push(errorStack), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorComponentStack && (destination.push(clientRenderedSuspenseBoundaryError1D), errorComponentStack = escapeTextForBrowser(errorComponentStack), destination.push(errorComponentStack), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            destination.push(clientRenderedSuspenseBoundaryError2);
          }
          flushSubtree(request, destination, segment, hoistableState);
          request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.fallbackPreamble) && writePreambleContribution(destination, request), destination = destination.push(endSuspenseBoundary));
          return destination;
        }
        if (boundary.status !== COMPLETED)
          return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
            hoistStylesheetDependency,
            hoistableState
          )), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
        if (boundary.byteSize > request.progressiveChunkSize)
          return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
        hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
        request.renderState.generateStaticMarkup || destination.push(startCompletedSuspenseBoundary);
        segment = boundary.completedSegments;
        if (1 !== segment.length)
          throw Error(
            "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
          );
        flushSegment(request, destination, segment[0], hoistableState);
        request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.contentPreamble) && writePreambleContribution(destination, request), destination = destination.push(endSuspenseBoundary));
        return destination;
      }
      __name(flushSegment, "flushSegment");
      __name2(flushSegment, "flushSegment");
      function flushSegmentContainer(request, destination, segment, hoistableState) {
        writeStartSegment(
          destination,
          request.renderState,
          segment.parentFormatContext,
          segment.id
        );
        flushSegment(request, destination, segment, hoistableState);
        return writeEndSegment(destination, segment.parentFormatContext);
      }
      __name(flushSegmentContainer, "flushSegmentContainer");
      __name2(flushSegmentContainer, "flushSegmentContainer");
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++)
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            completedSegments[i2]
          );
        completedSegments.length = 0;
        writeHoistablesForBoundary(
          destination,
          boundary.contentState,
          request.renderState
        );
        completedSegments = request.resumableState;
        request = request.renderState;
        i2 = boundary.rootSegmentID;
        boundary = boundary.contentState;
        var requiresStyleInsertion = request.stylesToHoist;
        request.stylesToHoist = false;
        destination.push(request.startInlineScript);
        requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction | SentCompleteBoundaryFunction, destination.push(completeBoundaryWithStylesScript1FullBoth)) : (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, destination.push(completeBoundaryWithStylesScript1FullPartial)) : destination.push(completeBoundaryWithStylesScript1Partial) : (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions |= SentCompleteBoundaryFunction, destination.push(completeBoundaryScript1Full)) : destination.push(completeBoundaryScript1Partial);
        completedSegments = i2.toString(16);
        destination.push(request.boundaryPrefix);
        destination.push(completedSegments);
        destination.push(completeBoundaryScript2);
        destination.push(request.segmentPrefix);
        destination.push(completedSegments);
        requiresStyleInsertion ? (destination.push(completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : destination.push(completeBoundaryScript3b);
        boundary = destination.push(completeBoundaryScriptEnd);
        return writeBootstrap(destination, request) && boundary;
      }
      __name(flushCompletedBoundary, "flushCompletedBoundary");
      __name2(flushCompletedBoundary, "flushCompletedBoundary");
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED)
          return true;
        var hoistableState = boundary.contentState, segmentID = segment.id;
        if (-1 === segmentID) {
          if (-1 === (segment.id = boundary.rootSegmentID))
            throw Error(
              "A root segment ID must have been assigned by now. This is a bug in React."
            );
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        }
        if (segmentID === boundary.rootSegmentID)
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        flushSegmentContainer(request, destination, segment, hoistableState);
        boundary = request.resumableState;
        request = request.renderState;
        destination.push(request.startInlineScript);
        (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, destination.push(completeSegmentScript1Full)) : destination.push(completeSegmentScript1Partial);
        destination.push(request.segmentPrefix);
        segmentID = segmentID.toString(16);
        destination.push(segmentID);
        destination.push(completeSegmentScript2);
        destination.push(request.placeholderPrefix);
        destination.push(segmentID);
        destination = destination.push(completeSegmentScriptEnd);
        return destination;
      }
      __name(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
      __name2(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
      function flushCompletedQueues(request, destination) {
        try {
          if (!(0 < request.pendingRootTasks)) {
            var i2, completedRootSegment = request.completedRootSegment;
            if (null !== completedRootSegment) {
              if (completedRootSegment.status === POSTPONED)
                return;
              var completedPreambleSegments = request.completedPreambleSegments;
              if (null === completedPreambleSegments)
                return;
              var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
              if (htmlChunks) {
                for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                  destination.push(htmlChunks[i$jscomp$0]);
                if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    destination.push(headChunks[i$jscomp$0]);
                else {
                  var chunk = startChunkForTag("head");
                  destination.push(chunk);
                  destination.push(endOfStartTag);
                }
              } else if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  destination.push(headChunks[i$jscomp$0]);
              var charsetChunks = renderState.charsetChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                destination.push(charsetChunks[i$jscomp$0]);
              charsetChunks.length = 0;
              renderState.preconnects.forEach(flushResource, destination);
              renderState.preconnects.clear();
              var viewportChunks = renderState.viewportChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                destination.push(viewportChunks[i$jscomp$0]);
              viewportChunks.length = 0;
              renderState.fontPreloads.forEach(flushResource, destination);
              renderState.fontPreloads.clear();
              renderState.highImagePreloads.forEach(flushResource, destination);
              renderState.highImagePreloads.clear();
              renderState.styles.forEach(flushStylesInPreamble, destination);
              var importMapChunks = renderState.importMapChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                destination.push(importMapChunks[i$jscomp$0]);
              importMapChunks.length = 0;
              renderState.bootstrapScripts.forEach(flushResource, destination);
              renderState.scripts.forEach(flushResource, destination);
              renderState.scripts.clear();
              renderState.bulkPreloads.forEach(flushResource, destination);
              renderState.bulkPreloads.clear();
              var hoistableChunks = renderState.hoistableChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                destination.push(hoistableChunks[i$jscomp$0]);
              for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
                var segments = completedPreambleSegments[renderState];
                for (preamble = 0; preamble < segments.length; preamble++)
                  flushSegment(request, destination, segments[preamble], null);
              }
              var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
              if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
                var chunk$jscomp$0 = endChunkForTag("head");
                destination.push(chunk$jscomp$0);
              }
              var bodyChunks = preamble$jscomp$0.bodyChunks;
              if (bodyChunks)
                for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                  destination.push(bodyChunks[completedPreambleSegments]);
              flushSegment(request, destination, completedRootSegment, null);
              request.completedRootSegment = null;
              writeBootstrap(destination, request.renderState);
            }
            var renderState$jscomp$0 = request.renderState;
            completedRootSegment = 0;
            var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
            for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
              destination.push(viewportChunks$jscomp$0[completedRootSegment]);
            viewportChunks$jscomp$0.length = 0;
            renderState$jscomp$0.preconnects.forEach(flushResource, destination);
            renderState$jscomp$0.preconnects.clear();
            renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.fontPreloads.clear();
            renderState$jscomp$0.highImagePreloads.forEach(
              flushResource,
              destination
            );
            renderState$jscomp$0.highImagePreloads.clear();
            renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
            renderState$jscomp$0.scripts.forEach(flushResource, destination);
            renderState$jscomp$0.scripts.clear();
            renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.bulkPreloads.clear();
            var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
            for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
              destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
            hoistableChunks$jscomp$0.length = 0;
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            for (i2 = 0; i2 < clientRenderedBoundaries.length; i2++) {
              var boundary = clientRenderedBoundaries[i2];
              renderState$jscomp$0 = destination;
              var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id3 = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
              renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
              (resumableState.instructions & SentClientRenderFunction) === NothingSent ? (resumableState.instructions |= SentClientRenderFunction, renderState$jscomp$0.push(clientRenderScript1Full)) : renderState$jscomp$0.push(clientRenderScript1Partial);
              renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
              var chunk$jscomp$1 = id3.toString(16);
              renderState$jscomp$0.push(chunk$jscomp$1);
              renderState$jscomp$0.push(clientRenderScript1A);
              if (errorDigest || errorMessage || errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
                  errorDigest || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$2);
              }
              if (errorMessage || errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(
                  errorMessage || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$3);
              }
              if (errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
                  errorStack || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$4);
              }
              if (errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$5 = escapeJSStringsForInstructionScripts(errorComponentStack);
                renderState$jscomp$0.push(chunk$jscomp$5);
              }
              var JSCompiler_inline_result = renderState$jscomp$0.push(
                clientRenderScriptEnd
              );
              if (!JSCompiler_inline_result) {
                request.destination = null;
                i2++;
                clientRenderedBoundaries.splice(0, i2);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i2);
            var completedBoundaries = request.completedBoundaries;
            for (i2 = 0; i2 < completedBoundaries.length; i2++)
              if (!flushCompletedBoundary(
                request,
                destination,
                completedBoundaries[i2]
              )) {
                request.destination = null;
                i2++;
                completedBoundaries.splice(0, i2);
                return;
              }
            completedBoundaries.splice(0, i2);
            var partialBoundaries = request.partialBoundaries;
            for (i2 = 0; i2 < partialBoundaries.length; i2++) {
              a: {
                clientRenderedBoundaries = request;
                boundary = destination;
                var boundary$jscomp$0 = partialBoundaries[i2], completedSegments = boundary$jscomp$0.completedSegments;
                for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                  if (!flushPartiallyCompletedSegment(
                    clientRenderedBoundaries,
                    boundary,
                    boundary$jscomp$0,
                    completedSegments[JSCompiler_inline_result]
                  )) {
                    JSCompiler_inline_result++;
                    completedSegments.splice(0, JSCompiler_inline_result);
                    var JSCompiler_inline_result$jscomp$0 = false;
                    break a;
                  }
                completedSegments.splice(0, JSCompiler_inline_result);
                JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                  boundary,
                  boundary$jscomp$0.contentState,
                  clientRenderedBoundaries.renderState
                );
              }
              if (!JSCompiler_inline_result$jscomp$0) {
                request.destination = null;
                i2++;
                partialBoundaries.splice(0, i2);
                return;
              }
            }
            partialBoundaries.splice(0, i2);
            var largeBoundaries = request.completedBoundaries;
            for (i2 = 0; i2 < largeBoundaries.length; i2++)
              if (!flushCompletedBoundary(request, destination, largeBoundaries[i2])) {
                request.destination = null;
                i2++;
                largeBoundaries.splice(0, i2);
                return;
              }
            largeBoundaries.splice(0, i2);
          }
        } finally {
          0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = false, i2 = request.resumableState, i2.hasBody && (partialBoundaries = endChunkForTag("body"), destination.push(partialBoundaries)), i2.hasHtml && (i2 = endChunkForTag("html"), destination.push(i2)), 0 !== request.abortableTasks.size && console.error(
            "There was still abortable task at the root when we closed. This is a bug in React."
          ), request.status = CLOSED, destination.push(null), request.destination = null);
        }
      }
      __name(flushCompletedQueues, "flushCompletedQueues");
      __name2(flushCompletedQueues, "flushCompletedQueues");
      function startWork(request) {
        request.flushScheduled = null !== request.destination;
        performWork(request);
        10 === request.status && (request.status = 11);
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
      }
      __name(startWork, "startWork");
      __name2(startWork, "startWork");
      function enqueueFlush(request) {
        if (false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
          request.flushScheduled = true;
          var destination = request.destination;
          destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
        }
      }
      __name(enqueueFlush, "enqueueFlush");
      __name2(enqueueFlush, "enqueueFlush");
      function startFlowing(request, destination) {
        if (13 === request.status)
          request.status = CLOSED, destination.destroy(request.fatalError);
        else if (request.status !== CLOSED && null === request.destination) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error) {
            destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
          }
        }
      }
      __name(startFlowing, "startFlowing");
      __name2(startFlowing, "startFlowing");
      function abort(request, reason) {
        if (11 === request.status || 10 === request.status)
          request.status = 12;
        try {
          var abortableTasks = request.abortableTasks;
          if (0 < abortableTasks.size) {
            var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
            request.fatalError = error;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, error);
            });
            abortableTasks.clear();
          }
          null !== request.destination && flushCompletedQueues(request, request.destination);
        } catch (error$4) {
          reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
        }
      }
      __name(abort, "abort");
      __name2(abort, "abort");
      function onError() {
      }
      __name(onError, "onError");
      __name2(onError, "onError");
      function renderToStringImpl(children, options2, generateStaticMarkup, abortReason) {
        var didFatal = false, fatalError2 = null, result = "", readyToStream = false;
        options2 = createResumableState(
          options2 ? options2.identifierPrefix : void 0
        );
        children = createRequest(
          children,
          options2,
          createRenderState(options2, generateStaticMarkup),
          createFormatContext(ROOT_HTML_MODE, null, 0),
          Infinity,
          onError,
          void 0,
          function() {
            readyToStream = true;
          },
          void 0,
          void 0,
          void 0
        );
        startWork(children);
        abort(children, abortReason);
        startFlowing(children, {
          push: function(chunk) {
            null !== chunk && (result += chunk);
            return true;
          },
          destroy: function(error) {
            didFatal = true;
            fatalError2 = error;
          }
        });
        if (didFatal && fatalError2 !== abortReason)
          throw fatalError2;
        if (!readyToStream)
          throw Error(
            "A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition."
          );
        return result;
      }
      __name(renderToStringImpl, "renderToStringImpl");
      __name2(renderToStringImpl, "renderToStringImpl");
      var React31 = require_react(), ReactDOM4 = require_react_dom(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), assign = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ), aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties$1 = {}, rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), didWarnValueNull = false, possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React31.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM4.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: false,
        data: null,
        method: null,
        action: null
      }), previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: previousDispatcher.f,
        r: previousDispatcher.r,
        D: function(href) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              if (!resumableState.dnsResources.hasOwnProperty(href)) {
                resumableState.dnsResources[href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                  JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
              }
              enqueueFlush(request);
            }
          } else
            previousDispatcher.D(href);
        },
        C: function(href, crossOrigin) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
              if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                resumableState.connectResources[bucket][href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                  JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                  if ("string" === typeof crossOrigin) {
                    var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                      crossOrigin,
                      "crossOrigin"
                    );
                    JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                  }
                  JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                }
                JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                  rel: "preconnect",
                  href,
                  crossOrigin
                }), renderState.preconnects.add(bucket));
              }
              enqueueFlush(request);
            }
          } else
            previousDispatcher.C(href, crossOrigin);
        },
        L: function(href, as, options2) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (as && href) {
              switch (as) {
                case "image":
                  if (options2) {
                    var imageSrcSet = options2.imageSrcSet;
                    var imageSizes = options2.imageSizes;
                    var fetchPriority = options2.fetchPriority;
                  }
                  var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                  if (resumableState.imageResources.hasOwnProperty(key))
                    return;
                  resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                  resumableState = renderState.headers;
                  var header;
                  resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as, options2), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                    resumableState,
                    assign(
                      {
                        rel: "preload",
                        href: imageSrcSet ? void 0 : href,
                        as
                      },
                      options2
                    )
                  ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                  break;
                case "style":
                  if (resumableState.styleResources.hasOwnProperty(href))
                    return;
                  imageSrcSet = [];
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as }, options2)
                  );
                  resumableState.styleResources[href] = !options2 || "string" !== typeof options2.crossOrigin && "string" !== typeof options2.integrity ? PRELOAD_NO_CREDS : [options2.crossOrigin, options2.integrity];
                  renderState.preloads.stylesheets.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  break;
                case "script":
                  if (resumableState.scriptResources.hasOwnProperty(href))
                    return;
                  imageSrcSet = [];
                  renderState.preloads.scripts.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  pushLinkImpl(
                    imageSrcSet,
                    assign({ rel: "preload", href, as }, options2)
                  );
                  resumableState.scriptResources[href] = !options2 || "string" !== typeof options2.crossOrigin && "string" !== typeof options2.integrity ? PRELOAD_NO_CREDS : [options2.crossOrigin, options2.integrity];
                  break;
                default:
                  if (resumableState.unknownResources.hasOwnProperty(as)) {
                    if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
                      return;
                  } else
                    imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
                  imageSrcSet[href] = PRELOAD_NO_CREDS;
                  if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader(href, as, options2), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                    renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                  else
                    switch (resumableState = [], href = assign(
                      { rel: "preload", href, as },
                      options2
                    ), pushLinkImpl(resumableState, href), as) {
                      case "font":
                        renderState.fontPreloads.add(resumableState);
                        break;
                      default:
                        renderState.bulkPreloads.add(resumableState);
                    }
              }
              enqueueFlush(request);
            }
          } else
            previousDispatcher.L(href, as, options2);
        },
        m: function(href, options2) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              var as = options2 && "string" === typeof options2.as ? options2.as : "script";
              switch (as) {
                case "script":
                  if (resumableState.moduleScriptResources.hasOwnProperty(href))
                    return;
                  as = [];
                  resumableState.moduleScriptResources[href] = !options2 || "string" !== typeof options2.crossOrigin && "string" !== typeof options2.integrity ? PRELOAD_NO_CREDS : [options2.crossOrigin, options2.integrity];
                  renderState.preloads.moduleScripts.set(href, as);
                  break;
                default:
                  if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
                    var resources = resumableState.unknownResources[as];
                    if (resources.hasOwnProperty(href))
                      return;
                  } else
                    resources = {}, resumableState.moduleUnknownResources[as] = resources;
                  as = [];
                  resources[href] = PRELOAD_NO_CREDS;
              }
              pushLinkImpl(
                as,
                assign({ rel: "modulepreload", href }, options2)
              );
              renderState.bulkPreloads.add(as);
              enqueueFlush(request);
            }
          } else
            previousDispatcher.m(href, options2);
        },
        X: function(src, options2) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.scriptResources.hasOwnProperty(
                src
              ) ? resumableState.scriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options2 = assign({ src, async: true }, options2), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options2, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options2), enqueueFlush(request));
            }
          } else
            previousDispatcher.X(src, options2);
        },
        S: function(href, precedence, options2) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              precedence = precedence || "default";
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                precedence: escapeTextForBrowser(precedence),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue)), precedence = {
                state: PENDING$1,
                props: assign(
                  {
                    rel: "stylesheet",
                    href,
                    "data-precedence": precedence
                  },
                  options2
                )
              }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
            }
          } else
            previousDispatcher.S(href, precedence, options2);
        },
        M: function(src, options2) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options2 = assign(
                { src, type: "module", async: true },
                options2
              ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options2, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options2), enqueueFlush(request));
            }
          } else
            previousDispatcher.M(src, options2);
        }
      };
      var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, EXISTS = null, PRELOAD_NO_CREDS = [];
      Object.freeze(PRELOAD_NO_CREDS);
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var didWarnForNewBooleanPropsWithEmptyValue = {};
      var NoContribution = 0, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";", attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""', actionJavaScriptURL = escapeTextForBrowser(
        "javascript:throw new Error('React form unexpectedly submitted.')"
      ), endOfStartTag = ">", endOfStartTagSelfClosing = "/>", didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, formReplayingRuntimeScript = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex = /(<\/|<)(s)(tyle)/gi, leadingNewline = "\n", VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), endTagCache = /* @__PURE__ */ new Map(), placeholder1 = '<template id="', placeholder2 = '"></template>', startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError1D = ' data-cstck="', clientRenderedSuspenseBoundaryError2 = "></template>", boundaryPreambleContributionChunkStart = "<!--", boundaryPreambleContributionChunkEnd = "-->", startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>", completeSegmentScript1Full = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScriptEnd = '")<\/script>', completeBoundaryScript1Full = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("', completeBoundaryScript1Partial = '$RC("', completeBoundaryWithStylesScript1FullBoth = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("', completeBoundaryWithStylesScript1FullPartial = '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("', completeBoundaryWithStylesScript1Partial = '$RR("', completeBoundaryScript2 = '","', completeBoundaryScript3a = '",', completeBoundaryScript3b = '"', completeBoundaryScriptEnd = ")<\/script>", clientRenderScript1Full = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderErrorScriptArgInterstitial = ",", clientRenderScriptEnd = ")<\/script>", regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = '<style media="not all" data-precedence="', lateStyleTagResourceOpen2 = '" data-href="', lateStyleTagResourceOpen3 = '">', lateStyleTagTemplateClose = "</style>", currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = '<style data-precedence="', styleTagResourceOpen2 = '" data-href="', spaceSeparator = " ", styleTagResourceOpen3 = '">', styleTagResourceClose = "</style>", arrayFirstOpenBracket = "[", arraySubsequentOpenBracket = ",[", arrayInterstitial = ",", arrayCloseBracket = "]", PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, doctypeChunk = "", bind = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var rendererSigil = {};
      var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          var internals = inst._reactInternals;
          null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          inst.replace = true;
          inst.queue = [payload];
          void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        },
        enqueueForceUpdate: function(inst, callback) {
          null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }
      }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
        readContext,
        use: function(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then)
              return unwrapThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE)
              return readContext(usable);
          }
          throw Error(
            "An unsupported type was passed to use(): " + String(usable)
          );
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          resolveCurrentlyRenderingComponent();
          return context._currentValue2;
        },
        useMemo: useMemo14,
        useReducer: useReducer3,
        useRef: function(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          return useReducer3(basicStateReducer, initialState);
        },
        useInsertionEffect: noop$1,
        useLayoutEffect: noop$1,
        useCallback: function(callback, deps) {
          return useMemo14(function() {
            return callback;
          }, deps);
        },
        useImperativeHandle: noop$1,
        useEffect: noop$1,
        useDebugValue: noop$1,
        useDeferredValue: function(value, initialValue) {
          resolveCurrentlyRenderingComponent();
          return void 0 !== initialValue ? initialValue : value;
        },
        useTransition: function() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        },
        useId: function() {
          var treeId = currentlyRenderingTask.treeContext;
          var overflow = treeId.overflow;
          treeId = treeId.id;
          treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
          var resumableState = currentResumableState;
          if (null === resumableState)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component."
            );
          overflow = localIdCounter++;
          treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
          0 < overflow && (treeId += "H" + overflow.toString(32));
          return treeId + "\xBB";
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          return getServerSnapshot();
        },
        useOptimistic: function(passthrough) {
          resolveCurrentlyRenderingComponent();
          return [passthrough, unsupportedSetOptimisticState];
        },
        useActionState,
        useFormState: useActionState,
        useHostTransitionStatus: function() {
          resolveCurrentlyRenderingComponent();
          return NotPending;
        },
        useMemoCache: function(size3) {
          for (var data = Array(size3), i2 = 0; i2 < size3; i2++)
            data[i2] = REACT_MEMO_CACHE_SENTINEL;
          return data;
        },
        useCacheRefresh: function() {
          return unsupportedRefresh;
        }
      }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
        getCacheForType: function() {
          throw Error("Not implemented.");
        },
        getOwner: function() {
          return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
        }
      }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var callComponent = {
        "react-stack-bottom-frame": function(Component3, props, secondArg) {
          return Component3(props, secondArg);
        }
      }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
        "react-stack-bottom-frame": function(instance) {
          return instance.render();
        }
      }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callLazyInit = {
        "react-stack-bottom-frame": function(lazy) {
          var init2 = lazy._init;
          return init2(lazy._payload);
        }
      }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = /* @__PURE__ */ __name2(function() {
          return localPerformance.now();
        }, "getCurrentTime");
      } else {
        var localDate = Date;
        getCurrentTime = /* @__PURE__ */ __name2(function() {
          return localDate.now();
        }, "getCurrentTime");
      }
      var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false;
      exports.renderToStaticMarkup = function(children, options2) {
        return renderToStringImpl(
          children,
          options2,
          true,
          'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
        );
      };
      exports.renderToString = function(children, options2) {
        return renderToStringImpl(
          children,
          options2,
          false,
          'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
        );
      };
      exports.version = "19.1.0";
    })();
  }
});
var require_server_edge = __commonJS({
  "../node_modules/react-dom/server.edge.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var b2;
    var l2;
    if (false) {
      b2 = null;
      l2 = null;
    } else {
      b2 = require_react_dom_server_edge_development();
      l2 = require_react_dom_server_legacy_browser_development();
    }
    exports.version = b2.version;
    exports.renderToReadableStream = b2.renderToReadableStream;
    exports.renderToString = l2.renderToString;
    exports.renderToStaticMarkup = l2.renderToStaticMarkup;
    if (b2.resume) {
      exports.resume = b2.resume;
    }
  }
});
var require_react_is_development = __commonJS({
  "../node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type6) {
          return typeof type6 === "string" || typeof type6 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type6 === REACT_FRAGMENT_TYPE || type6 === REACT_CONCURRENT_MODE_TYPE || type6 === REACT_PROFILER_TYPE || type6 === REACT_STRICT_MODE_TYPE || type6 === REACT_SUSPENSE_TYPE || type6 === REACT_SUSPENSE_LIST_TYPE || typeof type6 === "object" && type6 !== null && (type6.$$typeof === REACT_LAZY_TYPE || type6.$$typeof === REACT_MEMO_TYPE || type6.$$typeof === REACT_PROVIDER_TYPE || type6.$$typeof === REACT_CONTEXT_TYPE || type6.$$typeof === REACT_FORWARD_REF_TYPE || type6.$$typeof === REACT_FUNDAMENTAL_TYPE || type6.$$typeof === REACT_RESPONDER_TYPE || type6.$$typeof === REACT_SCOPE_TYPE || type6.$$typeof === REACT_BLOCK_TYPE);
        }
        __name(isValidElementType, "isValidElementType");
        __name2(isValidElementType, "isValidElementType");
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type6 = object.type;
                switch (type6) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type6;
                  default:
                    var $$typeofType = type6 && type6.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        __name(typeOf, "typeOf");
        __name2(typeOf, "typeOf");
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment11 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal3 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        __name(isAsyncMode, "isAsyncMode");
        __name2(isAsyncMode, "isAsyncMode");
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        __name(isConcurrentMode, "isConcurrentMode");
        __name2(isConcurrentMode, "isConcurrentMode");
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        __name(isContextConsumer, "isContextConsumer");
        __name2(isContextConsumer, "isContextConsumer");
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        __name(isContextProvider, "isContextProvider");
        __name2(isContextProvider, "isContextProvider");
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        __name(isElement, "isElement");
        __name2(isElement, "isElement");
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        __name(isForwardRef, "isForwardRef");
        __name2(isForwardRef, "isForwardRef");
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        __name(isFragment, "isFragment");
        __name2(isFragment, "isFragment");
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        __name(isLazy, "isLazy");
        __name2(isLazy, "isLazy");
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        __name(isMemo, "isMemo");
        __name2(isMemo, "isMemo");
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        __name(isPortal, "isPortal");
        __name2(isPortal, "isPortal");
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        __name(isProfiler, "isProfiler");
        __name2(isProfiler, "isProfiler");
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        __name(isStrictMode, "isStrictMode");
        __name2(isStrictMode, "isStrictMode");
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        __name(isSuspense, "isSuspense");
        __name2(isSuspense, "isSuspense");
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment11;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal3;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});
var require_react_is = __commonJS({
  "../node_modules/react-is/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});
var require_object_assign = __commonJS({
  "../node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    __name(toObject, "toObject");
    __name2(toObject, "toObject");
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    __name(shouldUseNative, "shouldUseNative");
    __name2(shouldUseNative, "shouldUseNative");
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from27;
      var to3 = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from27 = Object(arguments[s2]);
        for (var key in from27) {
          if (hasOwnProperty.call(from27, key)) {
            to3[key] = from27[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from27);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from27, symbols[i2])) {
              to3[symbols[i2]] = from27[symbols[i2]];
            }
          }
        }
      }
      return to3;
    };
  }
});
var require_ReactPropTypesSecret = __commonJS({
  "../node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});
var require_has = __commonJS({
  "../node_modules/prop-types/lib/has.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});
var require_checkPropTypes = __commonJS({
  "../node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var printWarning = /* @__PURE__ */ __name2(function() {
    }, "printWarning");
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = /* @__PURE__ */ __name2(function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      }, "printWarning");
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    __name(checkPropTypes, "checkPropTypes");
    __name2(checkPropTypes, "checkPropTypes");
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});
var require_factoryWithTypeCheckers = __commonJS({
  "../node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = /* @__PURE__ */ __name2(function() {
    }, "printWarning");
    if (true) {
      printWarning = /* @__PURE__ */ __name2(function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      }, "printWarning");
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    __name(emptyFunctionThatReturnsNull, "emptyFunctionThatReturnsNull");
    __name2(emptyFunctionThatReturnsNull, "emptyFunctionThatReturnsNull");
    module.exports = function(isValidElement3, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      __name(getIteratorFn, "getIteratorFn");
      __name2(getIteratorFn, "getIteratorFn");
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x2, y2) {
        if (x2 === y2) {
          return x2 !== 0 || 1 / x2 === 1 / y2;
        } else {
          return x2 !== x2 && y2 !== y2;
        }
      }
      __name(is, "is");
      __name2(is, "is");
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      __name(PropTypeError, "PropTypeError");
      __name2(PropTypeError, "PropTypeError");
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate13) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate13(props, propName, componentName, location, propFullName);
          }
        }
        __name(checkType, "checkType");
        __name2(checkType, "checkType");
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      __name(createChainableTypeChecker, "createChainableTypeChecker");
      __name2(createChainableTypeChecker, "createChainableTypeChecker");
      function createPrimitiveTypeChecker(expectedType) {
        function validate13(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createPrimitiveTypeChecker, "createPrimitiveTypeChecker");
      __name2(createPrimitiveTypeChecker, "createPrimitiveTypeChecker");
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      __name(createAnyTypeChecker, "createAnyTypeChecker");
      __name2(createAnyTypeChecker, "createAnyTypeChecker");
      function createArrayOfTypeChecker(typeChecker) {
        function validate13(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createArrayOfTypeChecker, "createArrayOfTypeChecker");
      __name2(createArrayOfTypeChecker, "createArrayOfTypeChecker");
      function createElementTypeChecker() {
        function validate13(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement3(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createElementTypeChecker, "createElementTypeChecker");
      __name2(createElementTypeChecker, "createElementTypeChecker");
      function createElementTypeTypeChecker() {
        function validate13(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createElementTypeTypeChecker, "createElementTypeTypeChecker");
      __name2(createElementTypeTypeChecker, "createElementTypeTypeChecker");
      function createInstanceTypeChecker(expectedClass) {
        function validate13(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createInstanceTypeChecker, "createInstanceTypeChecker");
      __name2(createInstanceTypeChecker, "createInstanceTypeChecker");
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate13(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function replacer(key, value) {
            var type6 = getPreciseType(value);
            if (type6 === "symbol") {
              return String(value);
            }
            return value;
          }, "replacer"), "replacer"));
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createEnumTypeChecker, "createEnumTypeChecker");
      __name2(createEnumTypeChecker, "createEnumTypeChecker");
      function createObjectOfTypeChecker(typeChecker) {
        function validate13(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createObjectOfTypeChecker, "createObjectOfTypeChecker");
      __name2(createObjectOfTypeChecker, "createObjectOfTypeChecker");
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate13(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createUnionTypeChecker, "createUnionTypeChecker");
      __name2(createUnionTypeChecker, "createUnionTypeChecker");
      function createNodeChecker() {
        function validate13(props, propName, componentName, location, propFullName) {
          if (!isNode2(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createNodeChecker, "createNodeChecker");
      __name2(createNodeChecker, "createNodeChecker");
      function invalidValidatorError(componentName, location, propFullName, key, type6) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type6 + "`."
        );
      }
      __name(invalidValidatorError, "invalidValidatorError");
      __name2(invalidValidatorError, "invalidValidatorError");
      function createShapeTypeChecker(shapeTypes) {
        function validate13(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createShapeTypeChecker, "createShapeTypeChecker");
      __name2(createShapeTypeChecker, "createShapeTypeChecker");
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate13(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate13, "validate13");
        __name2(validate13, "validate");
        return createChainableTypeChecker(validate13);
      }
      __name(createStrictShapeTypeChecker, "createStrictShapeTypeChecker");
      __name2(createStrictShapeTypeChecker, "createStrictShapeTypeChecker");
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement3(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      __name(isNode2, "isNode2");
      __name2(isNode2, "isNode");
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      __name(isSymbol, "isSymbol");
      __name2(isSymbol, "isSymbol");
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      __name(getPropType, "getPropType");
      __name2(getPropType, "getPropType");
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      __name(getPreciseType, "getPreciseType");
      __name2(getPreciseType, "getPreciseType");
      function getPostfixForTypeWarning(value) {
        var type6 = getPreciseType(value);
        switch (type6) {
          case "array":
          case "object":
            return "an " + type6;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type6;
          default:
            return type6;
        }
      }
      __name(getPostfixForTypeWarning, "getPostfixForTypeWarning");
      __name2(getPostfixForTypeWarning, "getPostfixForTypeWarning");
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      __name(getClassName, "getClassName");
      __name2(getClassName, "getClassName");
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});
var require_prop_types = __commonJS({
  "../node_modules/prop-types/index.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});
function p(e2, r3) {
  return e2(r3 = { exports: {} }, r3.exports), r3.exports;
}
__name(p, "p");
function x(r3) {
  var t2 = r3.children, n2 = void 0 === t2 ? "" : t2, o2 = O(r3, ["children"]);
  return "string" != typeof n2 && (n2 = (0, import_server.renderToString)(n2)), import_react4.default.createElement("template", S({}, o2, { dangerouslySetInnerHTML: { __html: n2 } }));
}
__name(x, "x");
function z(e2) {
  var r3 = e2.root, t2 = e2.children;
  return (0, import_react_dom.createPortal)(void 0 === t2 ? null : t2, r3);
}
__name(z, "z");
function E(n2) {
  var i2 = (0, import_react4.forwardRef)(function(o2, i3) {
    var u2, l2, s2 = o2.mode, f2 = void 0 === s2 ? "open" : s2, p2 = o2.delegatesFocus, d2 = void 0 !== p2 && p2, y2 = o2.styleSheets, h2 = void 0 === y2 ? [] : y2, v2 = o2.ssr, m2 = void 0 !== v2 && v2, b2 = o2.children, w2 = O(o2, ["mode", "delegatesFocus", "styleSheets", "ssr", "children"]), E2 = (l2 = (0, import_react4.useRef)((u2 = i3) && u2.current), (0, import_react4.useEffect)(function() {
      u2 && (u2.current = l2.current);
    }, [u2]), l2), T2 = (0, import_react4.useState)(null), A = g(T2, 2), C2 = A[0], P2 = A[1], F = "node_".concat(f2).concat(d2);
    return (0, import_react4.useLayoutEffect)(function() {
      if (E2.current)
        try {
          if ("function" == typeof i3 && i3(E2.current), m2) {
            var e2 = E2.current.shadowRoot;
            return void P2(e2);
          }
          var r3 = E2.current.attachShadow({ mode: f2, delegatesFocus: d2 });
          h2.length > 0 && (r3.adoptedStyleSheets = h2), P2(r3);
        } catch (e3) {
          !function(e4) {
            var r4 = e4.error, t2 = e4.styleSheets, n3 = e4.root;
            switch (r4.name) {
              case "NotSupportedError":
                t2.length > 0 && (n3.adoptedStyleSheets = t2);
                break;
              default:
                throw r4;
            }
          }({ error: e3, styleSheets: h2, root: C2 });
        }
    }, [i3, E2, h2]), import_react4.default.createElement(import_react4.default.Fragment, null, import_react4.default.createElement(n2.tag, S({ key: F, ref: E2 }, w2), (C2 || m2) && import_react4.default.createElement(j.Provider, { value: C2 }, m2 ? import_react4.default.createElement(x, { shadowroot: f2, shadowrootmode: f2 }, n2.render({ root: C2, ssr: m2, children: b2 })) : import_react4.default.createElement(z, { root: C2 }, n2.render({ root: C2, ssr: m2, children: b2 })))));
  });
  return i2.propTypes = { mode: import_prop_types.default.oneOf(["open", "closed"]), delegatesFocus: import_prop_types.default.bool, styleSheets: import_prop_types.default.arrayOf(import_prop_types.default.instanceOf(globalThis.CSSStyleSheet)), ssr: import_prop_types.default.bool, children: import_prop_types.default.node }, i2;
}
__name(E, "E");
function C() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "core", t2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function(e3) {
    return e3.children;
  };
  return new Proxy(e2, { get: function(e3, n2) {
    var o2 = d(n2, { separator: "-" }), a2 = "".concat(r3, "-").concat(o2);
    return T.has(a2) || T.set(a2, E({ tag: o2, render: t2 })), T.get(a2);
  } });
}
__name(C, "C");
var import_react4;
var import_react_dom;
var import_server;
var import_prop_types;
var f;
var d;
var y;
var h;
var v;
var m;
var b;
var g;
var S;
var w;
var O;
var j;
var T;
var P;
var react_shadow_esm_default;
var init_react_shadow_esm = __esm({
  "../node_modules/react-shadow/react-shadow.esm.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react4 = __toESM(require_react());
    import_react_dom = __toESM(require_react_dom());
    import_server = __toESM(require_server_edge());
    import_prop_types = __toESM(require_prop_types());
    f = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    __name2(p, "p");
    d = p(function(e2) {
      !function(r3) {
        var t2 = /* @__PURE__ */ __name2(function(e3, r4, n3) {
          if (!u2(r4) || s2(r4) || f2(r4) || p2(r4) || i2(r4))
            return r4;
          var o3, a3 = 0, c3 = 0;
          if (l2(r4))
            for (o3 = [], c3 = r4.length; a3 < c3; a3++)
              o3.push(t2(e3, r4[a3], n3));
          else
            for (var d3 in o3 = {}, r4)
              Object.prototype.hasOwnProperty.call(r4, d3) && (o3[e3(d3, n3)] = t2(e3, r4[d3], n3));
          return o3;
        }, "t"), n2 = /* @__PURE__ */ __name2(function(e3) {
          return d2(e3) ? e3 : (e3 = e3.replace(/[\-_\s]+(.)?/g, function(e4, r4) {
            return r4 ? r4.toUpperCase() : "";
          })).substr(0, 1).toLowerCase() + e3.substr(1);
        }, "n"), o2 = /* @__PURE__ */ __name2(function(e3) {
          var r4 = n2(e3);
          return r4.substr(0, 1).toUpperCase() + r4.substr(1);
        }, "o"), a2 = /* @__PURE__ */ __name2(function(e3, r4) {
          return function(e4, r5) {
            var t3 = (r5 = r5 || {}).separator || "_", n3 = r5.split || /(?=[A-Z])/;
            return e4.split(n3).join(t3);
          }(e3, r4).toLowerCase();
        }, "a"), c2 = Object.prototype.toString, i2 = /* @__PURE__ */ __name2(function(e3) {
          return "function" == typeof e3;
        }, "i"), u2 = /* @__PURE__ */ __name2(function(e3) {
          return e3 === Object(e3);
        }, "u"), l2 = /* @__PURE__ */ __name2(function(e3) {
          return "[object Array]" == c2.call(e3);
        }, "l"), s2 = /* @__PURE__ */ __name2(function(e3) {
          return "[object Date]" == c2.call(e3);
        }, "s"), f2 = /* @__PURE__ */ __name2(function(e3) {
          return "[object RegExp]" == c2.call(e3);
        }, "f"), p2 = /* @__PURE__ */ __name2(function(e3) {
          return "[object Boolean]" == c2.call(e3);
        }, "p"), d2 = /* @__PURE__ */ __name2(function(e3) {
          return (e3 -= 0) == e3;
        }, "d"), y2 = /* @__PURE__ */ __name2(function(e3, r4) {
          var t3 = r4 && "process" in r4 ? r4.process : r4;
          return "function" != typeof t3 ? e3 : function(r5, n3) {
            return t3(r5, e3, n3);
          };
        }, "y"), h2 = { camelize: n2, decamelize: a2, pascalize: o2, depascalize: a2, camelizeKeys: function(e3, r4) {
          return t2(y2(n2, r4), e3);
        }, decamelizeKeys: function(e3, r4) {
          return t2(y2(a2, r4), e3, r4);
        }, pascalizeKeys: function(e3, r4) {
          return t2(y2(o2, r4), e3);
        }, depascalizeKeys: function() {
          return this.decamelizeKeys.apply(this, arguments);
        } };
        e2.exports ? e2.exports = h2 : r3.humps = h2;
      }(f);
    }).decamelize;
    y = /* @__PURE__ */ __name2(function(e2) {
      if (Array.isArray(e2))
        return e2;
    }, "y");
    h = /* @__PURE__ */ __name2(function(e2, r3) {
      if ("undefined" != typeof Symbol && Symbol.iterator in Object(e2)) {
        var t2 = [], n2 = true, o2 = false, a2 = void 0;
        try {
          for (var c2, i2 = e2[Symbol.iterator](); !(n2 = (c2 = i2.next()).done) && (t2.push(c2.value), !r3 || t2.length !== r3); n2 = true)
            ;
        } catch (e3) {
          o2 = true, a2 = e3;
        } finally {
          try {
            n2 || null == i2.return || i2.return();
          } finally {
            if (o2)
              throw a2;
          }
        }
        return t2;
      }
    }, "h");
    v = /* @__PURE__ */ __name2(function(e2, r3) {
      (null == r3 || r3 > e2.length) && (r3 = e2.length);
      for (var t2 = 0, n2 = new Array(r3); t2 < r3; t2++)
        n2[t2] = e2[t2];
      return n2;
    }, "v");
    m = /* @__PURE__ */ __name2(function(e2, r3) {
      if (e2) {
        if ("string" == typeof e2)
          return v(e2, r3);
        var t2 = Object.prototype.toString.call(e2).slice(8, -1);
        return "Object" === t2 && e2.constructor && (t2 = e2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(e2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? v(e2, r3) : void 0;
      }
    }, "m");
    b = /* @__PURE__ */ __name2(function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }, "b");
    g = /* @__PURE__ */ __name2(function(e2, r3) {
      return y(e2) || h(e2, r3) || m(e2, r3) || b();
    }, "g");
    S = p(function(e2) {
      function r3() {
        return e2.exports = r3 = Object.assign || function(e3) {
          for (var r4 = 1; r4 < arguments.length; r4++) {
            var t2 = arguments[r4];
            for (var n2 in t2)
              Object.prototype.hasOwnProperty.call(t2, n2) && (e3[n2] = t2[n2]);
          }
          return e3;
        }, r3.apply(this, arguments);
      }
      __name(r3, "r3");
      __name2(r3, "r");
      e2.exports = r3;
    });
    w = /* @__PURE__ */ __name2(function(e2, r3) {
      if (null == e2)
        return {};
      var t2, n2, o2 = {}, a2 = Object.keys(e2);
      for (n2 = 0; n2 < a2.length; n2++)
        t2 = a2[n2], r3.indexOf(t2) >= 0 || (o2[t2] = e2[t2]);
      return o2;
    }, "w");
    O = /* @__PURE__ */ __name2(function(e2, r3) {
      if (null == e2)
        return {};
      var t2, n2, o2 = w(e2, r3);
      if (Object.getOwnPropertySymbols) {
        var a2 = Object.getOwnPropertySymbols(e2);
        for (n2 = 0; n2 < a2.length; n2++)
          t2 = a2[n2], r3.indexOf(t2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, t2) && (o2[t2] = e2[t2]);
      }
      return o2;
    }, "O");
    j = (0, import_react4.createContext)(null);
    __name2(x, "x");
    __name2(z, "z");
    __name2(E, "E");
    x.propTypes = { children: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.node]) }, z.propTypes = { root: import_prop_types.default.object.isRequired, children: import_prop_types.default.node };
    T = /* @__PURE__ */ new Map();
    __name2(C, "C");
    P = C();
    react_shadow_esm_default = P;
  }
});
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  }, "handleEvent"), "handleEvent");
}
__name(composeEventHandlers, "composeEventHandlers");
var init_dist3 = __esm({
  "../node_modules/@radix-ui/primitive/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(composeEventHandlers, "composeEventHandlers");
  }
});
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
__name(setRef, "setRef");
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i2 = 0; i2 < cleanups.length; i2++) {
          const cleanup = cleanups[i2];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i2], null);
          }
        }
      };
    }
  };
}
__name(composeRefs, "composeRefs");
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
__name(useComposedRefs, "useComposedRefs");
var React;
var init_dist4 = __esm({
  "../node_modules/@radix-ui/react-compose-refs/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React = __toESM(require_react(), 1);
    __name2(setRef, "setRef");
    __name2(composeRefs, "composeRefs");
    __name2(useComposedRefs, "useComposedRefs");
  }
});
function createContext2(rootComponentName, defaultContext) {
  const Context = React2.createContext(defaultContext);
  const Provider2 = /* @__PURE__ */ __name2((props) => {
    const { children, ...context } = props;
    const value = React2.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Context.Provider, { value, children });
  }, "Provider");
  Provider2.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React2.useContext(Context);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  __name(useContext22, "useContext22");
  __name2(useContext22, "useContext2");
  return [Provider2, useContext22];
}
__name(createContext2, "createContext2");
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React2.createContext(defaultContext);
    const index = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = /* @__PURE__ */ __name2((props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index] || BaseContext;
      const value = React2.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Context.Provider, { value, children });
    }, "Provider");
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index] || BaseContext;
      const context = React2.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    __name(useContext22, "useContext22");
    __name2(useContext22, "useContext2");
    return [Provider2, useContext22];
  }
  __name(createContext32, "createContext32");
  __name2(createContext32, "createContext3");
  const createScope = /* @__PURE__ */ __name2(() => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React2.createContext(defaultContext);
    });
    return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React2.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    }, "useScope"), "useScope");
  }, "createScope");
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
__name(createContextScope, "createContextScope");
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = /* @__PURE__ */ __name2(() => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React2.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    }, "useComposedScopes"), "useComposedScopes");
  }, "createScope");
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
__name(composeContextScopes, "composeContextScopes");
var React2;
var import_jsx_runtime2;
var init_dist5 = __esm({
  "../node_modules/@radix-ui/react-context/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React2 = __toESM(require_react(), 1);
    import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
    __name2(createContext2, "createContext2");
    __name2(createContextScope, "createContextScope");
    __name2(composeContextScopes, "composeContextScopes");
  }
});
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = React3.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React3.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React3.Children.count(newElement) > 1)
            return React3.Children.only(null);
          return React3.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React3.isValidElement(newElement) ? React3.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
__name(createSlot, "createSlot");
function createSlotClone(ownerName) {
  const SlotClone = React3.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenRef = React3.isValidElement(children) ? getElementRef(children) : void 0;
    const ref = useComposedRefs(childrenRef, forwardedRef);
    if (React3.isValidElement(children)) {
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React3.Fragment) {
        props2.ref = ref;
      }
      return React3.cloneElement(children, props2);
    }
    return React3.Children.count(children) > 1 ? React3.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
__name(createSlotClone, "createSlotClone");
function isSlottable(child) {
  return React3.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
__name(isSlottable, "isSlottable");
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
__name(mergeProps, "mergeProps");
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
__name(getElementRef, "getElementRef");
var React3;
var import_jsx_runtime3;
var SLOTTABLE_IDENTIFIER;
var init_dist6 = __esm({
  "../node_modules/@radix-ui/react-slot/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React3 = __toESM(require_react(), 1);
    init_dist4();
    import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
    __name2(createSlot, "createSlot");
    __name2(createSlotClone, "createSlotClone");
    SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
    __name2(isSlottable, "isSlottable");
    __name2(mergeProps, "mergeProps");
    __name2(getElementRef, "getElementRef");
  }
});
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = /* @__PURE__ */ __name2((props) => {
    const { scope, children } = props;
    const ref = import_react5.default.useRef(null);
    const itemMap = import_react5.default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  }, "CollectionProvider");
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react5.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react5.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = import_react5.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react5.default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react5.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  __name(useCollection2, "useCollection2");
  __name2(useCollection2, "useCollection");
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
__name(createCollection, "createCollection");
var import_react5;
var import_jsx_runtime4;
var import_react6;
var import_jsx_runtime5;
var init_dist7 = __esm({
  "../node_modules/@radix-ui/react-collection/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react5 = __toESM(require_react(), 1);
    init_dist5();
    init_dist4();
    init_dist6();
    import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
    import_react6 = __toESM(require_react(), 1);
    import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
    __name2(createCollection, "createCollection");
  }
});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM.flushSync(() => target.dispatchEvent(event));
}
__name(dispatchDiscreteCustomEvent, "dispatchDiscreteCustomEvent");
var React5;
var ReactDOM;
var import_jsx_runtime6;
var NODES;
var Primitive;
var init_dist8 = __esm({
  "../node_modules/@radix-ui/react-primitive/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React5 = __toESM(require_react(), 1);
    ReactDOM = __toESM(require_react_dom(), 1);
    init_dist6();
    import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
    NODES = [
      "a",
      "button",
      "div",
      "form",
      "h2",
      "h3",
      "img",
      "input",
      "label",
      "li",
      "nav",
      "ol",
      "p",
      "select",
      "span",
      "svg",
      "ul"
    ];
    Primitive = NODES.reduce((primitive, node) => {
      const Slot2 = createSlot(`Primitive.${node}`);
      const Node2 = React5.forwardRef((props, forwardedRef) => {
        const { asChild, ...primitiveProps } = props;
        const Comp = asChild ? Slot2 : node;
        if (typeof window !== "undefined") {
          window[Symbol.for("radix-ui")] = true;
        }
        return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
      });
      Node2.displayName = `Primitive.${node}`;
      return { ...primitive, [node]: Node2 };
    }, {});
    __name2(dispatchDiscreteCustomEvent, "dispatchDiscreteCustomEvent");
  }
});
function useCallbackRef(callback) {
  const callbackRef = React6.useRef(callback);
  React6.useEffect(() => {
    callbackRef.current = callback;
  });
  return React6.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
__name(useCallbackRef, "useCallbackRef");
var React6;
var init_dist9 = __esm({
  "../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React6 = __toESM(require_react(), 1);
    __name2(useCallbackRef, "useCallbackRef");
  }
});
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React7.useEffect(() => {
    const handleKeyDown = /* @__PURE__ */ __name2((event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    }, "handleKeyDown");
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
__name(useEscapeKeydown, "useEscapeKeydown");
var React7;
var init_dist10 = __esm({
  "../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React7 = __toESM(require_react(), 1);
    init_dist9();
    __name2(useEscapeKeydown, "useEscapeKeydown");
  }
});
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React8.useRef(false);
  const handleClickRef = React8.useRef(() => {
  });
  React8.useEffect(() => {
    const handlePointerDown = /* @__PURE__ */ __name2((event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = /* @__PURE__ */ __name2(function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        }, "handleAndDispatchPointerDownOutsideEvent2");
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    }, "handlePointerDown");
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
__name(usePointerDownOutside, "usePointerDownOutside");
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React8.useRef(false);
  React8.useEffect(() => {
    const handleFocus = /* @__PURE__ */ __name2((event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    }, "handleFocus");
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
__name(useFocusOutside, "useFocusOutside");
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
__name(dispatchUpdate, "dispatchUpdate");
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
__name(handleAndDispatchCustomEvent, "handleAndDispatchCustomEvent");
var React8;
var import_jsx_runtime7;
var DISMISSABLE_LAYER_NAME;
var CONTEXT_UPDATE;
var POINTER_DOWN_OUTSIDE;
var FOCUS_OUTSIDE;
var originalBodyPointerEvents;
var DismissableLayerContext;
var DismissableLayer;
var BRANCH_NAME;
var DismissableLayerBranch;
var Root;
var Branch;
var init_dist11 = __esm({
  "../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React8 = __toESM(require_react(), 1);
    init_dist3();
    init_dist8();
    init_dist4();
    init_dist9();
    init_dist10();
    import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
    DISMISSABLE_LAYER_NAME = "DismissableLayer";
    CONTEXT_UPDATE = "dismissableLayer.update";
    POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
    FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
    DismissableLayerContext = React8.createContext({
      layers: /* @__PURE__ */ new Set(),
      layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
      branches: /* @__PURE__ */ new Set()
    });
    DismissableLayer = React8.forwardRef(
      (props, forwardedRef) => {
        const {
          disableOutsidePointerEvents = false,
          onEscapeKeyDown,
          onPointerDownOutside,
          onFocusOutside,
          onInteractOutside,
          onDismiss,
          ...layerProps
        } = props;
        const context = React8.useContext(DismissableLayerContext);
        const [node, setNode] = React8.useState(null);
        const ownerDocument = node?.ownerDocument ?? globalThis?.document;
        const [, force] = React8.useState({});
        const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
        const layers = Array.from(context.layers);
        const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
        const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
        const index = node ? layers.indexOf(node) : -1;
        const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
        const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
        const pointerDownOutside = usePointerDownOutside((event) => {
          const target = event.target;
          const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
          if (!isPointerEventsEnabled || isPointerDownOnBranch)
            return;
          onPointerDownOutside?.(event);
          onInteractOutside?.(event);
          if (!event.defaultPrevented)
            onDismiss?.();
        }, ownerDocument);
        const focusOutside = useFocusOutside((event) => {
          const target = event.target;
          const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
          if (isFocusInBranch)
            return;
          onFocusOutside?.(event);
          onInteractOutside?.(event);
          if (!event.defaultPrevented)
            onDismiss?.();
        }, ownerDocument);
        useEscapeKeydown((event) => {
          const isHighestLayer = index === context.layers.size - 1;
          if (!isHighestLayer)
            return;
          onEscapeKeyDown?.(event);
          if (!event.defaultPrevented && onDismiss) {
            event.preventDefault();
            onDismiss();
          }
        }, ownerDocument);
        React8.useEffect(() => {
          if (!node)
            return;
          if (disableOutsidePointerEvents) {
            if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
              originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
              ownerDocument.body.style.pointerEvents = "none";
            }
            context.layersWithOutsidePointerEventsDisabled.add(node);
          }
          context.layers.add(node);
          dispatchUpdate();
          return () => {
            if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
              ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
            }
          };
        }, [node, ownerDocument, disableOutsidePointerEvents, context]);
        React8.useEffect(() => {
          return () => {
            if (!node)
              return;
            context.layers.delete(node);
            context.layersWithOutsidePointerEventsDisabled.delete(node);
            dispatchUpdate();
          };
        }, [node, context]);
        React8.useEffect(() => {
          const handleUpdate = /* @__PURE__ */ __name2(() => force({}), "handleUpdate");
          document.addEventListener(CONTEXT_UPDATE, handleUpdate);
          return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
        }, []);
        return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
          Primitive.div,
          {
            ...layerProps,
            ref: composedRefs,
            style: {
              pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
              ...props.style
            },
            onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
            onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
            onPointerDownCapture: composeEventHandlers(
              props.onPointerDownCapture,
              pointerDownOutside.onPointerDownCapture
            )
          }
        );
      }
    );
    DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
    BRANCH_NAME = "DismissableLayerBranch";
    DismissableLayerBranch = React8.forwardRef((props, forwardedRef) => {
      const context = React8.useContext(DismissableLayerContext);
      const ref = React8.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      React8.useEffect(() => {
        const node = ref.current;
        if (node) {
          context.branches.add(node);
          return () => {
            context.branches.delete(node);
          };
        }
      }, [context.branches]);
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Primitive.div, { ...props, ref: composedRefs });
    });
    DismissableLayerBranch.displayName = BRANCH_NAME;
    __name2(usePointerDownOutside, "usePointerDownOutside");
    __name2(useFocusOutside, "useFocusOutside");
    __name2(dispatchUpdate, "dispatchUpdate");
    __name2(handleAndDispatchCustomEvent, "handleAndDispatchCustomEvent");
    Root = DismissableLayer;
    Branch = DismissableLayerBranch;
  }
});
var React9;
var useLayoutEffect2;
var init_dist12 = __esm({
  "../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React9 = __toESM(require_react(), 1);
    useLayoutEffect2 = globalThis?.document ? React9.useLayoutEffect : () => {
    };
  }
});
var React10;
var import_react_dom2;
var import_jsx_runtime8;
var PORTAL_NAME;
var Portal;
var init_dist13 = __esm({
  "../node_modules/@radix-ui/react-portal/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React10 = __toESM(require_react(), 1);
    import_react_dom2 = __toESM(require_react_dom(), 1);
    init_dist8();
    init_dist12();
    import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
    PORTAL_NAME = "Portal";
    Portal = React10.forwardRef((props, forwardedRef) => {
      const { container: containerProp, ...portalProps } = props;
      const [mounted, setMounted] = React10.useState(false);
      useLayoutEffect2(() => setMounted(true), []);
      const container = containerProp || mounted && globalThis?.document?.body;
      return container ? import_react_dom2.default.createPortal(/* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
    });
    Portal.displayName = PORTAL_NAME;
  }
});
function useStateMachine(initialState, machine) {
  return React11.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
__name(useStateMachine, "useStateMachine");
function usePresence(present) {
  const [node, setNode] = React23.useState();
  const stylesRef = React23.useRef(null);
  const prevPresentRef = React23.useRef(present);
  const prevAnimationNameRef = React23.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React23.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = /* @__PURE__ */ __name2((event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      }, "handleAnimationEnd");
      const handleAnimationStart = /* @__PURE__ */ __name2((event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      }, "handleAnimationStart");
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React23.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
__name(usePresence, "usePresence");
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
__name(getAnimationName, "getAnimationName");
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
__name(getElementRef2, "getElementRef2");
var React23;
var React11;
var Presence;
var init_dist14 = __esm({
  "../node_modules/@radix-ui/react-presence/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React23 = __toESM(require_react(), 1);
    init_dist4();
    init_dist12();
    React11 = __toESM(require_react(), 1);
    __name2(useStateMachine, "useStateMachine");
    Presence = /* @__PURE__ */ __name2((props) => {
      const { present, children } = props;
      const presence = usePresence(present);
      const child = typeof children === "function" ? children({ present: presence.isPresent }) : React23.Children.only(children);
      const ref = useComposedRefs(presence.ref, getElementRef2(child));
      const forceMount = typeof children === "function";
      return forceMount || presence.isPresent ? React23.cloneElement(child, { ref }) : null;
    }, "Presence");
    Presence.displayName = "Presence";
    __name2(usePresence, "usePresence");
    __name2(getAnimationName, "getAnimationName");
    __name2(getElementRef2, "getElementRef");
  }
});
function useControllableState({
  prop,
  defaultProp,
  onChange = /* @__PURE__ */ __name2(() => {
  }, "onChange"),
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React12.useRef(prop !== void 0);
    React12.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from27 = wasControlled ? "controlled" : "uncontrolled";
        const to3 = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from27} to ${to3}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React12.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
__name(useControllableState, "useControllableState");
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React12.useState(defaultProp);
  const prevValueRef = React12.useRef(value);
  const onChangeRef = React12.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React12.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
__name(useUncontrolledState, "useUncontrolledState");
function isFunction(value) {
  return typeof value === "function";
}
__name(isFunction, "isFunction");
var React12;
var React24;
var useInsertionEffect;
var SYNC_STATE;
var init_dist15 = __esm({
  "../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React12 = __toESM(require_react(), 1);
    init_dist12();
    React24 = __toESM(require_react(), 1);
    useInsertionEffect = React12[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
    __name2(useControllableState, "useControllableState");
    __name2(useUncontrolledState, "useUncontrolledState");
    __name2(isFunction, "isFunction");
    SYNC_STATE = Symbol("RADIX:SYNC_STATE");
  }
});
var React13;
var import_jsx_runtime9;
var VISUALLY_HIDDEN_STYLES;
var NAME;
var VisuallyHidden;
var init_dist16 = __esm({
  "../node_modules/@radix-ui/react-visually-hidden/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React13 = __toESM(require_react(), 1);
    init_dist8();
    import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
    VISUALLY_HIDDEN_STYLES = Object.freeze({
      // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    });
    NAME = "VisuallyHidden";
    VisuallyHidden = React13.forwardRef(
      (props, forwardedRef) => {
        return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          Primitive.span,
          {
            ...props,
            ref: forwardedRef,
            style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
          }
        );
      }
    );
    VisuallyHidden.displayName = NAME;
  }
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent)
      textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText)
            textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
__name(getAnnounceTextContent, "getAnnounceTextContent");
function handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler)
    currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
__name(handleAndDispatchCustomEvent2, "handleAndDispatchCustomEvent2");
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
__name(useNextFrame, "useNextFrame");
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
__name(isHTMLElement, "isHTMLElement");
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
__name(getTabbableCandidates, "getTabbableCandidates");
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement)
      return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
__name(focusFirst, "focusFirst");
var React14;
var ReactDOM3;
var import_jsx_runtime10;
var PROVIDER_NAME;
var Collection;
var useCollection;
var createCollectionScope;
var createToastContext;
var createToastScope;
var ToastProviderProvider;
var useToastProviderContext;
var ToastProvider;
var VIEWPORT_NAME;
var VIEWPORT_DEFAULT_HOTKEY;
var VIEWPORT_PAUSE;
var VIEWPORT_RESUME;
var ToastViewport;
var FOCUS_PROXY_NAME;
var FocusProxy;
var TOAST_NAME;
var TOAST_SWIPE_START;
var TOAST_SWIPE_MOVE;
var TOAST_SWIPE_CANCEL;
var TOAST_SWIPE_END;
var Toast;
var ToastInteractiveProvider;
var useToastInteractiveContext;
var ToastImpl;
var ToastAnnounce;
var TITLE_NAME;
var ToastTitle;
var DESCRIPTION_NAME;
var ToastDescription;
var ACTION_NAME;
var ToastAction;
var CLOSE_NAME;
var ToastClose;
var ToastAnnounceExclude;
var isDeltaInDirection;
var Provider;
var Viewport;
var init_dist17 = __esm({
  "../node_modules/@radix-ui/react-toast/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React14 = __toESM(require_react(), 1);
    ReactDOM3 = __toESM(require_react_dom(), 1);
    init_dist3();
    init_dist4();
    init_dist7();
    init_dist5();
    init_dist11();
    init_dist13();
    init_dist14();
    init_dist8();
    init_dist9();
    init_dist15();
    init_dist12();
    init_dist16();
    import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
    PROVIDER_NAME = "ToastProvider";
    [Collection, useCollection, createCollectionScope] = createCollection("Toast");
    [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
    [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
    ToastProvider = /* @__PURE__ */ __name2((props) => {
      const {
        __scopeToast,
        label = "Notification",
        duration = 5e3,
        swipeDirection = "right",
        swipeThreshold = 50,
        children
      } = props;
      const [viewport, setViewport] = React14.useState(null);
      const [toastCount, setToastCount] = React14.useState(0);
      const isFocusedToastEscapeKeyDownRef = React14.useRef(false);
      const isClosePausedRef = React14.useRef(false);
      if (!label.trim()) {
        console.error(
          `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
        );
      }
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
        ToastProviderProvider,
        {
          scope: __scopeToast,
          label,
          duration,
          swipeDirection,
          swipeThreshold,
          toastCount,
          viewport,
          onViewportChange: setViewport,
          onToastAdd: React14.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
          onToastRemove: React14.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
          isFocusedToastEscapeKeyDownRef,
          isClosePausedRef,
          children
        }
      ) });
    }, "ToastProvider");
    ToastProvider.displayName = PROVIDER_NAME;
    VIEWPORT_NAME = "ToastViewport";
    VIEWPORT_DEFAULT_HOTKEY = ["F8"];
    VIEWPORT_PAUSE = "toast.viewportPause";
    VIEWPORT_RESUME = "toast.viewportResume";
    ToastViewport = React14.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeToast,
          hotkey = VIEWPORT_DEFAULT_HOTKEY,
          label = "Notifications ({hotkey})",
          ...viewportProps
        } = props;
        const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
        const getItems = useCollection(__scopeToast);
        const wrapperRef = React14.useRef(null);
        const headFocusProxyRef = React14.useRef(null);
        const tailFocusProxyRef = React14.useRef(null);
        const ref = React14.useRef(null);
        const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
        const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
        const hasToasts = context.toastCount > 0;
        React14.useEffect(() => {
          const handleKeyDown = /* @__PURE__ */ __name2((event) => {
            const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
            if (isHotkeyPressed)
              ref.current?.focus();
          }, "handleKeyDown");
          document.addEventListener("keydown", handleKeyDown);
          return () => document.removeEventListener("keydown", handleKeyDown);
        }, [hotkey]);
        React14.useEffect(() => {
          const wrapper = wrapperRef.current;
          const viewport = ref.current;
          if (hasToasts && wrapper && viewport) {
            const handlePause = /* @__PURE__ */ __name2(() => {
              if (!context.isClosePausedRef.current) {
                const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
                viewport.dispatchEvent(pauseEvent);
                context.isClosePausedRef.current = true;
              }
            }, "handlePause");
            const handleResume = /* @__PURE__ */ __name2(() => {
              if (context.isClosePausedRef.current) {
                const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
                viewport.dispatchEvent(resumeEvent);
                context.isClosePausedRef.current = false;
              }
            }, "handleResume");
            const handleFocusOutResume = /* @__PURE__ */ __name2((event) => {
              const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
              if (isFocusMovingOutside)
                handleResume();
            }, "handleFocusOutResume");
            const handlePointerLeaveResume = /* @__PURE__ */ __name2(() => {
              const isFocusInside = wrapper.contains(document.activeElement);
              if (!isFocusInside)
                handleResume();
            }, "handlePointerLeaveResume");
            wrapper.addEventListener("focusin", handlePause);
            wrapper.addEventListener("focusout", handleFocusOutResume);
            wrapper.addEventListener("pointermove", handlePause);
            wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
            window.addEventListener("blur", handlePause);
            window.addEventListener("focus", handleResume);
            return () => {
              wrapper.removeEventListener("focusin", handlePause);
              wrapper.removeEventListener("focusout", handleFocusOutResume);
              wrapper.removeEventListener("pointermove", handlePause);
              wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
              window.removeEventListener("blur", handlePause);
              window.removeEventListener("focus", handleResume);
            };
          }
        }, [hasToasts, context.isClosePausedRef]);
        const getSortedTabbableCandidates = React14.useCallback(
          ({ tabbingDirection }) => {
            const toastItems = getItems();
            const tabbableCandidates = toastItems.map((toastItem) => {
              const toastNode = toastItem.ref.current;
              const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
              return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
            });
            return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
          },
          [getItems]
        );
        React14.useEffect(() => {
          const viewport = ref.current;
          if (viewport) {
            const handleKeyDown = /* @__PURE__ */ __name2((event) => {
              const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
              const isTabKey = event.key === "Tab" && !isMetaKey;
              if (isTabKey) {
                const focusedElement = document.activeElement;
                const isTabbingBackwards = event.shiftKey;
                const targetIsViewport = event.target === viewport;
                if (targetIsViewport && isTabbingBackwards) {
                  headFocusProxyRef.current?.focus();
                  return;
                }
                const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
                const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
                const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
                if (focusFirst(sortedCandidates.slice(index + 1))) {
                  event.preventDefault();
                } else {
                  isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
                }
              }
            }, "handleKeyDown");
            viewport.addEventListener("keydown", handleKeyDown);
            return () => viewport.removeEventListener("keydown", handleKeyDown);
          }
        }, [getItems, getSortedTabbableCandidates]);
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
          Branch,
          {
            ref: wrapperRef,
            role: "region",
            "aria-label": label.replace("{hotkey}", hotkeyLabel),
            tabIndex: -1,
            style: { pointerEvents: hasToasts ? void 0 : "none" },
            children: [
              hasToasts && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
                FocusProxy,
                {
                  ref: headFocusProxyRef,
                  onFocusFromOutsideViewport: () => {
                    const tabbableCandidates = getSortedTabbableCandidates({
                      tabbingDirection: "forwards"
                    });
                    focusFirst(tabbableCandidates);
                  }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
              hasToasts && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
                FocusProxy,
                {
                  ref: tailFocusProxyRef,
                  onFocusFromOutsideViewport: () => {
                    const tabbableCandidates = getSortedTabbableCandidates({
                      tabbingDirection: "backwards"
                    });
                    focusFirst(tabbableCandidates);
                  }
                }
              )
            ]
          }
        );
      }
    );
    ToastViewport.displayName = VIEWPORT_NAME;
    FOCUS_PROXY_NAME = "ToastFocusProxy";
    FocusProxy = React14.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
        const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
          VisuallyHidden,
          {
            "aria-hidden": true,
            tabIndex: 0,
            ...proxyProps,
            ref: forwardedRef,
            style: { position: "fixed" },
            onFocus: (event) => {
              const prevFocusedElement = event.relatedTarget;
              const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);
              if (isFocusFromOutsideViewport)
                onFocusFromOutsideViewport();
            }
          }
        );
      }
    );
    FocusProxy.displayName = FOCUS_PROXY_NAME;
    TOAST_NAME = "Toast";
    TOAST_SWIPE_START = "toast.swipeStart";
    TOAST_SWIPE_MOVE = "toast.swipeMove";
    TOAST_SWIPE_CANCEL = "toast.swipeCancel";
    TOAST_SWIPE_END = "toast.swipeEnd";
    Toast = React14.forwardRef(
      (props, forwardedRef) => {
        const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
        const [open, setOpen] = useControllableState({
          prop: openProp,
          defaultProp: defaultOpen ?? true,
          onChange: onOpenChange,
          caller: TOAST_NAME
        });
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Presence, { present: forceMount || open, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
          ToastImpl,
          {
            open,
            ...toastProps,
            ref: forwardedRef,
            onClose: () => setOpen(false),
            onPause: useCallbackRef(props.onPause),
            onResume: useCallbackRef(props.onResume),
            onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
              event.currentTarget.setAttribute("data-swipe", "start");
            }),
            onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
              const { x: x2, y: y2 } = event.detail.delta;
              event.currentTarget.setAttribute("data-swipe", "move");
              event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x2}px`);
              event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
            }),
            onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
              event.currentTarget.setAttribute("data-swipe", "cancel");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
            }),
            onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
              const { x: x2, y: y2 } = event.detail.delta;
              event.currentTarget.setAttribute("data-swipe", "end");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
              event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
              event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x2}px`);
              event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
              setOpen(false);
            })
          }
        ) });
      }
    );
    Toast.displayName = TOAST_NAME;
    [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
      onClose() {
      }
    });
    ToastImpl = React14.forwardRef(
      (props, forwardedRef) => {
        const {
          __scopeToast,
          type: type6 = "foreground",
          duration: durationProp,
          open,
          onClose,
          onEscapeKeyDown,
          onPause,
          onResume,
          onSwipeStart,
          onSwipeMove,
          onSwipeCancel,
          onSwipeEnd,
          ...toastProps
        } = props;
        const context = useToastProviderContext(TOAST_NAME, __scopeToast);
        const [node, setNode] = React14.useState(null);
        const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
        const pointerStartRef = React14.useRef(null);
        const swipeDeltaRef = React14.useRef(null);
        const duration = durationProp || context.duration;
        const closeTimerStartTimeRef = React14.useRef(0);
        const closeTimerRemainingTimeRef = React14.useRef(duration);
        const closeTimerRef = React14.useRef(0);
        const { onToastAdd, onToastRemove } = context;
        const handleClose = useCallbackRef(() => {
          const isFocusInToast = node?.contains(document.activeElement);
          if (isFocusInToast)
            context.viewport?.focus();
          onClose();
        });
        const startTimer = React14.useCallback(
          (duration2) => {
            if (!duration2 || duration2 === Infinity)
              return;
            window.clearTimeout(closeTimerRef.current);
            closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
            closeTimerRef.current = window.setTimeout(handleClose, duration2);
          },
          [handleClose]
        );
        React14.useEffect(() => {
          const viewport = context.viewport;
          if (viewport) {
            const handleResume = /* @__PURE__ */ __name2(() => {
              startTimer(closeTimerRemainingTimeRef.current);
              onResume?.();
            }, "handleResume");
            const handlePause = /* @__PURE__ */ __name2(() => {
              const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
              closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
              window.clearTimeout(closeTimerRef.current);
              onPause?.();
            }, "handlePause");
            viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
            viewport.addEventListener(VIEWPORT_RESUME, handleResume);
            return () => {
              viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
              viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
            };
          }
        }, [context.viewport, duration, onPause, onResume, startTimer]);
        React14.useEffect(() => {
          if (open && !context.isClosePausedRef.current)
            startTimer(duration);
        }, [open, duration, context.isClosePausedRef, startTimer]);
        React14.useEffect(() => {
          onToastAdd();
          return () => onToastRemove();
        }, [onToastAdd, onToastRemove]);
        const announceTextContent = React14.useMemo(() => {
          return node ? getAnnounceTextContent(node) : null;
        }, [node]);
        if (!context.viewport)
          return null;
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
          announceTextContent && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            ToastAnnounce,
            {
              __scopeToast,
              role: "status",
              "aria-live": type6 === "foreground" ? "assertive" : "polite",
              "aria-atomic": true,
              children: announceTextContent
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM3.createPortal(
            /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
              Root,
              {
                asChild: true,
                onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
                  if (!context.isFocusedToastEscapeKeyDownRef.current)
                    handleClose();
                  context.isFocusedToastEscapeKeyDownRef.current = false;
                }),
                children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
                  Primitive.li,
                  {
                    role: "status",
                    "aria-live": "off",
                    "aria-atomic": true,
                    tabIndex: 0,
                    "data-state": open ? "open" : "closed",
                    "data-swipe-direction": context.swipeDirection,
                    ...toastProps,
                    ref: composedRefs,
                    style: { userSelect: "none", touchAction: "none", ...props.style },
                    onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                      if (event.key !== "Escape")
                        return;
                      onEscapeKeyDown?.(event.nativeEvent);
                      if (!event.nativeEvent.defaultPrevented) {
                        context.isFocusedToastEscapeKeyDownRef.current = true;
                        handleClose();
                      }
                    }),
                    onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                      if (event.button !== 0)
                        return;
                      pointerStartRef.current = { x: event.clientX, y: event.clientY };
                    }),
                    onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                      if (!pointerStartRef.current)
                        return;
                      const x2 = event.clientX - pointerStartRef.current.x;
                      const y2 = event.clientY - pointerStartRef.current.y;
                      const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                      const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                      const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                      const clampedX = isHorizontalSwipe ? clamp2(0, x2) : 0;
                      const clampedY = !isHorizontalSwipe ? clamp2(0, y2) : 0;
                      const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                      const delta = { x: clampedX, y: clampedY };
                      const eventDetail = { originalEvent: event, delta };
                      if (hasSwipeMoveStarted) {
                        swipeDeltaRef.current = delta;
                        handleAndDispatchCustomEvent2(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                          discrete: false
                        });
                      } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                        swipeDeltaRef.current = delta;
                        handleAndDispatchCustomEvent2(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                          discrete: false
                        });
                        event.target.setPointerCapture(event.pointerId);
                      } else if (Math.abs(x2) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                        pointerStartRef.current = null;
                      }
                    }),
                    onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                      const delta = swipeDeltaRef.current;
                      const target = event.target;
                      if (target.hasPointerCapture(event.pointerId)) {
                        target.releasePointerCapture(event.pointerId);
                      }
                      swipeDeltaRef.current = null;
                      pointerStartRef.current = null;
                      if (delta) {
                        const toast = event.currentTarget;
                        const eventDetail = { originalEvent: event, delta };
                        if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                          handleAndDispatchCustomEvent2(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                            discrete: true
                          });
                        } else {
                          handleAndDispatchCustomEvent2(
                            TOAST_SWIPE_CANCEL,
                            onSwipeCancel,
                            eventDetail,
                            {
                              discrete: true
                            }
                          );
                        }
                        toast.addEventListener("click", (event2) => event2.preventDefault(), {
                          once: true
                        });
                      }
                    })
                  }
                )
              }
            ) }),
            context.viewport
          ) })
        ] });
      }
    );
    ToastAnnounce = /* @__PURE__ */ __name2((props) => {
      const { __scopeToast, children, ...announceProps } = props;
      const context = useToastProviderContext(TOAST_NAME, __scopeToast);
      const [renderAnnounceText, setRenderAnnounceText] = React14.useState(false);
      const [isAnnounced, setIsAnnounced] = React14.useState(false);
      useNextFrame(() => setRenderAnnounceText(true));
      React14.useEffect(() => {
        const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
        return () => window.clearTimeout(timer);
      }, []);
      return isAnnounced ? null : /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Portal, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
        context.label,
        " ",
        children
      ] }) }) });
    }, "ToastAnnounce");
    TITLE_NAME = "ToastTitle";
    ToastTitle = React14.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, ...titleProps } = props;
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Primitive.div, { ...titleProps, ref: forwardedRef });
      }
    );
    ToastTitle.displayName = TITLE_NAME;
    DESCRIPTION_NAME = "ToastDescription";
    ToastDescription = React14.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, ...descriptionProps } = props;
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Primitive.div, { ...descriptionProps, ref: forwardedRef });
      }
    );
    ToastDescription.displayName = DESCRIPTION_NAME;
    ACTION_NAME = "ToastAction";
    ToastAction = React14.forwardRef(
      (props, forwardedRef) => {
        const { altText, ...actionProps } = props;
        if (!altText.trim()) {
          console.error(
            `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
          );
          return null;
        }
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ToastClose, { ...actionProps, ref: forwardedRef }) });
      }
    );
    ToastAction.displayName = ACTION_NAME;
    CLOSE_NAME = "ToastClose";
    ToastClose = React14.forwardRef(
      (props, forwardedRef) => {
        const { __scopeToast, ...closeProps } = props;
        const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
        return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
          Primitive.button,
          {
            type: "button",
            ...closeProps,
            ref: forwardedRef,
            onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
          }
        ) });
      }
    );
    ToastClose.displayName = CLOSE_NAME;
    ToastAnnounceExclude = React14.forwardRef((props, forwardedRef) => {
      const { __scopeToast, altText, ...announceExcludeProps } = props;
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
        Primitive.div,
        {
          "data-radix-toast-announce-exclude": "",
          "data-radix-toast-announce-alt": altText || void 0,
          ...announceExcludeProps,
          ref: forwardedRef
        }
      );
    });
    __name2(getAnnounceTextContent, "getAnnounceTextContent");
    __name2(handleAndDispatchCustomEvent2, "handleAndDispatchCustomEvent");
    isDeltaInDirection = /* @__PURE__ */ __name2((delta, direction, threshold = 0) => {
      const deltaX = Math.abs(delta.x);
      const deltaY = Math.abs(delta.y);
      const isDeltaX = deltaX > deltaY;
      if (direction === "left" || direction === "right") {
        return isDeltaX && deltaX > threshold;
      } else {
        return !isDeltaX && deltaY > threshold;
      }
    }, "isDeltaInDirection");
    __name2(useNextFrame, "useNextFrame");
    __name2(isHTMLElement, "isHTMLElement");
    __name2(getTabbableCandidates, "getTabbableCandidates");
    __name2(focusFirst, "focusFirst");
    Provider = ToastProvider;
    Viewport = ToastViewport;
  }
});
var require_toggle_selection = __commonJS({
  "../node_modules/toggle-selection/index.js"(exports, module) {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection.rangeCount; i2++) {
        ranges.push(selection.getRangeAt(i2));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});
var require_copy_to_clipboard = __commonJS({
  "../node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format9(message) {
      var copyKey = (/mac os x/i.test("Cloudflare-Workers") ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    __name(format9, "format9");
    __name2(format9, "format");
    function copy2(text, options2) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options2) {
        options2 = {};
      }
      debug = options2.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options2.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format10 = clipboardToIE11Formatting[options2.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format10, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options2.format, text);
            }
          }
          if (options2.onCopy) {
            e2.preventDefault();
            options2.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options2.format || "text", text);
          options2.onCopy && options2.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format9("message" in options2 ? options2.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    __name(copy2, "copy2");
    __name2(copy2, "copy");
    module.exports = copy2;
  }
});
var import_react7;
var LayoutGroupContext;
var init_LayoutGroupContext = __esm({
  "../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react7 = __toESM(require_react(), 1);
    LayoutGroupContext = (0, import_react7.createContext)({});
  }
});
function useConstant(init2) {
  const ref = (0, import_react8.useRef)(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}
__name(useConstant, "useConstant");
var import_react8;
var init_use_constant = __esm({
  "../node_modules/framer-motion/dist/es/utils/use-constant.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react8 = __toESM(require_react(), 1);
    __name2(useConstant, "useConstant");
  }
});
var import_react9;
var PresenceContext;
var init_PresenceContext = __esm({
  "../node_modules/framer-motion/dist/es/context/PresenceContext.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react9 = __toESM(require_react(), 1);
    PresenceContext = (0, import_react9.createContext)(null);
  }
});
var import_react10;
var MotionConfigContext;
var init_MotionConfigContext = __esm({
  "../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react10 = __toESM(require_react(), 1);
    MotionConfigContext = (0, import_react10.createContext)({
      transformPagePoint: (p2) => p2,
      isStatic: false,
      reducedMotion: "never"
    });
  }
});
function PopChild({ children, isPresent }) {
  const id3 = (0, import_react11.useId)();
  const ref = (0, import_react11.useRef)(null);
  const size3 = (0, import_react11.useRef)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  const { nonce } = (0, import_react11.useContext)(MotionConfigContext);
  (0, import_react11.useInsertionEffect)(() => {
    const { width, height, top, left } = size3.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id3;
    const style = document.createElement("style");
    if (nonce)
      style.nonce = nonce;
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return (0, import_jsx_runtime11.jsx)(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size3, children: React15.cloneElement(children, { ref }) });
}
__name(PopChild, "PopChild");
var import_jsx_runtime11;
var React15;
var import_react11;
var PopChildMeasure;
var init_PopChild = __esm({
  "../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
    React15 = __toESM(require_react(), 1);
    import_react11 = __toESM(require_react(), 1);
    init_MotionConfigContext();
    PopChildMeasure = /* @__PURE__ */ __name(class extends React15.Component {
      getSnapshotBeforeUpdate(prevProps) {
        const element = this.props.childRef.current;
        if (element && prevProps.isPresent && !this.props.isPresent) {
          const size3 = this.props.sizeRef.current;
          size3.height = element.offsetHeight || 0;
          size3.width = element.offsetWidth || 0;
          size3.top = element.offsetTop;
          size3.left = element.offsetLeft;
        }
        return null;
      }
      /**
       * Required with getSnapshotBeforeUpdate to stop React complaining.
       */
      componentDidUpdate() {
      }
      render() {
        return this.props.children;
      }
    }, "PopChildMeasure");
    __name2(PopChildMeasure, "PopChildMeasure");
    __name2(PopChild, "PopChild");
  }
});
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
__name(newChildrenMap, "newChildrenMap");
var import_jsx_runtime12;
var React16;
var import_react12;
var PresenceChild;
var init_PresenceChild = __esm({
  "../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
    React16 = __toESM(require_react(), 1);
    import_react12 = __toESM(require_react(), 1);
    init_PresenceContext();
    init_use_constant();
    init_PopChild();
    PresenceChild = /* @__PURE__ */ __name2(({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
      const presenceChildren = useConstant(newChildrenMap);
      const id3 = (0, import_react12.useId)();
      const memoizedOnExitComplete = (0, import_react12.useCallback)((childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      }, [presenceChildren, onExitComplete]);
      const context = (0, import_react12.useMemo)(
        () => ({
          id: id3,
          initial,
          isPresent,
          custom,
          onExitComplete: memoizedOnExitComplete,
          register: (childId) => {
            presenceChildren.set(childId, false);
            return () => presenceChildren.delete(childId);
          }
        }),
        /**
         * If the presence of a child affects the layout of the components around it,
         * we want to make a new context value to ensure they get re-rendered
         * so they can detect that layout change.
         */
        presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]
      );
      (0, import_react12.useMemo)(() => {
        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
      }, [isPresent]);
      React16.useEffect(() => {
        !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
      }, [isPresent]);
      if (mode === "popLayout") {
        children = (0, import_jsx_runtime12.jsx)(PopChild, { isPresent, children });
      }
      return (0, import_jsx_runtime12.jsx)(PresenceContext.Provider, { value: context, children });
    }, "PresenceChild");
    __name2(newChildrenMap, "newChildrenMap");
  }
});
function usePresence2(subscribe = true) {
  const context = (0, import_react13.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id3 = (0, import_react13.useId)();
  (0, import_react13.useEffect)(() => {
    if (subscribe)
      register(id3);
  }, [subscribe]);
  const safeToRemove = (0, import_react13.useCallback)(() => subscribe && onExitComplete && onExitComplete(id3), [id3, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
__name(usePresence2, "usePresence2");
var import_react13;
var init_use_presence = __esm({
  "../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react13 = __toESM(require_react(), 1);
    init_PresenceContext();
    __name2(usePresence2, "usePresence");
  }
});
function onlyElements(children) {
  const filtered = [];
  import_react14.Children.forEach(children, (child) => {
    if ((0, import_react14.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}
__name(onlyElements, "onlyElements");
var import_react14;
var getChildKey;
var init_utils4 = __esm({
  "../node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react14 = __toESM(require_react(), 1);
    getChildKey = /* @__PURE__ */ __name2((child) => child.key || "", "getChildKey");
    __name2(onlyElements, "onlyElements");
  }
});
var isBrowser2;
var init_is_browser = __esm({
  "../node_modules/framer-motion/dist/es/utils/is-browser.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isBrowser2 = typeof window !== "undefined";
  }
});
var import_react15;
var useIsomorphicLayoutEffect;
var init_use_isomorphic_effect = __esm({
  "../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react15 = __toESM(require_react(), 1);
    init_is_browser();
    useIsomorphicLayoutEffect = isBrowser2 ? import_react15.useLayoutEffect : import_react15.useEffect;
  }
});
var import_jsx_runtime13;
var import_react16;
var AnimatePresence;
var init_AnimatePresence = __esm({
  "../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
    import_react16 = __toESM(require_react(), 1);
    init_LayoutGroupContext();
    init_use_constant();
    init_PresenceChild();
    init_use_presence();
    init_utils4();
    init_use_isomorphic_effect();
    AnimatePresence = /* @__PURE__ */ __name2(({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false }) => {
      const [isParentPresent, safeToRemove] = usePresence2(propagate);
      const presentChildren = (0, import_react16.useMemo)(() => onlyElements(children), [children]);
      const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
      const isInitialRender = (0, import_react16.useRef)(true);
      const pendingPresentChildren = (0, import_react16.useRef)(presentChildren);
      const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
      const [diffedChildren, setDiffedChildren] = (0, import_react16.useState)(presentChildren);
      const [renderedChildren, setRenderedChildren] = (0, import_react16.useState)(presentChildren);
      useIsomorphicLayoutEffect(() => {
        isInitialRender.current = false;
        pendingPresentChildren.current = presentChildren;
        for (let i2 = 0; i2 < renderedChildren.length; i2++) {
          const key = getChildKey(renderedChildren[i2]);
          if (!presentKeys.includes(key)) {
            if (exitComplete.get(key) !== true) {
              exitComplete.set(key, false);
            }
          } else {
            exitComplete.delete(key);
          }
        }
      }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
      const exitingChildren = [];
      if (presentChildren !== diffedChildren) {
        let nextChildren = [...presentChildren];
        for (let i2 = 0; i2 < renderedChildren.length; i2++) {
          const child = renderedChildren[i2];
          const key = getChildKey(child);
          if (!presentKeys.includes(key)) {
            nextChildren.splice(i2, 0, child);
            exitingChildren.push(child);
          }
        }
        if (mode === "wait" && exitingChildren.length) {
          nextChildren = exitingChildren;
        }
        setRenderedChildren(onlyElements(nextChildren));
        setDiffedChildren(presentChildren);
        return;
      }
      if (mode === "wait" && renderedChildren.length > 1) {
        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
      }
      const { forceRender } = (0, import_react16.useContext)(LayoutGroupContext);
      return (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children: renderedChildren.map((child) => {
        const key = getChildKey(child);
        const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
        const onExit = /* @__PURE__ */ __name2(() => {
          if (exitComplete.has(key)) {
            exitComplete.set(key, true);
          } else {
            return;
          }
          let isEveryExitComplete = true;
          exitComplete.forEach((isExitComplete) => {
            if (!isExitComplete)
              isEveryExitComplete = false;
          });
          if (isEveryExitComplete) {
            forceRender === null || forceRender === void 0 ? void 0 : forceRender();
            setRenderedChildren(pendingPresentChildren.current);
            propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());
            onExitComplete && onExitComplete();
          }
        }, "onExit");
        return (0, import_jsx_runtime13.jsx)(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom: isPresent ? void 0 : custom, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, children: child }, key);
      }) });
    }, "AnimatePresence");
  }
});
var noop;
var init_noop = __esm({
  "../node_modules/motion-utils/dist/es/noop.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    noop = /* @__PURE__ */ __name2((any) => any, "noop");
  }
});
var warning;
var invariant;
var init_errors3 = __esm({
  "../node_modules/motion-utils/dist/es/errors.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_noop();
    warning = noop;
    invariant = noop;
    if (true) {
      warning = /* @__PURE__ */ __name2((check, message) => {
        if (!check && typeof console !== "undefined") {
          console.warn(message);
        }
      }, "warning");
      invariant = /* @__PURE__ */ __name2((check, message) => {
        if (!check) {
          throw new Error(message);
        }
      }, "invariant");
    }
  }
});
function memo2(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
__name(memo2, "memo2");
var init_memo = __esm({
  "../node_modules/motion-utils/dist/es/memo.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(memo2, "memo");
  }
});
var progress;
var init_progress = __esm({
  "../node_modules/motion-utils/dist/es/progress.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    progress = /* @__PURE__ */ __name2((from27, to3, value) => {
      const toFromDifference = to3 - from27;
      return toFromDifference === 0 ? 1 : (value - from27) / toFromDifference;
    }, "progress");
  }
});
var secondsToMilliseconds;
var millisecondsToSeconds;
var init_time_conversion = __esm({
  "../node_modules/motion-utils/dist/es/time-conversion.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    secondsToMilliseconds = /* @__PURE__ */ __name2((seconds) => seconds * 1e3, "secondsToMilliseconds");
    millisecondsToSeconds = /* @__PURE__ */ __name2((milliseconds) => milliseconds / 1e3, "millisecondsToSeconds");
  }
});
var init_es = __esm({
  "../node_modules/motion-utils/dist/es/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_errors3();
    init_memo();
    init_noop();
    init_progress();
    init_time_conversion();
  }
});
var MotionGlobalConfig;
var init_GlobalConfig = __esm({
  "../node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    MotionGlobalConfig = {
      skipAnimations: false,
      useManualTiming: false
    };
  }
});
function createRenderStep(runNextFrame) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  __name(triggerCallback, "triggerCallback");
  __name2(triggerCallback, "triggerCallback");
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
__name(createRenderStep, "createRenderStep");
var init_render_step = __esm({
  "../node_modules/framer-motion/dist/es/frameloop/render-step.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(createRenderStep, "createRenderStep");
  }
});
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = /* @__PURE__ */ __name2(() => runNextFrame = true, "flagRunNextFrame");
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const { read, resolveKeyframes, update, preRender, render, postRender } = steps;
  const processBatch = /* @__PURE__ */ __name2(() => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    read.process(state);
    resolveKeyframes.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  }, "processBatch");
  const wake = /* @__PURE__ */ __name2(() => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  }, "wake");
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = /* @__PURE__ */ __name2((process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++) {
      steps[stepsOrder[i2]].cancel(process2);
    }
  }, "cancel");
  return { schedule, cancel, state, steps };
}
__name(createRenderBatcher, "createRenderBatcher");
var stepsOrder;
var maxElapsed;
var init_batcher = __esm({
  "../node_modules/framer-motion/dist/es/frameloop/batcher.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_GlobalConfig();
    init_render_step();
    stepsOrder = [
      "read",
      // Read
      "resolveKeyframes",
      // Write/Read/Write/Read
      "update",
      // Compute
      "preRender",
      // Compute
      "render",
      // Write
      "postRender"
      // Compute
    ];
    maxElapsed = 40;
    __name2(createRenderBatcher, "createRenderBatcher");
  }
});
var frame;
var cancelFrame;
var frameData;
var frameSteps;
var init_frame = __esm({
  "../node_modules/framer-motion/dist/es/frameloop/frame.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_batcher();
    ({ schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true));
  }
});
var import_react17;
var LazyContext;
var init_LazyContext = __esm({
  "../node_modules/framer-motion/dist/es/context/LazyContext.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react17 = __toESM(require_react(), 1);
    LazyContext = (0, import_react17.createContext)({ strict: false });
  }
});
var featureProps;
var featureDefinitions;
var init_definitions = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/definitions.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    featureProps = {
      animation: [
        "animate",
        "variants",
        "whileHover",
        "whileTap",
        "exit",
        "whileInView",
        "whileFocus",
        "whileDrag"
      ],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
    };
    featureDefinitions = {};
    for (const key in featureProps) {
      featureDefinitions[key] = {
        isEnabled: (props) => featureProps[key].some((name) => !!props[name])
      };
    }
  }
});
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
__name(loadFeatures, "loadFeatures");
var init_load_features = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/load-features.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_definitions();
    __name2(loadFeatures, "loadFeatures");
  }
});
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
__name(isValidMotionProp, "isValidMotionProp");
var validMotionProps;
var init_valid_prop = __esm({
  "../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    validMotionProps = /* @__PURE__ */ new Set([
      "animate",
      "exit",
      "variants",
      "initial",
      "style",
      "values",
      "variants",
      "transition",
      "transformTemplate",
      "custom",
      "inherit",
      "onBeforeLayoutMeasure",
      "onAnimationStart",
      "onAnimationComplete",
      "onUpdate",
      "onDragStart",
      "onDrag",
      "onDragEnd",
      "onMeasureDragConstraints",
      "onDirectionLock",
      "onDragTransitionEnd",
      "_dragX",
      "_dragY",
      "onHoverStart",
      "onHoverEnd",
      "onViewportEnter",
      "onViewportLeave",
      "globalTapTarget",
      "ignoreStrict",
      "viewport"
    ]);
    __name2(isValidMotionProp, "isValidMotionProp");
  }
});
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = /* @__PURE__ */ __name2((key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key), "shouldForward");
}
__name(loadExternalIsValidProp, "loadExternalIsValidProp");
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
__name(filterProps, "filterProps");
var shouldForward;
var init_filter_props = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_valid_prop();
    shouldForward = /* @__PURE__ */ __name2((key) => !isValidMotionProp(key), "shouldForward");
    __name2(loadExternalIsValidProp, "loadExternalIsValidProp");
    try {
      loadExternalIsValidProp(__require2("@emotion/is-prop-valid").default);
    } catch (_a) {
    }
    __name2(filterProps, "filterProps");
  }
});
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}
__name(warnOnce, "warnOnce");
var warned;
var init_warn_once = __esm({
  "../node_modules/framer-motion/dist/es/utils/warn-once.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    warned = /* @__PURE__ */ new Set();
    __name2(warnOnce, "warnOnce");
  }
});
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = /* @__PURE__ */ __name2((...args) => {
    if (true) {
      warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
    }
    return componentFactory(...args);
  }, "deprecatedFactoryFunction");
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create")
        return componentFactory;
      if (!componentCache.has(key)) {
        componentCache.set(key, componentFactory(key));
      }
      return componentCache.get(key);
    }
  });
}
__name(createDOMMotionComponentProxy, "createDOMMotionComponentProxy");
var init_create_proxy = __esm({
  "../node_modules/framer-motion/dist/es/render/components/create-proxy.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_warn_once();
    __name2(createDOMMotionComponentProxy, "createDOMMotionComponentProxy");
  }
});
var import_react18;
var MotionContext;
var init_MotionContext = __esm({
  "../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react18 = __toESM(require_react(), 1);
    MotionContext = (0, import_react18.createContext)({});
  }
});
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
__name(isVariantLabel, "isVariantLabel");
var init_is_variant_label = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isVariantLabel, "isVariantLabel");
  }
});
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
}
__name(isAnimationControls, "isAnimationControls");
var init_is_animation_controls = __esm({
  "../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isAnimationControls, "isAnimationControls");
  }
});
var variantPriorityOrder;
var variantProps;
var init_variant_props = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/variant-props.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    variantPriorityOrder = [
      "animate",
      "whileInView",
      "whileFocus",
      "whileHover",
      "whileTap",
      "whileDrag",
      "exit"
    ];
    variantProps = ["initial", ...variantPriorityOrder];
  }
});
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
__name(isControllingVariants, "isControllingVariants");
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
__name(isVariantNode, "isVariantNode");
var init_is_controlling_variants = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_animation_controls();
    init_is_variant_label();
    init_variant_props();
    __name2(isControllingVariants, "isControllingVariants");
    __name2(isVariantNode, "isVariantNode");
  }
});
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
__name(getCurrentTreeVariants, "getCurrentTreeVariants");
var init_utils5 = __esm({
  "../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_variant_label();
    init_is_controlling_variants();
    __name2(getCurrentTreeVariants, "getCurrentTreeVariants");
  }
});
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, (0, import_react19.useContext)(MotionContext));
  return (0, import_react19.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
__name(useCreateMotionContext, "useCreateMotionContext");
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
__name(variantLabelsAsDependency, "variantLabelsAsDependency");
var import_react19;
var init_create = __esm({
  "../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react19 = __toESM(require_react(), 1);
    init_MotionContext();
    init_utils5();
    __name2(useCreateMotionContext, "useCreateMotionContext");
    __name2(variantLabelsAsDependency, "variantLabelsAsDependency");
  }
});
var motionComponentSymbol;
var init_symbol = __esm({
  "../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    motionComponentSymbol = Symbol.for("motionComponentSymbol");
  }
});
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
__name(isRefObject, "isRefObject");
var init_is_ref_object = __esm({
  "../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isRefObject, "isRefObject");
  }
});
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, import_react20.useCallback)(
    (instance) => {
      if (instance) {
        visualState.onMount && visualState.onMount(instance);
      }
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
__name(useMotionRef, "useMotionRef");
var import_react20;
var init_use_motion_ref = __esm({
  "../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react20 = __toESM(require_react(), 1);
    init_is_ref_object();
    __name2(useMotionRef, "useMotionRef");
  }
});
var camelToDash;
var init_camel_to_dash = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    camelToDash = /* @__PURE__ */ __name2((str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), "camelToDash");
  }
});
var optimizedAppearDataId;
var optimizedAppearDataAttribute;
var init_data_id = __esm({
  "../node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_camel_to_dash();
    optimizedAppearDataId = "framerAppearId";
    optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
  }
});
var microtask;
var cancelMicrotask;
var init_microtask = __esm({
  "../node_modules/framer-motion/dist/es/frameloop/microtask.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_batcher();
    ({ schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false));
  }
});
var import_react21;
var SwitchLayoutGroupContext;
var init_SwitchLayoutGroupContext = __esm({
  "../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react21 = __toESM(require_react(), 1);
    SwitchLayoutGroupContext = (0, import_react21.createContext)({});
  }
});
function useVisualElement(Component3, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a, _b;
  const { visualElement: parent } = (0, import_react22.useContext)(MotionContext);
  const lazyContext = (0, import_react22.useContext)(LazyContext);
  const presenceContext = (0, import_react22.useContext)(PresenceContext);
  const reducedMotionConfig = (0, import_react22.useContext)(MotionConfigContext).reducedMotion;
  const visualElementRef = (0, import_react22.useRef)(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component3, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = (0, import_react22.useContext)(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = (0, import_react22.useRef)(false);
  (0, import_react22.useInsertionEffect)(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = (0, import_react22.useRef)(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  (0, import_react22.useEffect)(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a2;
        (_a2 = window.MotionHandoffMarkAsComplete) === null || _a2 === void 0 ? void 0 : _a2.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
__name(useVisualElement, "useVisualElement");
function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
__name(createProjectionNode, "createProjectionNode");
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
__name(getClosestProjectingNode, "getClosestProjectingNode");
var import_react22;
var init_use_visual_element = __esm({
  "../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react22 = __toESM(require_react(), 1);
    init_PresenceContext();
    init_MotionContext();
    init_use_isomorphic_effect();
    init_LazyContext();
    init_MotionConfigContext();
    init_data_id();
    init_microtask();
    init_is_ref_object();
    init_SwitchLayoutGroupContext();
    __name2(useVisualElement, "useVisualElement");
    __name2(createProjectionNode, "createProjectionNode");
    __name2(getClosestProjectingNode, "getClosestProjectingNode");
  }
});
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component: Component3 }) {
  var _a, _b;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...(0, import_react23.useContext)(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser2) {
      useStrictMode(configAndProps, preloadedFeatures);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return (0, import_jsx_runtime14.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? (0, import_jsx_runtime14.jsx)(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component3, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  __name(MotionComponent, "MotionComponent");
  __name2(MotionComponent, "MotionComponent");
  MotionComponent.displayName = `motion.${typeof Component3 === "string" ? Component3 : `create(${(_b = (_a = Component3.displayName) !== null && _a !== void 0 ? _a : Component3.name) !== null && _b !== void 0 ? _b : ""})`}`;
  const ForwardRefMotionComponent = (0, import_react23.forwardRef)(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component3;
  return ForwardRefMotionComponent;
}
__name(createRendererMotionComponent, "createRendererMotionComponent");
function useLayoutId({ layoutId }) {
  const layoutGroupId = (0, import_react23.useContext)(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
__name(useLayoutId, "useLayoutId");
function useStrictMode(configAndProps, preloadedFeatures) {
  const isStrict = (0, import_react23.useContext)(LazyContext).strict;
  if (preloadedFeatures && isStrict) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
  }
}
__name(useStrictMode, "useStrictMode");
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: (drag2 === null || drag2 === void 0 ? void 0 : drag2.isEnabled(props)) || (layout2 === null || layout2 === void 0 ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
__name(getProjectionFunctionality, "getProjectionFunctionality");
var import_jsx_runtime14;
var import_react23;
var init_motion = __esm({
  "../node_modules/framer-motion/dist/es/motion/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
    init_es();
    import_react23 = __toESM(require_react(), 1);
    init_LayoutGroupContext();
    init_LazyContext();
    init_MotionConfigContext();
    init_MotionContext();
    init_create();
    init_is_browser();
    init_definitions();
    init_load_features();
    init_symbol();
    init_use_motion_ref();
    init_use_visual_element();
    __name2(createRendererMotionComponent, "createRendererMotionComponent");
    __name2(useLayoutId, "useLayoutId");
    __name2(useStrictMode, "useStrictMode");
    __name2(getProjectionFunctionality, "getProjectionFunctionality");
  }
});
var lowercaseSVGElements;
var init_lowercase_elements = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    lowercaseSVGElements = [
      "animate",
      "circle",
      "defs",
      "desc",
      "ellipse",
      "g",
      "image",
      "line",
      "filter",
      "marker",
      "mask",
      "metadata",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "rect",
      "stop",
      "switch",
      "symbol",
      "svg",
      "text",
      "tspan",
      "use",
      "view"
    ];
  }
});
function isSVGComponent(Component3) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component3 !== "string" || /**
    * If it contains a dash, the element is a custom HTML webcomponent.
    */
    Component3.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component3) > -1 || /**
    * If it contains a capital letter, it's an SVG component
    */
    /[A-Z]/u.test(Component3)
  ) {
    return true;
  }
  return false;
}
__name(isSVGComponent, "isSVGComponent");
var init_is_svg_component = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_lowercase_elements();
    __name2(isSVGComponent, "isSVGComponent");
  }
});
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
__name(getValueState, "getValueState");
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
__name(resolveVariantFromProps, "resolveVariantFromProps");
var init_resolve_variants = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(getValueState, "getValueState");
    __name2(resolveVariantFromProps, "resolveVariantFromProps");
  }
});
var isKeyframesTarget;
var init_is_keyframes_target = __esm({
  "../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isKeyframesTarget = /* @__PURE__ */ __name2((v2) => {
      return Array.isArray(v2);
    }, "isKeyframesTarget");
  }
});
var isCustomValue;
var resolveFinalValueInKeyframes;
var init_resolve_value = __esm({
  "../node_modules/framer-motion/dist/es/utils/resolve-value.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_keyframes_target();
    isCustomValue = /* @__PURE__ */ __name2((v2) => {
      return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
    }, "isCustomValue");
    resolveFinalValueInKeyframes = /* @__PURE__ */ __name2((v2) => {
      return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
    }, "resolveFinalValueInKeyframes");
  }
});
var isMotionValue;
var init_is_motion_value = __esm({
  "../node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isMotionValue = /* @__PURE__ */ __name2((value) => Boolean(value && value.getVelocity), "isMotionValue");
  }
});
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
__name(resolveMotionValue, "resolveMotionValue");
var init_resolve_motion_value = __esm({
  "../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_resolve_value();
    init_is_motion_value();
    __name2(resolveMotionValue, "resolveMotionValue");
  }
});
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onUpdate }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onUpdate) {
    state.onMount = (instance) => onUpdate({ props, current: instance, ...state });
    state.onUpdate = (visualElement) => onUpdate(visualElement);
  }
  return state;
}
__name(makeState, "makeState");
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list.length; i2++) {
      const resolved = resolveVariantFromProps(props, list[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
__name(makeLatestValues, "makeLatestValues");
var import_react24;
var makeUseVisualState;
var init_use_visual_state = __esm({
  "../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react24 = __toESM(require_react(), 1);
    init_is_animation_controls();
    init_MotionContext();
    init_PresenceContext();
    init_is_controlling_variants();
    init_resolve_variants();
    init_use_constant();
    init_resolve_motion_value();
    __name2(makeState, "makeState");
    makeUseVisualState = /* @__PURE__ */ __name2((config) => (props, isStatic) => {
      const context = (0, import_react24.useContext)(MotionContext);
      const presenceContext = (0, import_react24.useContext)(PresenceContext);
      const make = /* @__PURE__ */ __name2(() => makeState(config, props, context, presenceContext), "make");
      return isStatic ? make() : useConstant(make);
    }, "makeUseVisualState");
    __name2(makeLatestValues, "makeLatestValues");
  }
});
var transformPropOrder;
var transformProps;
var init_keys_transform = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/keys-transform.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    transformPropOrder = [
      "transformPerspective",
      "x",
      "y",
      "z",
      "translateX",
      "translateY",
      "translateZ",
      "scale",
      "scaleX",
      "scaleY",
      "rotate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "skew",
      "skewX",
      "skewY"
    ];
    transformProps = new Set(transformPropOrder);
  }
});
var checkStringStartsWith;
var isCSSVariableName;
var startsAsVariableToken;
var isCSSVariableToken;
var singleCssVariableRegex;
var init_is_css_variable = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    checkStringStartsWith = /* @__PURE__ */ __name2((token) => (key) => typeof key === "string" && key.startsWith(token), "checkStringStartsWith");
    isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
    startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
    isCSSVariableToken = /* @__PURE__ */ __name2((value) => {
      const startsWithToken = startsAsVariableToken(value);
      if (!startsWithToken)
        return false;
      return singleCssVariableRegex.test(value.split("/*")[0].trim());
    }, "isCSSVariableToken");
    singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
  }
});
var getValueAsType;
var init_get_as_type = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    getValueAsType = /* @__PURE__ */ __name2((value, type6) => {
      return type6 && typeof value === "number" ? type6.transform(value) : value;
    }, "getValueAsType");
  }
});
var clamp;
var init_clamp = __esm({
  "../node_modules/framer-motion/dist/es/utils/clamp.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    clamp = /* @__PURE__ */ __name2((min, max, v2) => {
      if (v2 > max)
        return max;
      if (v2 < min)
        return min;
      return v2;
    }, "clamp");
  }
});
var number;
var alpha;
var scale;
var init_numbers = __esm({
  "../node_modules/framer-motion/dist/es/value/types/numbers/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_clamp();
    number = {
      test: (v2) => typeof v2 === "number",
      parse: parseFloat,
      transform: (v2) => v2
    };
    alpha = {
      ...number,
      transform: (v2) => clamp(0, 1, v2)
    };
    scale = {
      ...number,
      default: 1
    };
  }
});
var createUnitType;
var degrees;
var percent;
var px;
var vh;
var vw;
var progressPercentage;
var init_units = __esm({
  "../node_modules/framer-motion/dist/es/value/types/numbers/units.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    createUnitType = /* @__PURE__ */ __name2((unit) => ({
      test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
      parse: parseFloat,
      transform: (v2) => `${v2}${unit}`
    }), "createUnitType");
    degrees = /* @__PURE__ */ createUnitType("deg");
    percent = /* @__PURE__ */ createUnitType("%");
    px = /* @__PURE__ */ createUnitType("px");
    vh = /* @__PURE__ */ createUnitType("vh");
    vw = /* @__PURE__ */ createUnitType("vw");
    progressPercentage = {
      ...percent,
      parse: (v2) => percent.parse(v2) / 100,
      transform: (v2) => percent.transform(v2 * 100)
    };
  }
});
var browserNumberValueTypes;
var init_number_browser = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/number-browser.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_units();
    browserNumberValueTypes = {
      // Border props
      borderWidth: px,
      borderTopWidth: px,
      borderRightWidth: px,
      borderBottomWidth: px,
      borderLeftWidth: px,
      borderRadius: px,
      radius: px,
      borderTopLeftRadius: px,
      borderTopRightRadius: px,
      borderBottomRightRadius: px,
      borderBottomLeftRadius: px,
      // Positioning props
      width: px,
      maxWidth: px,
      height: px,
      maxHeight: px,
      top: px,
      right: px,
      bottom: px,
      left: px,
      // Spacing props
      padding: px,
      paddingTop: px,
      paddingRight: px,
      paddingBottom: px,
      paddingLeft: px,
      margin: px,
      marginTop: px,
      marginRight: px,
      marginBottom: px,
      marginLeft: px,
      // Misc
      backgroundPositionX: px,
      backgroundPositionY: px
    };
  }
});
var transformValueTypes;
var init_transform = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/transform.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_numbers();
    init_units();
    transformValueTypes = {
      rotate: degrees,
      rotateX: degrees,
      rotateY: degrees,
      rotateZ: degrees,
      scale,
      scaleX: scale,
      scaleY: scale,
      scaleZ: scale,
      skew: degrees,
      skewX: degrees,
      skewY: degrees,
      distance: px,
      translateX: px,
      translateY: px,
      translateZ: px,
      x: px,
      y: px,
      z: px,
      perspective: px,
      transformPerspective: px,
      opacity: alpha,
      originX: progressPercentage,
      originY: progressPercentage,
      originZ: px
    };
  }
});
var int;
var init_type_int = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_numbers();
    int = {
      ...number,
      transform: Math.round
    };
  }
});
var numberValueTypes;
var init_number = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_numbers();
    init_units();
    init_number_browser();
    init_transform();
    init_type_int();
    numberValueTypes = {
      ...browserNumberValueTypes,
      ...transformValueTypes,
      zIndex: int,
      size: px,
      // SVG
      fillOpacity: alpha,
      strokeOpacity: alpha,
      numOctaves: int
    };
  }
});
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
__name(buildTransform, "buildTransform");
var translateAlias;
var numTransforms;
var init_build_transform = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_get_as_type();
    init_number();
    init_keys_transform();
    translateAlias = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective"
    };
    numTransforms = transformPropOrder.length;
    __name2(buildTransform, "buildTransform");
  }
});
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
__name(buildHTMLStyles, "buildHTMLStyles");
var init_build_styles = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_css_variable();
    init_get_as_type();
    init_number();
    init_build_transform();
    init_keys_transform();
    __name2(buildHTMLStyles, "buildHTMLStyles");
  }
});
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
__name(buildSVGPath, "buildSVGPath");
var dashKeys;
var camelKeys;
var init_path = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_units();
    dashKeys = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
    };
    camelKeys = {
      offset: "strokeDashoffset",
      array: "strokeDasharray"
    };
    __name2(buildSVGPath, "buildSVGPath");
  }
});
function calcOrigin(origin, offset, size3) {
  return typeof origin === "string" ? origin : px.transform(offset + size3 * origin);
}
__name(calcOrigin, "calcOrigin");
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
__name(calcSVGTransformOrigin, "calcSVGTransformOrigin");
var init_transform_origin = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_units();
    __name2(calcOrigin, "calcOrigin");
    __name2(calcSVGTransformOrigin, "calcSVGTransformOrigin");
  }
});
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
__name(buildSVGAttrs, "buildSVGAttrs");
var init_build_attrs = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_build_styles();
    init_path();
    init_transform_origin();
    __name2(buildSVGAttrs, "buildSVGAttrs");
  }
});
var createHtmlRenderState;
var init_create_render_state = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    createHtmlRenderState = /* @__PURE__ */ __name2(() => ({
      style: {},
      transform: {},
      transformOrigin: {},
      vars: {}
    }), "createHtmlRenderState");
  }
});
var createSvgRenderState;
var init_create_render_state2 = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_create_render_state();
    createSvgRenderState = /* @__PURE__ */ __name2(() => ({
      ...createHtmlRenderState(),
      attrs: {}
    }), "createSvgRenderState");
  }
});
var isSVGTag;
var init_is_svg_tag = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isSVGTag = /* @__PURE__ */ __name2((tag) => typeof tag === "string" && tag.toLowerCase() === "svg", "isSVGTag");
  }
});
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
__name(renderHTML, "renderHTML");
var init_render = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/render.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(renderHTML, "renderHTML");
  }
});
var camelCaseAttributes;
var init_camel_case_attrs = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    camelCaseAttributes = /* @__PURE__ */ new Set([
      "baseFrequency",
      "diffuseConstant",
      "kernelMatrix",
      "kernelUnitLength",
      "keySplines",
      "keyTimes",
      "limitingConeAngle",
      "markerHeight",
      "markerWidth",
      "numOctaves",
      "targetX",
      "targetY",
      "surfaceScale",
      "specularConstant",
      "specularExponent",
      "stdDeviation",
      "tableValues",
      "viewBox",
      "gradientTransform",
      "pathLength",
      "startOffset",
      "textLength",
      "lengthAdjust"
    ]);
  }
});
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
__name(renderSVG, "renderSVG");
var init_render2 = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_camel_to_dash();
    init_render();
    init_camel_case_attrs();
    __name2(renderSVG, "renderSVG");
  }
});
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
__name(addScaleCorrector, "addScaleCorrector");
var scaleCorrectors;
var init_scale_correction = __esm({
  "../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    scaleCorrectors = {};
    __name2(addScaleCorrector, "addScaleCorrector");
  }
});
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
__name(isForcedMotionValue, "isForcedMotionValue");
var init_is_forced_motion_value = __esm({
  "../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_scale_correction();
    init_keys_transform();
    __name2(isForcedMotionValue, "isForcedMotionValue");
  }
});
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  var _a;
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps, "scrapeMotionValuesFromProps");
var init_scrape_motion_values = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_forced_motion_value();
    init_is_motion_value();
    __name2(scrapeMotionValuesFromProps, "scrapeMotionValuesFromProps");
  }
});
function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps2, "scrapeMotionValuesFromProps2");
var init_scrape_motion_values2 = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_motion_value();
    init_keys_transform();
    init_scrape_motion_values();
    __name2(scrapeMotionValuesFromProps2, "scrapeMotionValuesFromProps");
  }
});
function updateSVGDimensions(instance, renderState) {
  try {
    renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
  } catch (e2) {
    renderState.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
__name(updateSVGDimensions, "updateSVGDimensions");
var layoutProps;
var svgMotionConfig;
var init_config_motion = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/config-motion.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_frame();
    init_use_visual_state();
    init_keys_transform();
    init_build_attrs();
    init_create_render_state2();
    init_is_svg_tag();
    init_render2();
    init_scrape_motion_values2();
    __name2(updateSVGDimensions, "updateSVGDimensions");
    layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"];
    svgMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
        createRenderState: createSvgRenderState,
        onUpdate: ({ props, prevProps, current, renderState, latestValues }) => {
          if (!current)
            return;
          let hasTransform2 = !!props.drag;
          if (!hasTransform2) {
            for (const key in latestValues) {
              if (transformProps.has(key)) {
                hasTransform2 = true;
                break;
              }
            }
          }
          if (!hasTransform2)
            return;
          let needsMeasure = !prevProps;
          if (prevProps) {
            for (let i2 = 0; i2 < layoutProps.length; i2++) {
              const key = layoutProps[i2];
              if (props[key] !== prevProps[key]) {
                needsMeasure = true;
              }
            }
          }
          if (!needsMeasure)
            return;
          frame.read(() => {
            updateSVGDimensions(current, renderState);
            frame.render(() => {
              buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);
              renderSVG(current, renderState);
            });
          });
        }
      })
    };
  }
});
var htmlMotionConfig;
var init_config_motion2 = __esm({
  "../node_modules/framer-motion/dist/es/render/html/config-motion.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_use_visual_state();
    init_scrape_motion_values();
    init_create_render_state();
    htmlMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createHtmlRenderState
      })
    };
  }
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
__name(copyRawValuesOnly, "copyRawValuesOnly");
function useInitialMotionValues({ transformTemplate }, visualState) {
  return (0, import_react25.useMemo)(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
__name(useInitialMotionValues, "useInitialMotionValues");
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
__name(useStyle, "useStyle");
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
__name(useHTMLProps, "useHTMLProps");
var import_react25;
var init_use_props = __esm({
  "../node_modules/framer-motion/dist/es/render/html/use-props.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react25 = __toESM(require_react(), 1);
    init_is_forced_motion_value();
    init_is_motion_value();
    init_build_styles();
    init_create_render_state();
    __name2(copyRawValuesOnly, "copyRawValuesOnly");
    __name2(useInitialMotionValues, "useInitialMotionValues");
    __name2(useStyle, "useStyle");
    __name2(useHTMLProps, "useHTMLProps");
  }
});
function useSVGProps(props, visualState, _isStatic, Component3) {
  const visualProps = (0, import_react26.useMemo)(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component3), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
__name(useSVGProps, "useSVGProps");
var import_react26;
var init_use_props2 = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/use-props.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react26 = __toESM(require_react(), 1);
    init_use_props();
    init_build_attrs();
    init_create_render_state2();
    init_is_svg_tag();
    __name2(useSVGProps, "useSVGProps");
  }
});
function createUseRender(forwardMotionProps = false) {
  const useRender = /* @__PURE__ */ __name2((Component3, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component3);
    const filteredProps = filterProps(props, typeof Component3 === "string", forwardMotionProps);
    const elementProps = Component3 !== import_react27.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = (0, import_react27.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react27.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  }, "useRender");
  return useRender;
}
__name(createUseRender, "createUseRender");
var import_react27;
var init_use_render = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/use-render.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react27 = __toESM(require_react(), 1);
    init_use_props();
    init_filter_props();
    init_is_svg_component();
    init_use_props2();
    init_is_motion_value();
    __name2(createUseRender, "createUseRender");
  }
});
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function createMotionComponent2(Component3, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component3) ? svgMotionConfig : htmlMotionConfig;
    const config = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component3
    };
    return createRendererMotionComponent(config);
  }, "createMotionComponent2"), "createMotionComponent");
}
__name(createMotionComponentFactory, "createMotionComponentFactory");
var init_create_factory = __esm({
  "../node_modules/framer-motion/dist/es/render/components/create-factory.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_motion();
    init_is_svg_component();
    init_config_motion();
    init_config_motion2();
    init_use_render();
    __name2(createMotionComponentFactory, "createMotionComponentFactory");
  }
});
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev[i2] !== next[i2])
      return false;
  }
  return true;
}
__name(shallowCompare, "shallowCompare");
var init_shallow_compare = __esm({
  "../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(shallowCompare, "shallowCompare");
  }
});
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
__name(resolveVariant, "resolveVariant");
var init_resolve_dynamic_variants = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_resolve_variants();
    __name2(resolveVariant, "resolveVariant");
  }
});
var supportsScrollTimeline;
var init_scroll_timeline = __esm({
  "../node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    supportsScrollTimeline = memo2(() => window.ScrollTimeline !== void 0);
  }
});
var BaseGroupPlaybackControls;
var init_BaseGroup = __esm({
  "../node_modules/motion-dom/dist/es/animation/controls/BaseGroup.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_scroll_timeline();
    BaseGroupPlaybackControls = /* @__PURE__ */ __name(class {
      constructor(animations2) {
        this.stop = () => this.runAll("stop");
        this.animations = animations2.filter(Boolean);
      }
      get finished() {
        return Promise.all(this.animations.map((animation) => "finished" in animation ? animation.finished : animation));
      }
      /**
       * TODO: Filter out cancelled or stopped animations before returning
       */
      getAll(propName) {
        return this.animations[0][propName];
      }
      setAll(propName, newValue) {
        for (let i2 = 0; i2 < this.animations.length; i2++) {
          this.animations[i2][propName] = newValue;
        }
      }
      attachTimeline(timeline, fallback) {
        const subscriptions = this.animations.map((animation) => {
          if (supportsScrollTimeline() && animation.attachTimeline) {
            return animation.attachTimeline(timeline);
          } else if (typeof fallback === "function") {
            return fallback(animation);
          }
        });
        return () => {
          subscriptions.forEach((cancel, i2) => {
            cancel && cancel();
            this.animations[i2].stop();
          });
        };
      }
      get time() {
        return this.getAll("time");
      }
      set time(time2) {
        this.setAll("time", time2);
      }
      get speed() {
        return this.getAll("speed");
      }
      set speed(speed) {
        this.setAll("speed", speed);
      }
      get startTime() {
        return this.getAll("startTime");
      }
      get duration() {
        let max = 0;
        for (let i2 = 0; i2 < this.animations.length; i2++) {
          max = Math.max(max, this.animations[i2].duration);
        }
        return max;
      }
      runAll(methodName) {
        this.animations.forEach((controls) => controls[methodName]());
      }
      flatten() {
        this.runAll("flatten");
      }
      play() {
        this.runAll("play");
      }
      pause() {
        this.runAll("pause");
      }
      cancel() {
        this.runAll("cancel");
      }
      complete() {
        this.runAll("complete");
      }
    }, "BaseGroupPlaybackControls");
    __name2(BaseGroupPlaybackControls, "BaseGroupPlaybackControls");
  }
});
var GroupPlaybackControls;
var init_Group = __esm({
  "../node_modules/motion-dom/dist/es/animation/controls/Group.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_BaseGroup();
    GroupPlaybackControls = /* @__PURE__ */ __name(class extends BaseGroupPlaybackControls {
      then(onResolve, onReject) {
        return Promise.all(this.animations).then(onResolve).catch(onReject);
      }
    }, "GroupPlaybackControls");
    __name2(GroupPlaybackControls, "GroupPlaybackControls");
  }
});
function getValueTransition(transition, key) {
  return transition ? transition[key] || transition["default"] || transition : void 0;
}
__name(getValueTransition, "getValueTransition");
var init_get_value_transition = __esm({
  "../node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(getValueTransition, "getValueTransition");
  }
});
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
__name(calcGeneratorDuration, "calcGeneratorDuration");
var maxGeneratorDuration;
var init_calc_duration = __esm({
  "../node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    maxGeneratorDuration = 2e4;
    __name2(calcGeneratorDuration, "calcGeneratorDuration");
  }
});
var init_create_generator_easing = __esm({
  "../node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_calc_duration();
  }
});
function isGenerator(type6) {
  return typeof type6 === "function";
}
__name(isGenerator, "isGenerator");
var init_is_generator = __esm({
  "../node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isGenerator, "isGenerator");
  }
});
function attachTimeline(animation, timeline) {
  animation.timeline = timeline;
  animation.onfinish = null;
}
__name(attachTimeline, "attachTimeline");
var init_attach_timeline = __esm({
  "../node_modules/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(attachTimeline, "attachTimeline");
  }
});
var init_NativeAnimationControls = __esm({
  "../node_modules/motion-dom/dist/es/animation/waapi/NativeAnimationControls.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_attach_timeline();
  }
});
var isBezierDefinition;
var init_is_bezier_definition = __esm({
  "../node_modules/motion-dom/dist/es/utils/is-bezier-definition.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isBezierDefinition = /* @__PURE__ */ __name2((easing) => Array.isArray(easing) && typeof easing[0] === "number", "isBezierDefinition");
  }
});
var supportsFlags;
var init_flags = __esm({
  "../node_modules/motion-dom/dist/es/utils/supports/flags.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    supportsFlags = {
      linearEasing: void 0
    };
  }
});
function memoSupports(callback, supportsFlag) {
  const memoized2 = memo2(callback);
  return () => {
    var _a;
    return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized2();
  };
}
__name(memoSupports, "memoSupports");
var init_memo2 = __esm({
  "../node_modules/motion-dom/dist/es/utils/supports/memo.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_flags();
    __name2(memoSupports, "memoSupports");
  }
});
var supportsLinearEasing;
var init_linear_easing = __esm({
  "../node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_memo2();
    supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
      try {
        document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
      } catch (e2) {
        return false;
      }
      return true;
    }, "linearEasing");
  }
});
var generateLinearEasing;
var init_linear = __esm({
  "../node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    generateLinearEasing = /* @__PURE__ */ __name2((easing, duration, resolution = 10) => {
      let points = "";
      const numPoints = Math.max(Math.round(duration / resolution), 2);
      for (let i2 = 0; i2 < numPoints; i2++) {
        points += easing(progress(0, numPoints - 1, i2)) + ", ";
      }
      return `linear(${points.substring(0, points.length - 2)})`;
    }, "generateLinearEasing");
  }
});
function isWaapiSupportedEasing(easing) {
  return Boolean(typeof easing === "function" && supportsLinearEasing() || !easing || typeof easing === "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
__name(isWaapiSupportedEasing, "isWaapiSupportedEasing");
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function" && supportsLinearEasing()) {
    return generateLinearEasing(easing, duration);
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}
__name(mapEasingToNativeEasing, "mapEasingToNativeEasing");
var cubicBezierAsString;
var supportedWaapiEasing;
var init_easing = __esm({
  "../node_modules/motion-dom/dist/es/animation/waapi/utils/easing.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_bezier_definition();
    init_linear_easing();
    init_linear();
    __name2(isWaapiSupportedEasing, "isWaapiSupportedEasing");
    cubicBezierAsString = /* @__PURE__ */ __name2(([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`, "cubicBezierAsString");
    supportedWaapiEasing = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
      circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
      backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
      backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
    };
    __name2(mapEasingToNativeEasing, "mapEasingToNativeEasing");
  }
});
function isDragActive() {
  return isDragging.x || isDragging.y;
}
__name(isDragActive, "isDragActive");
var isDragging;
var init_is_active = __esm({
  "../node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isDragging = {
      x: false,
      y: false
    };
    __name2(isDragActive, "isDragActive");
  }
});
function resolveElements(elementOrSelector, scope, selectorCache) {
  var _a;
  if (elementOrSelector instanceof Element) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root = document;
    if (scope) {
      root = scope.current;
    }
    const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
__name(resolveElements, "resolveElements");
var init_resolve_elements = __esm({
  "../node_modules/motion-dom/dist/es/utils/resolve-elements.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(resolveElements, "resolveElements");
  }
});
function setupGesture(elementOrSelector, options2) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options2,
    signal: gestureAbortController.signal
  };
  const cancel = /* @__PURE__ */ __name2(() => gestureAbortController.abort(), "cancel");
  return [elements, eventOptions, cancel];
}
__name(setupGesture, "setupGesture");
var init_setup = __esm({
  "../node_modules/motion-dom/dist/es/gestures/utils/setup.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_resolve_elements();
    __name2(setupGesture, "setupGesture");
  }
});
function filterEvents(callback) {
  return (event) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    callback(event);
  };
}
__name(filterEvents, "filterEvents");
function hover(elementOrSelector, onHoverStart, options2 = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options2);
  const onPointerEnter = filterEvents((enterEvent) => {
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = filterEvents((leaveEvent) => {
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    });
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  });
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
__name(hover, "hover");
var init_hover = __esm({
  "../node_modules/motion-dom/dist/es/gestures/hover.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_active();
    init_setup();
    __name2(filterEvents, "filterEvents");
    __name2(hover, "hover");
  }
});
var isNodeOrChild;
var init_is_node_or_child = __esm({
  "../node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isNodeOrChild = /* @__PURE__ */ __name2((parent, child) => {
      if (!child) {
        return false;
      } else if (parent === child) {
        return true;
      } else {
        return isNodeOrChild(parent, child.parentElement);
      }
    }, "isNodeOrChild");
  }
});
var isPrimaryPointer;
var init_is_primary_pointer = __esm({
  "../node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isPrimaryPointer = /* @__PURE__ */ __name2((event) => {
      if (event.pointerType === "mouse") {
        return typeof event.button !== "number" || event.button <= 0;
      } else {
        return event.isPrimary !== false;
      }
    }, "isPrimaryPointer");
  }
});
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
__name(isElementKeyboardAccessible, "isElementKeyboardAccessible");
var focusableElements;
var init_is_keyboard_accessible = __esm({
  "../node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    focusableElements = /* @__PURE__ */ new Set([
      "BUTTON",
      "INPUT",
      "SELECT",
      "TEXTAREA",
      "A"
    ]);
    __name2(isElementKeyboardAccessible, "isElementKeyboardAccessible");
  }
});
var isPressing;
var init_state = __esm({
  "../node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isPressing = /* @__PURE__ */ new WeakSet();
  }
});
function filterEvents2(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
__name(filterEvents2, "filterEvents2");
function firePointerEvent(target, type6) {
  target.dispatchEvent(new PointerEvent("pointer" + type6, { isPrimary: true, bubbles: true }));
}
__name(firePointerEvent, "firePointerEvent");
var enableKeyboardPress;
var init_keyboard = __esm({
  "../node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_state();
    __name2(filterEvents2, "filterEvents");
    __name2(firePointerEvent, "firePointerEvent");
    enableKeyboardPress = /* @__PURE__ */ __name2((focusEvent, eventOptions) => {
      const element = focusEvent.currentTarget;
      if (!element)
        return;
      const handleKeydown = filterEvents2(() => {
        if (isPressing.has(element))
          return;
        firePointerEvent(element, "down");
        const handleKeyup = filterEvents2(() => {
          firePointerEvent(element, "up");
        });
        const handleBlur = /* @__PURE__ */ __name2(() => firePointerEvent(element, "cancel"), "handleBlur");
        element.addEventListener("keyup", handleKeyup, eventOptions);
        element.addEventListener("blur", handleBlur, eventOptions);
      });
      element.addEventListener("keydown", handleKeydown, eventOptions);
      element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
    }, "enableKeyboardPress");
  }
});
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
__name(isValidPressEvent, "isValidPressEvent");
function press(elementOrSelector, onPressStart, options2 = {}) {
  const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options2);
  const startPress = /* @__PURE__ */ __name2((startEvent) => {
    const element = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent) || isPressing.has(element))
      return;
    isPressing.add(element);
    const onPressEnd = onPressStart(startEvent);
    const onPointerEnd = /* @__PURE__ */ __name2((endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {
        return;
      }
      isPressing.delete(element);
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    }, "onPointerEnd");
    const onPointerUp = /* @__PURE__ */ __name2((upEvent) => {
      onPointerEnd(upEvent, options2.useGlobalTarget || isNodeOrChild(element, upEvent.target));
    }, "onPointerUp");
    const onPointerCancel = /* @__PURE__ */ __name2((cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    }, "onPointerCancel");
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  }, "startPress");
  elements.forEach((element) => {
    if (!isElementKeyboardAccessible(element) && element.getAttribute("tabindex") === null) {
      element.tabIndex = 0;
    }
    const target = options2.useGlobalTarget ? window : element;
    target.addEventListener("pointerdown", startPress, eventOptions);
    element.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions), eventOptions);
  });
  return cancelEvents;
}
__name(press, "press");
var init_press = __esm({
  "../node_modules/motion-dom/dist/es/gestures/press/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_active();
    init_is_node_or_child();
    init_is_primary_pointer();
    init_setup();
    init_is_keyboard_accessible();
    init_keyboard();
    init_state();
    __name2(isValidPressEvent, "isValidPressEvent");
    __name2(press, "press");
  }
});
var init_convert_options = __esm({
  "../node_modules/motion-dom/dist/es/animation/waapi/utils/convert-options.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_linear_easing();
    init_create_generator_easing();
    init_is_generator();
    init_easing();
  }
});
var init_PseudoAnimation = __esm({
  "../node_modules/motion-dom/dist/es/animation/waapi/PseudoAnimation.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_NativeAnimationControls();
    init_convert_options();
  }
});
var init_choose_layer_type = __esm({
  "../node_modules/motion-dom/dist/es/view/utils/choose-layer-type.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
var init_css = __esm({
  "../node_modules/motion-dom/dist/es/view/utils/css.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
var init_get_layer_name = __esm({
  "../node_modules/motion-dom/dist/es/view/utils/get-layer-name.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
var init_get_view_animations = __esm({
  "../node_modules/motion-dom/dist/es/view/utils/get-view-animations.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
var init_has_target = __esm({
  "../node_modules/motion-dom/dist/es/view/utils/has-target.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
  }
});
var init_start = __esm({
  "../node_modules/motion-dom/dist/es/view/start.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_BaseGroup();
    init_get_value_transition();
    init_NativeAnimationControls();
    init_PseudoAnimation();
    init_convert_options();
    init_easing();
    init_choose_layer_type();
    init_css();
    init_get_layer_name();
    init_get_view_animations();
    init_has_target();
  }
});
var init_view = __esm({
  "../node_modules/motion-dom/dist/es/view/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_start();
  }
});
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
__name(setDragLock, "setDragLock");
var init_set_active = __esm({
  "../node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_active();
    __name2(setDragLock, "setDragLock");
  }
});
var init_es2 = __esm({
  "../node_modules/motion-dom/dist/es/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Group();
    init_get_value_transition();
    init_calc_duration();
    init_create_generator_easing();
    init_is_generator();
    init_NativeAnimationControls();
    init_attach_timeline();
    init_easing();
    init_linear();
    init_hover();
    init_press();
    init_is_bezier_definition();
    init_resolve_elements();
    init_flags();
    init_linear_easing();
    init_scroll_timeline();
    init_view();
    init_is_active();
    init_set_active();
    init_is_node_or_child();
    init_is_primary_pointer();
  }
});
var positionalKeys;
var init_keys_position = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/keys-position.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_keys_transform();
    positionalKeys = /* @__PURE__ */ new Set([
      "width",
      "height",
      "top",
      "left",
      "right",
      "bottom",
      ...transformPropOrder
    ]);
  }
});
function clearTime() {
  now = void 0;
}
__name(clearTime, "clearTime");
var now;
var time;
var init_sync_time = __esm({
  "../node_modules/framer-motion/dist/es/frameloop/sync-time.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_GlobalConfig();
    init_frame();
    __name2(clearTime, "clearTime");
    time = {
      now: () => {
        if (now === void 0) {
          time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
        }
        return now;
      },
      set: (newTime) => {
        now = newTime;
        queueMicrotask(clearTime);
      }
    };
  }
});
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
__name(addUniqueItem, "addUniqueItem");
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
__name(removeItem, "removeItem");
var init_array = __esm({
  "../node_modules/framer-motion/dist/es/utils/array.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(addUniqueItem, "addUniqueItem");
    __name2(removeItem, "removeItem");
  }
});
var SubscriptionManager;
var init_subscription_manager = __esm({
  "../node_modules/framer-motion/dist/es/utils/subscription-manager.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_array();
    SubscriptionManager = /* @__PURE__ */ __name(class {
      constructor() {
        this.subscriptions = [];
      }
      add(handler) {
        addUniqueItem(this.subscriptions, handler);
        return () => removeItem(this.subscriptions, handler);
      }
      notify(a2, b2, c2) {
        const numSubscriptions = this.subscriptions.length;
        if (!numSubscriptions)
          return;
        if (numSubscriptions === 1) {
          this.subscriptions[0](a2, b2, c2);
        } else {
          for (let i2 = 0; i2 < numSubscriptions; i2++) {
            const handler = this.subscriptions[i2];
            handler && handler(a2, b2, c2);
          }
        }
      }
      getSize() {
        return this.subscriptions.length;
      }
      clear() {
        this.subscriptions.length = 0;
      }
    }, "SubscriptionManager");
    __name2(SubscriptionManager, "SubscriptionManager");
  }
});
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
__name(velocityPerSecond, "velocityPerSecond");
var init_velocity_per_second = __esm({
  "../node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(velocityPerSecond, "velocityPerSecond");
  }
});
function motionValue(init2, options2) {
  return new MotionValue(init2, options2);
}
__name(motionValue, "motionValue");
var MAX_VELOCITY_DELTA;
var isFloat;
var collectMotionValues;
var MotionValue;
var init_value = __esm({
  "../node_modules/framer-motion/dist/es/value/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sync_time();
    init_subscription_manager();
    init_velocity_per_second();
    init_warn_once();
    init_frame();
    MAX_VELOCITY_DELTA = 30;
    isFloat = /* @__PURE__ */ __name2((value) => {
      return !isNaN(parseFloat(value));
    }, "isFloat");
    collectMotionValues = {
      current: void 0
    };
    MotionValue = /* @__PURE__ */ __name(class {
      /**
       * @param init - The initiating value
       * @param config - Optional configuration options
       *
       * -  `transformer`: A function to transform incoming values with.
       *
       * @internal
       */
      constructor(init2, options2 = {}) {
        this.version = "11.18.2";
        this.canTrackVelocity = null;
        this.events = {};
        this.updateAndNotify = (v2, render = true) => {
          const currentTime = time.now();
          if (this.updatedAt !== currentTime) {
            this.setPrevFrameValue();
          }
          this.prev = this.current;
          this.setCurrent(v2);
          if (this.current !== this.prev && this.events.change) {
            this.events.change.notify(this.current);
          }
          if (render && this.events.renderRequest) {
            this.events.renderRequest.notify(this.current);
          }
        };
        this.hasAnimated = false;
        this.setCurrent(init2);
        this.owner = options2.owner;
      }
      setCurrent(current) {
        this.current = current;
        this.updatedAt = time.now();
        if (this.canTrackVelocity === null && current !== void 0) {
          this.canTrackVelocity = isFloat(this.current);
        }
      }
      setPrevFrameValue(prevFrameValue = this.current) {
        this.prevFrameValue = prevFrameValue;
        this.prevUpdatedAt = this.updatedAt;
      }
      /**
       * Adds a function that will be notified when the `MotionValue` is updated.
       *
       * It returns a function that, when called, will cancel the subscription.
       *
       * When calling `onChange` inside a React component, it should be wrapped with the
       * `useEffect` hook. As it returns an unsubscribe function, this should be returned
       * from the `useEffect` function to ensure you don't add duplicate subscribers..
       *
       * ```jsx
       * export const MyComponent = () => {
       *   const x = useMotionValue(0)
       *   const y = useMotionValue(0)
       *   const opacity = useMotionValue(1)
       *
       *   useEffect(() => {
       *     function updateOpacity() {
       *       const maxXY = Math.max(x.get(), y.get())
       *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
       *       opacity.set(newOpacity)
       *     }
       *
       *     const unsubscribeX = x.on("change", updateOpacity)
       *     const unsubscribeY = y.on("change", updateOpacity)
       *
       *     return () => {
       *       unsubscribeX()
       *       unsubscribeY()
       *     }
       *   }, [])
       *
       *   return <motion.div style={{ x }} />
       * }
       * ```
       *
       * @param subscriber - A function that receives the latest value.
       * @returns A function that, when called, will cancel this subscription.
       *
       * @deprecated
       */
      onChange(subscription) {
        if (true) {
          warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
        }
        return this.on("change", subscription);
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new SubscriptionManager();
        }
        const unsubscribe = this.events[eventName].add(callback);
        if (eventName === "change") {
          return () => {
            unsubscribe();
            frame.read(() => {
              if (!this.events.change.getSize()) {
                this.stop();
              }
            });
          };
        }
        return unsubscribe;
      }
      clearListeners() {
        for (const eventManagers in this.events) {
          this.events[eventManagers].clear();
        }
      }
      /**
       * Attaches a passive effect to the `MotionValue`.
       *
       * @internal
       */
      attach(passiveEffect, stopPassiveEffect) {
        this.passiveEffect = passiveEffect;
        this.stopPassiveEffect = stopPassiveEffect;
      }
      /**
       * Sets the state of the `MotionValue`.
       *
       * @remarks
       *
       * ```jsx
       * const x = useMotionValue(0)
       * x.set(10)
       * ```
       *
       * @param latest - Latest value to set.
       * @param render - Whether to notify render subscribers. Defaults to `true`
       *
       * @public
       */
      set(v2, render = true) {
        if (!render || !this.passiveEffect) {
          this.updateAndNotify(v2, render);
        } else {
          this.passiveEffect(v2, this.updateAndNotify);
        }
      }
      setWithVelocity(prev, current, delta) {
        this.set(current);
        this.prev = void 0;
        this.prevFrameValue = prev;
        this.prevUpdatedAt = this.updatedAt - delta;
      }
      /**
       * Set the state of the `MotionValue`, stopping any active animations,
       * effects, and resets velocity to `0`.
       */
      jump(v2, endAnimation = true) {
        this.updateAndNotify(v2);
        this.prev = v2;
        this.prevUpdatedAt = this.prevFrameValue = void 0;
        endAnimation && this.stop();
        if (this.stopPassiveEffect)
          this.stopPassiveEffect();
      }
      /**
       * Returns the latest state of `MotionValue`
       *
       * @returns - The latest state of `MotionValue`
       *
       * @public
       */
      get() {
        if (collectMotionValues.current) {
          collectMotionValues.current.push(this);
        }
        return this.current;
      }
      /**
       * @public
       */
      getPrevious() {
        return this.prev;
      }
      /**
       * Returns the latest velocity of `MotionValue`
       *
       * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
       *
       * @public
       */
      getVelocity() {
        const currentTime = time.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
          return 0;
        }
        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
        return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
      }
      /**
       * Registers a new animation to control this `MotionValue`. Only one
       * animation can drive a `MotionValue` at one time.
       *
       * ```jsx
       * value.start()
       * ```
       *
       * @param animation - A function that starts the provided animation
       *
       * @internal
       */
      start(startAnimation) {
        this.stop();
        return new Promise((resolve) => {
          this.hasAnimated = true;
          this.animation = startAnimation(resolve);
          if (this.events.animationStart) {
            this.events.animationStart.notify();
          }
        }).then(() => {
          if (this.events.animationComplete) {
            this.events.animationComplete.notify();
          }
          this.clearAnimation();
        });
      }
      /**
       * Stop the currently active animation.
       *
       * @public
       */
      stop() {
        if (this.animation) {
          this.animation.stop();
          if (this.events.animationCancel) {
            this.events.animationCancel.notify();
          }
        }
        this.clearAnimation();
      }
      /**
       * Returns `true` if this value is currently animating.
       *
       * @public
       */
      isAnimating() {
        return !!this.animation;
      }
      clearAnimation() {
        delete this.animation;
      }
      /**
       * Destroy and clean up subscribers to this `MotionValue`.
       *
       * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
       * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
       * created a `MotionValue` via the `motionValue` function.
       *
       * @public
       */
      destroy() {
        this.clearListeners();
        this.stop();
        if (this.stopPassiveEffect) {
          this.stopPassiveEffect();
        }
      }
    }, "MotionValue");
    __name2(MotionValue, "MotionValue");
    __name2(motionValue, "motionValue");
  }
});
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
__name(setMotionValue, "setMotionValue");
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
__name(setTarget, "setTarget");
var init_setters = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/setters.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_resolve_value();
    init_value();
    init_resolve_dynamic_variants();
    __name2(setMotionValue, "setMotionValue");
    __name2(setTarget, "setTarget");
  }
});
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
__name(isWillChangeMotionValue, "isWillChangeMotionValue");
var init_is = __esm({
  "../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_motion_value();
    __name2(isWillChangeMotionValue, "isWillChangeMotionValue");
  }
});
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  }
}
__name(addValueToWillChange, "addValueToWillChange");
var init_add_will_change = __esm({
  "../node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is();
    __name2(addValueToWillChange, "addValueToWillChange");
  }
});
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
__name(getOptimisedAppearId, "getOptimisedAppearId");
var init_get_appear_id = __esm({
  "../node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_data_id();
    __name2(getOptimisedAppearId, "getOptimisedAppearId");
  }
});
var instantAnimationState;
var init_use_instant_transition_state = __esm({
  "../node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    instantAnimationState = {
      current: false
    };
  }
});
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
__name(binarySubdivide, "binarySubdivide");
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = /* @__PURE__ */ __name2((aX) => binarySubdivide(aX, 0, 1, mX1, mX2), "getTForX");
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
__name(cubicBezier, "cubicBezier");
var calcBezier;
var subdivisionPrecision;
var subdivisionMaxIterations;
var init_cubic_bezier = __esm({
  "../node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    calcBezier = /* @__PURE__ */ __name2((t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2, "calcBezier");
    subdivisionPrecision = 1e-7;
    subdivisionMaxIterations = 12;
    __name2(binarySubdivide, "binarySubdivide");
    __name2(cubicBezier, "cubicBezier");
  }
});
var mirrorEasing;
var init_mirror = __esm({
  "../node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    mirrorEasing = /* @__PURE__ */ __name2((easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2, "mirrorEasing");
  }
});
var reverseEasing;
var init_reverse = __esm({
  "../node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    reverseEasing = /* @__PURE__ */ __name2((easing) => (p2) => 1 - easing(1 - p2), "reverseEasing");
  }
});
var backOut;
var backIn;
var backInOut;
var init_back = __esm({
  "../node_modules/framer-motion/dist/es/easing/back.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_cubic_bezier();
    init_mirror();
    init_reverse();
    backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
    backIn = /* @__PURE__ */ reverseEasing(backOut);
    backInOut = /* @__PURE__ */ mirrorEasing(backIn);
  }
});
var anticipate;
var init_anticipate = __esm({
  "../node_modules/framer-motion/dist/es/easing/anticipate.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_back();
    anticipate = /* @__PURE__ */ __name2((p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1))), "anticipate");
  }
});
var circIn;
var circOut;
var circInOut;
var init_circ = __esm({
  "../node_modules/framer-motion/dist/es/easing/circ.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_mirror();
    init_reverse();
    circIn = /* @__PURE__ */ __name2((p2) => 1 - Math.sin(Math.acos(p2)), "circIn");
    circOut = reverseEasing(circIn);
    circInOut = mirrorEasing(circIn);
  }
});
var isZeroValueString;
var init_is_zero_value_string = __esm({
  "../node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isZeroValueString = /* @__PURE__ */ __name2((v2) => /^0[^.\s]+$/u.test(v2), "isZeroValueString");
  }
});
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
__name(isNone, "isNone");
var init_is_none = __esm({
  "../node_modules/framer-motion/dist/es/animation/utils/is-none.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_zero_value_string();
    __name2(isNone, "isNone");
  }
});
var sanitize;
var init_sanitize = __esm({
  "../node_modules/framer-motion/dist/es/value/types/utils/sanitize.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    sanitize = /* @__PURE__ */ __name2((v2) => Math.round(v2 * 1e5) / 1e5, "sanitize");
  }
});
var floatRegex;
var init_float_regex = __esm({
  "../node_modules/framer-motion/dist/es/value/types/utils/float-regex.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  }
});
function isNullish(v2) {
  return v2 == null;
}
__name(isNullish, "isNullish");
var init_is_nullish = __esm({
  "../node_modules/framer-motion/dist/es/value/types/utils/is-nullish.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isNullish, "isNullish");
  }
});
var singleColorRegex;
var init_single_color_regex = __esm({
  "../node_modules/framer-motion/dist/es/value/types/utils/single-color-regex.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
  }
});
var isColorString;
var splitColor;
var init_utils6 = __esm({
  "../node_modules/framer-motion/dist/es/value/types/color/utils.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_float_regex();
    init_is_nullish();
    init_single_color_regex();
    isColorString = /* @__PURE__ */ __name2((type6, testProp) => (v2) => {
      return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type6) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
    }, "isColorString");
    splitColor = /* @__PURE__ */ __name2((aName, bName, cName) => (v2) => {
      if (typeof v2 !== "string")
        return v2;
      const [a2, b2, c2, alpha2] = v2.match(floatRegex);
      return {
        [aName]: parseFloat(a2),
        [bName]: parseFloat(b2),
        [cName]: parseFloat(c2),
        alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
      };
    }, "splitColor");
  }
});
var clampRgbUnit;
var rgbUnit;
var rgba;
var init_rgba = __esm({
  "../node_modules/framer-motion/dist/es/value/types/color/rgba.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_clamp();
    init_numbers();
    init_sanitize();
    init_utils6();
    clampRgbUnit = /* @__PURE__ */ __name2((v2) => clamp(0, 255, v2), "clampRgbUnit");
    rgbUnit = {
      ...number,
      transform: (v2) => Math.round(clampRgbUnit(v2))
    };
    rgba = {
      test: /* @__PURE__ */ isColorString("rgb", "red"),
      parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
      transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
    };
  }
});
function parseHex(v2) {
  let r3 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r3 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a2 = v2.substring(7, 9);
  } else {
    r3 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a2 = v2.substring(4, 5);
    r3 += r3;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r3, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
__name(parseHex, "parseHex");
var hex2;
var init_hex2 = __esm({
  "../node_modules/framer-motion/dist/es/value/types/color/hex.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_rgba();
    init_utils6();
    __name2(parseHex, "parseHex");
    hex2 = {
      test: /* @__PURE__ */ isColorString("#"),
      parse: parseHex,
      transform: rgba.transform
    };
  }
});
var hsla;
var init_hsla = __esm({
  "../node_modules/framer-motion/dist/es/value/types/color/hsla.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_numbers();
    init_units();
    init_sanitize();
    init_utils6();
    hsla = {
      test: /* @__PURE__ */ isColorString("hsl", "hue"),
      parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
      transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
        return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
      }
    };
  }
});
var color;
var init_color = __esm({
  "../node_modules/framer-motion/dist/es/value/types/color/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_hex2();
    init_hsla();
    init_rgba();
    color = {
      test: (v2) => rgba.test(v2) || hex2.test(v2) || hsla.test(v2),
      parse: (v2) => {
        if (rgba.test(v2)) {
          return rgba.parse(v2);
        } else if (hsla.test(v2)) {
          return hsla.parse(v2);
        } else {
          return hex2.parse(v2);
        }
      },
      transform: (v2) => {
        return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
      }
    };
  }
});
var colorRegex;
var init_color_regex = __esm({
  "../node_modules/framer-motion/dist/es/value/types/utils/color-regex.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  }
});
function test(v2) {
  var _a, _b;
  return isNaN(v2) && typeof v2 === "string" && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
__name(test, "test");
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i2 = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i2);
      types.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i2);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i2);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i2;
    return SPLIT_TOKEN;
  });
  const split3 = tokenised.split(SPLIT_TOKEN);
  return { values, split: split3, indexes, types };
}
__name(analyseComplexValue, "analyseComplexValue");
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
__name(parseComplexValue, "parseComplexValue");
function createTransformer(source) {
  const { split: split3, types } = analyseComplexValue(source);
  const numSections = split3.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++) {
      output += split3[i2];
      if (v2[i2] !== void 0) {
        const type6 = types[i2];
        if (type6 === NUMBER_TOKEN) {
          output += sanitize(v2[i2]);
        } else if (type6 === COLOR_TOKEN) {
          output += color.transform(v2[i2]);
        } else {
          output += v2[i2];
        }
      }
    }
    return output;
  };
}
__name(createTransformer, "createTransformer");
function getAnimatableNone(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
__name(getAnimatableNone, "getAnimatableNone");
var NUMBER_TOKEN;
var COLOR_TOKEN;
var VAR_TOKEN;
var VAR_FUNCTION_TOKEN;
var SPLIT_TOKEN;
var complexRegex;
var convertNumbersToZero;
var complex;
var init_complex = __esm({
  "../node_modules/framer-motion/dist/es/value/types/complex/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_color();
    init_color_regex();
    init_float_regex();
    init_sanitize();
    __name2(test, "test");
    NUMBER_TOKEN = "number";
    COLOR_TOKEN = "color";
    VAR_TOKEN = "var";
    VAR_FUNCTION_TOKEN = "var(";
    SPLIT_TOKEN = "${}";
    complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
    __name2(analyseComplexValue, "analyseComplexValue");
    __name2(parseComplexValue, "parseComplexValue");
    __name2(createTransformer, "createTransformer");
    convertNumbersToZero = /* @__PURE__ */ __name2((v2) => typeof v2 === "number" ? 0 : v2, "convertNumbersToZero");
    __name2(getAnimatableNone, "getAnimatableNone");
    complex = {
      test,
      parse: parseComplexValue,
      createTransformer,
      getAnimatableNone
    };
  }
});
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
__name(applyDefaultFilter, "applyDefaultFilter");
var maxDefaults;
var functionRegex;
var filter;
var init_filter = __esm({
  "../node_modules/framer-motion/dist/es/value/types/complex/filter.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_complex();
    init_float_regex();
    maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
    __name2(applyDefaultFilter, "applyDefaultFilter");
    functionRegex = /\b([a-z-]*)\(.*?\)/gu;
    filter = {
      ...complex,
      getAnimatableNone: (v2) => {
        const functions = v2.match(functionRegex);
        return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
      }
    };
  }
});
var defaultValueTypes;
var getDefaultValueType;
var init_defaults = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_color();
    init_filter();
    init_number();
    defaultValueTypes = {
      ...numberValueTypes,
      // Color props
      color,
      backgroundColor: color,
      outlineColor: color,
      fill: color,
      stroke: color,
      // Border props
      borderColor: color,
      borderTopColor: color,
      borderRightColor: color,
      borderBottomColor: color,
      borderLeftColor: color,
      filter,
      WebkitFilter: filter
    };
    getDefaultValueType = /* @__PURE__ */ __name2((key) => defaultValueTypes[key], "getDefaultValueType");
  }
});
function getAnimatableNone2(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
__name(getAnimatableNone2, "getAnimatableNone2");
var init_animatable_none = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_complex();
    init_filter();
    init_defaults();
    __name2(getAnimatableNone2, "getAnimatableNone");
  }
});
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0;
  let animatableTemplate = void 0;
  while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i2];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i2];
    }
    i2++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
    }
  }
}
__name(makeNoneKeyframesAnimatable, "makeNoneKeyframesAnimatable");
var invalidTemplates;
var init_make_none_animatable = __esm({
  "../node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_complex();
    init_animatable_none();
    invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
    __name2(makeNoneKeyframesAnimatable, "makeNoneKeyframesAnimatable");
  }
});
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
__name(removeNonTranslationalTransform, "removeNonTranslationalTransform");
var isNumOrPxType;
var getPosFromMatrix;
var getTranslateFromMatrix;
var transformKeys;
var nonTranslationalTransformKeys;
var positionalValues;
var init_unit_conversion = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_numbers();
    init_units();
    init_keys_transform();
    isNumOrPxType = /* @__PURE__ */ __name2((v2) => v2 === number || v2 === px, "isNumOrPxType");
    getPosFromMatrix = /* @__PURE__ */ __name2((matrix, pos) => parseFloat(matrix.split(", ")[pos]), "getPosFromMatrix");
    getTranslateFromMatrix = /* @__PURE__ */ __name2((pos2, pos3) => (_bbox, { transform }) => {
      if (transform === "none" || !transform)
        return 0;
      const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
      if (matrix3d) {
        return getPosFromMatrix(matrix3d[1], pos3);
      } else {
        const matrix = transform.match(/^matrix\((.+)\)$/u);
        if (matrix) {
          return getPosFromMatrix(matrix[1], pos2);
        } else {
          return 0;
        }
      }
    }, "getTranslateFromMatrix");
    transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
    nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
    __name2(removeNonTranslationalTransform, "removeNonTranslationalTransform");
    positionalValues = {
      // Dimensions
      width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
      height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
      top: (_bbox, { top }) => parseFloat(top),
      left: (_bbox, { left }) => parseFloat(left),
      bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
      right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
      // Transform
      x: getTranslateFromMatrix(4, 13),
      y: getTranslateFromMatrix(5, 14)
    };
    positionalValues.translateX = positionalValues.x;
    positionalValues.translateY = positionalValues.y;
  }
});
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a;
          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete());
  toResolve.clear();
}
__name(measureAllKeyframes, "measureAllKeyframes");
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
__name(readAllKeyframes, "readAllKeyframes");
function flushKeyframeResolvers() {
  readAllKeyframes();
  measureAllKeyframes();
}
__name(flushKeyframeResolvers, "flushKeyframeResolvers");
var toResolve;
var isScheduled;
var anyNeedsMeasurement;
var KeyframeResolver;
var init_KeyframesResolver = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_unit_conversion();
    init_frame();
    toResolve = /* @__PURE__ */ new Set();
    isScheduled = false;
    anyNeedsMeasurement = false;
    __name2(measureAllKeyframes, "measureAllKeyframes");
    __name2(readAllKeyframes, "readAllKeyframes");
    __name2(flushKeyframeResolvers, "flushKeyframeResolvers");
    KeyframeResolver = /* @__PURE__ */ __name(class {
      constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
        this.isComplete = false;
        this.isAsync = false;
        this.needsMeasurement = false;
        this.isScheduled = false;
        this.unresolvedKeyframes = [...unresolvedKeyframes];
        this.onComplete = onComplete;
        this.name = name;
        this.motionValue = motionValue2;
        this.element = element;
        this.isAsync = isAsync;
      }
      scheduleResolve() {
        this.isScheduled = true;
        if (this.isAsync) {
          toResolve.add(this);
          if (!isScheduled) {
            isScheduled = true;
            frame.read(readAllKeyframes);
            frame.resolveKeyframes(measureAllKeyframes);
          }
        } else {
          this.readKeyframes();
          this.complete();
        }
      }
      readKeyframes() {
        const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          if (unresolvedKeyframes[i2] === null) {
            if (i2 === 0) {
              const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();
              const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
              if (currentValue !== void 0) {
                unresolvedKeyframes[0] = currentValue;
              } else if (element && name) {
                const valueAsRead = element.readValue(name, finalKeyframe);
                if (valueAsRead !== void 0 && valueAsRead !== null) {
                  unresolvedKeyframes[0] = valueAsRead;
                }
              }
              if (unresolvedKeyframes[0] === void 0) {
                unresolvedKeyframes[0] = finalKeyframe;
              }
              if (motionValue2 && currentValue === void 0) {
                motionValue2.set(unresolvedKeyframes[0]);
              }
            } else {
              unresolvedKeyframes[i2] = unresolvedKeyframes[i2 - 1];
            }
          }
        }
      }
      setFinalKeyframe() {
      }
      measureInitialState() {
      }
      renderEndStyles() {
      }
      measureEndState() {
      }
      complete() {
        this.isComplete = true;
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
        toResolve.delete(this);
      }
      cancel() {
        if (!this.isComplete) {
          this.isScheduled = false;
          toResolve.delete(this);
        }
      }
      resume() {
        if (!this.isComplete)
          this.scheduleResolve();
      }
    }, "KeyframeResolver");
    __name2(KeyframeResolver, "KeyframeResolver");
  }
});
var isNumericalString;
var init_is_numerical_string = __esm({
  "../node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isNumericalString = /* @__PURE__ */ __name2((v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2), "isNumericalString");
  }
});
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token1, token2, fallback] = match2;
  return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
}
__name(parseCSSVariable, "parseCSSVariable");
function getVariableValue(current, element, depth = 1) {
  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
__name(getVariableValue, "getVariableValue");
var splitCSSVariableRegex;
var maxDepth;
var init_css_variables_conversion = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_is_numerical_string();
    init_is_css_variable();
    splitCSSVariableRegex = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
    __name2(parseCSSVariable, "parseCSSVariable");
    maxDepth = 4;
    __name2(getVariableValue, "getVariableValue");
  }
});
var testValueType;
var init_test = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    testValueType = /* @__PURE__ */ __name2((v2) => (type6) => type6.test(v2), "testValueType");
  }
});
var auto;
var init_type_auto = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    auto = {
      test: (v2) => v2 === "auto",
      parse: (v2) => v2
    };
  }
});
var dimensionValueTypes;
var findDimensionValueType;
var init_dimensions = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_numbers();
    init_units();
    init_test();
    init_type_auto();
    dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
    findDimensionValueType = /* @__PURE__ */ __name2((v2) => dimensionValueTypes.find(testValueType(v2)), "findDimensionValueType");
  }
});
var DOMKeyframesResolver;
var init_DOMKeyframesResolver = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_none();
    init_keys_position();
    init_make_none_animatable();
    init_KeyframesResolver();
    init_css_variables_conversion();
    init_is_css_variable();
    init_unit_conversion();
    init_dimensions();
    DOMKeyframesResolver = /* @__PURE__ */ __name(class extends KeyframeResolver {
      constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
        super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
      }
      readKeyframes() {
        const { unresolvedKeyframes, element, name } = this;
        if (!element || !element.current)
          return;
        super.readKeyframes();
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          let keyframe = unresolvedKeyframes[i2];
          if (typeof keyframe === "string") {
            keyframe = keyframe.trim();
            if (isCSSVariableToken(keyframe)) {
              const resolved = getVariableValue(keyframe, element.current);
              if (resolved !== void 0) {
                unresolvedKeyframes[i2] = resolved;
              }
              if (i2 === unresolvedKeyframes.length - 1) {
                this.finalKeyframe = keyframe;
              }
            }
          }
        }
        this.resolveNoneKeyframes();
        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
          return;
        }
        const [origin, target] = unresolvedKeyframes;
        const originType = findDimensionValueType(origin);
        const targetType = findDimensionValueType(target);
        if (originType === targetType)
          return;
        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
          for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
            const value = unresolvedKeyframes[i2];
            if (typeof value === "string") {
              unresolvedKeyframes[i2] = parseFloat(value);
            }
          }
        } else {
          this.needsMeasurement = true;
        }
      }
      resolveNoneKeyframes() {
        const { unresolvedKeyframes, name } = this;
        const noneKeyframeIndexes = [];
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          if (isNone(unresolvedKeyframes[i2])) {
            noneKeyframeIndexes.push(i2);
          }
        }
        if (noneKeyframeIndexes.length) {
          makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
        }
      }
      measureInitialState() {
        const { element, unresolvedKeyframes, name } = this;
        if (!element || !element.current)
          return;
        if (name === "height") {
          this.suspendedScrollY = window.pageYOffset;
        }
        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        unresolvedKeyframes[0] = this.measuredOrigin;
        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (measureKeyframe !== void 0) {
          element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
        }
      }
      measureEndState() {
        var _a;
        const { element, name, unresolvedKeyframes } = this;
        if (!element || !element.current)
          return;
        const value = element.getValue(name);
        value && value.jump(this.measuredOrigin, false);
        const finalKeyframeIndex = unresolvedKeyframes.length - 1;
        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        if (finalKeyframe !== null && this.finalKeyframe === void 0) {
          this.finalKeyframe = finalKeyframe;
        }
        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
          this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
            element.getValue(unsetTransformName).set(unsetTransformValue);
          });
        }
        this.resolveNoneKeyframes();
      }
    }, "DOMKeyframesResolver");
    __name2(DOMKeyframesResolver, "DOMKeyframesResolver");
  }
});
var isAnimatable;
var init_is_animatable = __esm({
  "../node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_complex();
    isAnimatable = /* @__PURE__ */ __name2((value, name) => {
      if (name === "zIndex")
        return false;
      if (typeof value === "number" || Array.isArray(value))
        return true;
      if (typeof value === "string" && // It's animatable if we have a string
      (complex.test(value) || value === "0") && // And it contains numbers and/or colors
      !value.startsWith("url(")) {
        return true;
      }
      return false;
    }, "isAnimatable");
  }
});
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (keyframes2[i2] !== current)
      return true;
  }
}
__name(hasKeyframesChanged, "hasKeyframesChanged");
function canAnimate(keyframes2, name, type6, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type6 === "spring" || isGenerator(type6)) && velocity;
}
__name(canAnimate, "canAnimate");
var init_can_animate = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_is_animatable();
    __name2(hasKeyframesChanged, "hasKeyframesChanged");
    __name2(canAnimate, "canAnimate");
  }
});
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
}
__name(getFinalKeyframe, "getFinalKeyframe");
var isNotNull;
var init_get_final_keyframe = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isNotNull = /* @__PURE__ */ __name2((value) => value !== null, "isNotNull");
    __name2(getFinalKeyframe, "getFinalKeyframe");
  }
});
var MAX_RESOLVE_DELAY;
var BaseAnimation;
var init_BaseAnimation = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sync_time();
    init_KeyframesResolver();
    init_use_instant_transition_state();
    init_can_animate();
    init_get_final_keyframe();
    MAX_RESOLVE_DELAY = 40;
    BaseAnimation = /* @__PURE__ */ __name(class {
      constructor({ autoplay = true, delay: delay2 = 0, type: type6 = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options2 }) {
        this.isStopped = false;
        this.hasAttemptedResolve = false;
        this.createdAt = time.now();
        this.options = {
          autoplay,
          delay: delay2,
          type: type6,
          repeat,
          repeatDelay,
          repeatType,
          ...options2
        };
        this.updateFinishedPromise();
      }
      /**
       * This method uses the createdAt and resolvedAt to calculate the
       * animation startTime. *Ideally*, we would use the createdAt time as t=0
       * as the following frame would then be the first frame of the animation in
       * progress, which would feel snappier.
       *
       * However, if there's a delay (main thread work) between the creation of
       * the animation and the first commited frame, we prefer to use resolvedAt
       * to avoid a sudden jump into the animation.
       */
      calcStartTime() {
        if (!this.resolvedAt)
          return this.createdAt;
        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;
      }
      /**
       * A getter for resolved data. If keyframes are not yet resolved, accessing
       * this.resolved will synchronously flush all pending keyframe resolvers.
       * This is a deoptimisation, but at its worst still batches read/writes.
       */
      get resolved() {
        if (!this._resolved && !this.hasAttemptedResolve) {
          flushKeyframeResolvers();
        }
        return this._resolved;
      }
      /**
       * A method to be called when the keyframes resolver completes. This method
       * will check if its possible to run the animation and, if not, skip it.
       * Otherwise, it will call initPlayback on the implementing class.
       */
      onKeyframesResolved(keyframes2, finalKeyframe) {
        this.resolvedAt = time.now();
        this.hasAttemptedResolve = true;
        const { name, type: type6, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
        if (!isGenerator2 && !canAnimate(keyframes2, name, type6, velocity)) {
          if (instantAnimationState.current || !delay2) {
            onUpdate && onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
            onComplete && onComplete();
            this.resolveFinishedPromise();
            return;
          } else {
            this.options.duration = 0;
          }
        }
        const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
        if (resolvedAnimation === false)
          return;
        this._resolved = {
          keyframes: keyframes2,
          finalKeyframe,
          ...resolvedAnimation
        };
        this.onPostResolved();
      }
      onPostResolved() {
      }
      /**
       * Allows the returned animation to be awaited or promise-chained. Currently
       * resolves when the animation finishes at all but in a future update could/should
       * reject if its cancels.
       */
      then(resolve, reject) {
        return this.currentFinishedPromise.then(resolve, reject);
      }
      flatten() {
        this.options.type = "keyframes";
        this.options.ease = "linear";
      }
      updateFinishedPromise() {
        this.currentFinishedPromise = new Promise((resolve) => {
          this.resolveFinishedPromise = resolve;
        });
      }
    }, "BaseAnimation");
    __name2(BaseAnimation, "BaseAnimation");
  }
});
var mixNumber;
var init_number2 = __esm({
  "../node_modules/framer-motion/dist/es/utils/mix/number.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    mixNumber = /* @__PURE__ */ __name2((from27, to3, progress2) => {
      return from27 + (to3 - from27) * progress2;
    }, "mixNumber");
  }
});
function hueToRgb(p2, q, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q;
  if (t2 < 2 / 3)
    return p2 + (q - p2) * (2 / 3 - t2) * 6;
  return p2;
}
__name(hueToRgb, "hueToRgb");
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q;
    red = hueToRgb(p2, q, hue + 1 / 3);
    green = hueToRgb(p2, q, hue);
    blue = hueToRgb(p2, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
__name(hslaToRgba, "hslaToRgba");
var init_hsla_to_rgba = __esm({
  "../node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(hueToRgb, "hueToRgb");
    __name2(hslaToRgba, "hslaToRgba");
  }
});
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}
__name(mixImmediate, "mixImmediate");
var init_immediate = __esm({
  "../node_modules/framer-motion/dist/es/utils/mix/immediate.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(mixImmediate, "mixImmediate");
  }
});
function asRGBA(color2) {
  const type6 = getColorType(color2);
  warning(Boolean(type6), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
  if (!Boolean(type6))
    return false;
  let model = type6.parse(color2);
  if (type6 === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
__name(asRGBA, "asRGBA");
var mixLinearColor;
var colorTypes;
var getColorType;
var mixColor;
var init_color2 = __esm({
  "../node_modules/framer-motion/dist/es/utils/mix/color.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_number2();
    init_es();
    init_hsla_to_rgba();
    init_hex2();
    init_rgba();
    init_hsla();
    init_immediate();
    mixLinearColor = /* @__PURE__ */ __name2((from27, to3, v2) => {
      const fromExpo = from27 * from27;
      const expo = v2 * (to3 * to3 - fromExpo) + fromExpo;
      return expo < 0 ? 0 : Math.sqrt(expo);
    }, "mixLinearColor");
    colorTypes = [hex2, rgba, hsla];
    getColorType = /* @__PURE__ */ __name2((v2) => colorTypes.find((type6) => type6.test(v2)), "getColorType");
    __name2(asRGBA, "asRGBA");
    mixColor = /* @__PURE__ */ __name2((from27, to3) => {
      const fromRGBA = asRGBA(from27);
      const toRGBA = asRGBA(to3);
      if (!fromRGBA || !toRGBA) {
        return mixImmediate(from27, to3);
      }
      const blended = { ...fromRGBA };
      return (v2) => {
        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v2);
        return rgba.transform(blended);
      };
    }, "mixColor");
  }
});
var combineFunctions;
var pipe;
var init_pipe = __esm({
  "../node_modules/framer-motion/dist/es/utils/pipe.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    combineFunctions = /* @__PURE__ */ __name2((a2, b2) => (v2) => b2(a2(v2)), "combineFunctions");
    pipe = /* @__PURE__ */ __name2((...transformers) => transformers.reduce(combineFunctions), "pipe");
  }
});
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p2) => p2 <= 0 ? origin : target;
  } else {
    return (p2) => p2 >= 1 ? target : origin;
  }
}
__name(mixVisibility, "mixVisibility");
var invisibleValues;
var init_visibility = __esm({
  "../node_modules/framer-motion/dist/es/utils/mix/visibility.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
    __name2(mixVisibility, "mixVisibility");
  }
});
function mixNumber2(a2, b2) {
  return (p2) => mixNumber(a2, b2, p2);
}
__name(mixNumber2, "mixNumber2");
function getMixer(a2) {
  if (typeof a2 === "number") {
    return mixNumber2;
  } else if (typeof a2 === "string") {
    return isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex;
  } else if (Array.isArray(a2)) {
    return mixArray;
  } else if (typeof a2 === "object") {
    return color.test(a2) ? mixColor : mixObject;
  }
  return mixImmediate;
}
__name(getMixer, "getMixer");
function mixArray(a2, b2) {
  const output = [...a2];
  const numValues = output.length;
  const blendValue = a2.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](p2);
    }
    return output;
  };
}
__name(mixArray, "mixArray");
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 };
  const blendValue = {};
  for (const key in output) {
    if (a2[key] !== void 0 && b2[key] !== void 0) {
      blendValue[key] = getMixer(a2[key])(a2[key], b2[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
}
__name(mixObject, "mixObject");
function matchOrder(origin, target) {
  var _a;
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type6 = target.types[i2];
    const originIndex = origin.indexes[type6][pointers[type6]];
    const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
    orderedOrigin[i2] = originValue;
    pointers[type6]++;
  }
  return orderedOrigin;
}
__name(matchOrder, "matchOrder");
var mixComplex;
var init_complex2 = __esm({
  "../node_modules/framer-motion/dist/es/utils/mix/complex.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_number2();
    init_color2();
    init_pipe();
    init_es();
    init_color();
    init_complex();
    init_is_css_variable();
    init_visibility();
    init_immediate();
    __name2(mixNumber2, "mixNumber");
    __name2(getMixer, "getMixer");
    __name2(mixArray, "mixArray");
    __name2(mixObject, "mixObject");
    __name2(matchOrder, "matchOrder");
    mixComplex = /* @__PURE__ */ __name2((origin, target) => {
      const template = complex.createTransformer(target);
      const originStats = analyseComplexValue(origin);
      const targetStats = analyseComplexValue(target);
      const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
      if (canInterpolate) {
        if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
          return mixVisibility(origin, target);
        }
        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
      } else {
        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
        return mixImmediate(origin, target);
      }
    }, "mixComplex");
  }
});
function mix(from27, to3, p2) {
  if (typeof from27 === "number" && typeof to3 === "number" && typeof p2 === "number") {
    return mixNumber(from27, to3, p2);
  }
  const mixer = getMixer(from27);
  return mixer(from27, to3);
}
__name(mix, "mix");
var init_mix = __esm({
  "../node_modules/framer-motion/dist/es/utils/mix/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_complex2();
    init_number2();
    __name2(mix, "mix");
  }
});
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
__name(calcGeneratorVelocity, "calcGeneratorVelocity");
var velocitySampleDuration;
var init_velocity = __esm({
  "../node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_velocity_per_second();
    velocitySampleDuration = 5;
    __name2(calcGeneratorVelocity, "calcGeneratorVelocity");
  }
});
var springDefaults;
var init_defaults2 = __esm({
  "../node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    springDefaults = {
      // Default spring physics
      stiffness: 100,
      damping: 10,
      mass: 1,
      velocity: 0,
      // Default duration/bounce-based options
      duration: 800,
      // in ms
      bounce: 0.3,
      visualDuration: 0.3,
      // in seconds
      // Rest thresholds
      restSpeed: {
        granular: 0.01,
        default: 2
      },
      restDelta: {
        granular: 5e-3,
        default: 0.5
      },
      // Limits
      minDuration: 0.01,
      // in seconds
      maxDuration: 10,
      // in seconds
      minDamping: 0.05,
      maxDamping: 1
    };
  }
});
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = /* @__PURE__ */ __name2((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    }, "envelope");
    derivative = /* @__PURE__ */ __name2((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    }, "derivative");
  } else {
    envelope = /* @__PURE__ */ __name2((undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    }, "envelope");
    derivative = /* @__PURE__ */ __name2((undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    }, "derivative");
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
__name(findSpring, "findSpring");
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
__name(approximateRoot, "approximateRoot");
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
__name(calcAngularFreq, "calcAngularFreq");
var safeMin;
var rootIterations;
var init_find = __esm({
  "../node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_clamp();
    init_defaults2();
    safeMin = 1e-3;
    __name2(findSpring, "findSpring");
    rootIterations = 12;
    __name2(approximateRoot, "approximateRoot");
    __name2(calcAngularFreq, "calcAngularFreq");
  }
});
function isSpringType(options2, keys) {
  return keys.some((key) => options2[key] !== void 0);
}
__name(isSpringType, "isSpringType");
function getSpringOptions(options2) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options2
  };
  if (!isSpringType(options2, physicsKeys) && isSpringType(options2, durationKeys)) {
    if (options2.visualDuration) {
      const visualDuration = options2.visualDuration;
      const root = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp(0.05, 1, 1 - (options2.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options2);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
__name(getSpringOptions, "getSpringOptions");
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options2 = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options2;
  const origin = options2.keyframes[0];
  const target = options2.keyframes[options2.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options2,
    velocity: -millisecondsToSeconds(options2.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = /* @__PURE__ */ __name2((t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    }, "resolveSpring");
  } else if (dampingRatio === 1) {
    resolveSpring = /* @__PURE__ */ __name2((t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2), "resolveSpring");
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = /* @__PURE__ */ __name2((t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    }, "resolveSpring");
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = 0;
        if (dampingRatio < 1) {
          currentVelocity = t2 === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    }
  };
  return generator;
}
__name(spring, "spring");
var durationKeys;
var physicsKeys;
var init_spring = __esm({
  "../node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_clamp();
    init_velocity();
    init_defaults2();
    init_find();
    durationKeys = ["duration", "bounce"];
    physicsKeys = ["stiffness", "damping", "mass"];
    __name2(isSpringType, "isSpringType");
    __name2(getSpringOptions, "getSpringOptions");
    __name2(spring, "spring");
  }
});
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = /* @__PURE__ */ __name2((v2) => min !== void 0 && v2 < min || max !== void 0 && v2 > max, "isOutOfBounds");
  const nearestBoundary = /* @__PURE__ */ __name2((v2) => {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
  }, "nearestBoundary");
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = /* @__PURE__ */ __name2((t2) => -amplitude * Math.exp(-t2 / timeConstant), "calcDelta");
  const calcLatest = /* @__PURE__ */ __name2((t2) => target + calcDelta(t2), "calcLatest");
  const applyFriction = /* @__PURE__ */ __name2((t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  }, "applyFriction");
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = /* @__PURE__ */ __name2((t2) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  }, "checkCatchBoundary");
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state;
      }
    }
  };
}
__name(inertia, "inertia");
var init_inertia = __esm({
  "../node_modules/framer-motion/dist/es/animation/generators/inertia.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_spring();
    init_velocity();
    __name2(inertia, "inertia");
  }
});
var easeIn;
var easeOut;
var easeInOut;
var init_ease = __esm({
  "../node_modules/framer-motion/dist/es/easing/ease.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_cubic_bezier();
    easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
    easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
    easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
  }
});
var isEasingArray;
var init_is_easing_array = __esm({
  "../node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    isEasingArray = /* @__PURE__ */ __name2((ease2) => {
      return Array.isArray(ease2) && typeof ease2[0] !== "number";
    }, "isEasingArray");
  }
});
var easingLookup;
var easingDefinitionToFunction;
var init_map = __esm({
  "../node_modules/framer-motion/dist/es/easing/utils/map.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_anticipate();
    init_back();
    init_circ();
    init_cubic_bezier();
    init_ease();
    easingLookup = {
      linear: noop,
      easeIn,
      easeInOut,
      easeOut,
      circIn,
      circInOut,
      circOut,
      backIn,
      backInOut,
      backOut,
      anticipate
    };
    easingDefinitionToFunction = /* @__PURE__ */ __name2((definition) => {
      if (isBezierDefinition(definition)) {
        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
        const [x1, y1, x2, y2] = definition;
        return cubicBezier(x1, y1, x2, y2);
      } else if (typeof definition === "string") {
        invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
        return easingLookup[definition];
      }
      return definition;
    }, "easingDefinitionToFunction");
  }
});
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || mix;
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
__name(createMixers, "createMixers");
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = /* @__PURE__ */ __name2((v2) => {
    if (isZeroDeltaRange && v2 < input[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  }, "interpolator");
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
__name(interpolate, "interpolate");
var init_interpolate = __esm({
  "../node_modules/framer-motion/dist/es/utils/interpolate.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_clamp();
    init_mix();
    init_pipe();
    __name2(createMixers, "createMixers");
    __name2(interpolate, "interpolate");
  }
});
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = progress(0, remaining, i2);
    offset.push(mixNumber(min, 1, offsetProgress));
  }
}
__name(fillOffset, "fillOffset");
var init_fill = __esm({
  "../node_modules/framer-motion/dist/es/utils/offsets/fill.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_number2();
    __name2(fillOffset, "fillOffset");
  }
});
function defaultOffset(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
__name(defaultOffset, "defaultOffset");
var init_default = __esm({
  "../node_modules/framer-motion/dist/es/utils/offsets/default.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_fill();
    __name2(defaultOffset, "defaultOffset");
  }
});
function convertOffsetToTimes(offset, duration) {
  return offset.map((o2) => o2 * duration);
}
__name(convertOffsetToTimes, "convertOffsetToTimes");
var init_time = __esm({
  "../node_modules/framer-motion/dist/es/utils/offsets/time.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(convertOffsetToTimes, "convertOffsetToTimes");
  }
});
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
__name(defaultEasing, "defaultEasing");
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => {
      state.value = mapTimeToKeyframe(t2);
      state.done = t2 >= duration;
      return state;
    }
  };
}
__name(keyframes, "keyframes");
var init_keyframes = __esm({
  "../node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_ease();
    init_is_easing_array();
    init_map();
    init_interpolate();
    init_default();
    init_time();
    __name2(defaultEasing, "defaultEasing");
    __name2(keyframes, "keyframes");
  }
});
var frameloopDriver;
var init_driver_frameloop = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sync_time();
    init_frame();
    frameloopDriver = /* @__PURE__ */ __name2((update) => {
      const passTimestamp = /* @__PURE__ */ __name2(({ timestamp }) => update(timestamp), "passTimestamp");
      return {
        start: () => frame.update(passTimestamp, true),
        stop: () => cancelFrame(passTimestamp),
        /**
         * If we're processing this frame we can use the
         * framelocked timestamp to keep things in sync.
         */
        now: () => frameData.isProcessing ? frameData.timestamp : time.now()
      };
    }, "frameloopDriver");
  }
});
var generators;
var percentToProgress;
var MainThreadAnimation;
var init_MainThreadAnimation = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_KeyframesResolver();
    init_clamp();
    init_mix();
    init_pipe();
    init_inertia();
    init_keyframes();
    init_spring();
    init_BaseAnimation();
    init_driver_frameloop();
    init_get_final_keyframe();
    generators = {
      decay: inertia,
      inertia,
      tween: keyframes,
      keyframes,
      spring
    };
    percentToProgress = /* @__PURE__ */ __name2((percent2) => percent2 / 100, "percentToProgress");
    MainThreadAnimation = /* @__PURE__ */ __name(class extends BaseAnimation {
      constructor(options2) {
        super(options2);
        this.holdTime = null;
        this.cancelTime = null;
        this.currentTime = 0;
        this.playbackSpeed = 1;
        this.pendingPlayState = "running";
        this.startTime = null;
        this.state = "idle";
        this.stop = () => {
          this.resolver.cancel();
          this.isStopped = true;
          if (this.state === "idle")
            return;
          this.teardown();
          const { onStop } = this.options;
          onStop && onStop();
        };
        const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
        const onResolved = /* @__PURE__ */ __name2((resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), "onResolved");
        this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element);
        this.resolver.scheduleResolve();
      }
      flatten() {
        super.flatten();
        if (this._resolved) {
          Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
        }
      }
      initPlayback(keyframes$1) {
        const { type: type6 = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
        const generatorFactory = isGenerator(type6) ? type6 : generators[type6] || keyframes;
        let mapPercentToKeyframes;
        let mirroredGenerator;
        if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
          if (true) {
            invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
          }
          mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
          keyframes$1 = [0, 100];
        }
        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
        if (repeatType === "mirror") {
          mirroredGenerator = generatorFactory({
            ...this.options,
            keyframes: [...keyframes$1].reverse(),
            velocity: -velocity
          });
        }
        if (generator.calculatedDuration === null) {
          generator.calculatedDuration = calcGeneratorDuration(generator);
        }
        const { calculatedDuration } = generator;
        const resolvedDuration = calculatedDuration + repeatDelay;
        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
        return {
          generator,
          mirroredGenerator,
          mapPercentToKeyframes,
          calculatedDuration,
          resolvedDuration,
          totalDuration
        };
      }
      onPostResolved() {
        const { autoplay = true } = this.options;
        this.play();
        if (this.pendingPlayState === "paused" || !autoplay) {
          this.pause();
        } else {
          this.state = this.pendingPlayState;
        }
      }
      tick(timestamp, sample = false) {
        const { resolved } = this;
        if (!resolved) {
          const { keyframes: keyframes3 } = this.options;
          return { done: true, value: keyframes3[keyframes3.length - 1] };
        }
        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
        if (this.startTime === null)
          return generator.next(0);
        const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
        if (this.speed > 0) {
          this.startTime = Math.min(this.startTime, timestamp);
        } else if (this.speed < 0) {
          this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
        }
        if (sample) {
          this.currentTime = timestamp;
        } else if (this.holdTime !== null) {
          this.currentTime = this.holdTime;
        } else {
          this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
        }
        const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
        const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
        this.currentTime = Math.max(timeWithoutDelay, 0);
        if (this.state === "finished" && this.holdTime === null) {
          this.currentTime = totalDuration;
        }
        let elapsed = this.currentTime;
        let frameGenerator = generator;
        if (repeat) {
          const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
          let currentIteration = Math.floor(progress2);
          let iterationProgress = progress2 % 1;
          if (!iterationProgress && progress2 >= 1) {
            iterationProgress = 1;
          }
          iterationProgress === 1 && currentIteration--;
          currentIteration = Math.min(currentIteration, repeat + 1);
          const isOddIteration = Boolean(currentIteration % 2);
          if (isOddIteration) {
            if (repeatType === "reverse") {
              iterationProgress = 1 - iterationProgress;
              if (repeatDelay) {
                iterationProgress -= repeatDelay / resolvedDuration;
              }
            } else if (repeatType === "mirror") {
              frameGenerator = mirroredGenerator;
            }
          }
          elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
        }
        const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
        if (mapPercentToKeyframes) {
          state.value = mapPercentToKeyframes(state.value);
        }
        let { done } = state;
        if (!isInDelayPhase && calculatedDuration !== null) {
          done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
        }
        const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
        if (isAnimationFinished && finalKeyframe !== void 0) {
          state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
        }
        if (onUpdate) {
          onUpdate(state.value);
        }
        if (isAnimationFinished) {
          this.finish();
        }
        return state;
      }
      get duration() {
        const { resolved } = this;
        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
      }
      get time() {
        return millisecondsToSeconds(this.currentTime);
      }
      set time(newTime) {
        newTime = secondsToMilliseconds(newTime);
        this.currentTime = newTime;
        if (this.holdTime !== null || this.speed === 0) {
          this.holdTime = newTime;
        } else if (this.driver) {
          this.startTime = this.driver.now() - newTime / this.speed;
        }
      }
      get speed() {
        return this.playbackSpeed;
      }
      set speed(newSpeed) {
        const hasChanged = this.playbackSpeed !== newSpeed;
        this.playbackSpeed = newSpeed;
        if (hasChanged) {
          this.time = millisecondsToSeconds(this.currentTime);
        }
      }
      play() {
        if (!this.resolver.isScheduled) {
          this.resolver.resume();
        }
        if (!this._resolved) {
          this.pendingPlayState = "running";
          return;
        }
        if (this.isStopped)
          return;
        const { driver = frameloopDriver, onPlay, startTime } = this.options;
        if (!this.driver) {
          this.driver = driver((timestamp) => this.tick(timestamp));
        }
        onPlay && onPlay();
        const now2 = this.driver.now();
        if (this.holdTime !== null) {
          this.startTime = now2 - this.holdTime;
        } else if (!this.startTime) {
          this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
        } else if (this.state === "finished") {
          this.startTime = now2;
        }
        if (this.state === "finished") {
          this.updateFinishedPromise();
        }
        this.cancelTime = this.startTime;
        this.holdTime = null;
        this.state = "running";
        this.driver.start();
      }
      pause() {
        var _a;
        if (!this._resolved) {
          this.pendingPlayState = "paused";
          return;
        }
        this.state = "paused";
        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
      }
      complete() {
        if (this.state !== "running") {
          this.play();
        }
        this.pendingPlayState = this.state = "finished";
        this.holdTime = null;
      }
      finish() {
        this.teardown();
        this.state = "finished";
        const { onComplete } = this.options;
        onComplete && onComplete();
      }
      cancel() {
        if (this.cancelTime !== null) {
          this.tick(this.cancelTime);
        }
        this.teardown();
        this.updateFinishedPromise();
      }
      teardown() {
        this.state = "idle";
        this.stopDriver();
        this.resolveFinishedPromise();
        this.updateFinishedPromise();
        this.startTime = this.cancelTime = null;
        this.resolver.cancel();
      }
      stopDriver() {
        if (!this.driver)
          return;
        this.driver.stop();
        this.driver = void 0;
      }
      sample(time2) {
        this.startTime = 0;
        return this.tick(time2, true);
      }
    }, "MainThreadAnimation");
    __name2(MainThreadAnimation, "MainThreadAnimation");
  }
});
var acceleratedValues;
var init_accelerated_values = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    acceleratedValues = /* @__PURE__ */ new Set([
      "opacity",
      "clipPath",
      "filter",
      "transform"
      // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
      // or until we implement support for linear() easing.
      // "background-color"
    ]);
  }
});
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
__name(startWaapiAnimation, "startWaapiAnimation");
var init_waapi = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    __name2(startWaapiAnimation, "startWaapiAnimation");
  }
});
var supportsWaapi;
var init_supports_waapi = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    supportsWaapi = /* @__PURE__ */ memo2(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  }
});
function requiresPregeneratedKeyframes(options2) {
  return isGenerator(options2.type) || options2.type === "spring" || !isWaapiSupportedEasing(options2.ease);
}
__name(requiresPregeneratedKeyframes, "requiresPregeneratedKeyframes");
function pregenerateKeyframes(keyframes2, options2) {
  const sampleAnimation = new MainThreadAnimation({
    ...options2,
    keyframes: keyframes2,
    repeat: 0,
    delay: 0,
    isGenerator: true
  });
  let state = { done: false, value: keyframes2[0] };
  const pregeneratedKeyframes = [];
  let t2 = 0;
  while (!state.done && t2 < maxDuration) {
    state = sampleAnimation.sample(t2);
    pregeneratedKeyframes.push(state.value);
    t2 += sampleDelta;
  }
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t2 - sampleDelta,
    ease: "linear"
  };
}
__name(pregenerateKeyframes, "pregenerateKeyframes");
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
__name(isUnsupportedEase, "isUnsupportedEase");
var sampleDelta;
var maxDuration;
var unsupportedEasingFunctions;
var AcceleratedAnimation;
var init_AcceleratedAnimation = __esm({
  "../node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_anticipate();
    init_back();
    init_circ();
    init_DOMKeyframesResolver();
    init_BaseAnimation();
    init_MainThreadAnimation();
    init_accelerated_values();
    init_waapi();
    init_get_final_keyframe();
    init_supports_waapi();
    sampleDelta = 10;
    maxDuration = 2e4;
    __name2(requiresPregeneratedKeyframes, "requiresPregeneratedKeyframes");
    __name2(pregenerateKeyframes, "pregenerateKeyframes");
    unsupportedEasingFunctions = {
      anticipate,
      backInOut,
      circInOut
    };
    __name2(isUnsupportedEase, "isUnsupportedEase");
    AcceleratedAnimation = /* @__PURE__ */ __name(class extends BaseAnimation {
      constructor(options2) {
        super(options2);
        const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
        this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element);
        this.resolver.scheduleResolve();
      }
      initPlayback(keyframes2, finalKeyframe) {
        let { duration = 300, times, ease: ease2, type: type6, motionValue: motionValue2, name, startTime } = this.options;
        if (!motionValue2.owner || !motionValue2.owner.current) {
          return false;
        }
        if (typeof ease2 === "string" && supportsLinearEasing() && isUnsupportedEase(ease2)) {
          ease2 = unsupportedEasingFunctions[ease2];
        }
        if (requiresPregeneratedKeyframes(this.options)) {
          const { onComplete, onUpdate, motionValue: motionValue3, element, ...options2 } = this.options;
          const pregeneratedAnimation = pregenerateKeyframes(keyframes2, options2);
          keyframes2 = pregeneratedAnimation.keyframes;
          if (keyframes2.length === 1) {
            keyframes2[1] = keyframes2[0];
          }
          duration = pregeneratedAnimation.duration;
          times = pregeneratedAnimation.times;
          ease2 = pregeneratedAnimation.ease;
          type6 = "keyframes";
        }
        const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
        if (this.pendingTimeline) {
          attachTimeline(animation, this.pendingTimeline);
          this.pendingTimeline = void 0;
        } else {
          animation.onfinish = () => {
            const { onComplete } = this.options;
            motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
            onComplete && onComplete();
            this.cancel();
            this.resolveFinishedPromise();
          };
        }
        return {
          animation,
          duration,
          times,
          type: type6,
          ease: ease2,
          keyframes: keyframes2
        };
      }
      get duration() {
        const { resolved } = this;
        if (!resolved)
          return 0;
        const { duration } = resolved;
        return millisecondsToSeconds(duration);
      }
      get time() {
        const { resolved } = this;
        if (!resolved)
          return 0;
        const { animation } = resolved;
        return millisecondsToSeconds(animation.currentTime || 0);
      }
      set time(newTime) {
        const { resolved } = this;
        if (!resolved)
          return;
        const { animation } = resolved;
        animation.currentTime = secondsToMilliseconds(newTime);
      }
      get speed() {
        const { resolved } = this;
        if (!resolved)
          return 1;
        const { animation } = resolved;
        return animation.playbackRate;
      }
      set speed(newSpeed) {
        const { resolved } = this;
        if (!resolved)
          return;
        const { animation } = resolved;
        animation.playbackRate = newSpeed;
      }
      get state() {
        const { resolved } = this;
        if (!resolved)
          return "idle";
        const { animation } = resolved;
        return animation.playState;
      }
      get startTime() {
        const { resolved } = this;
        if (!resolved)
          return null;
        const { animation } = resolved;
        return animation.startTime;
      }
      /**
       * Replace the default DocumentTimeline with another AnimationTimeline.
       * Currently used for scroll animations.
       */
      attachTimeline(timeline) {
        if (!this._resolved) {
          this.pendingTimeline = timeline;
        } else {
          const { resolved } = this;
          if (!resolved)
            return noop;
          const { animation } = resolved;
          attachTimeline(animation, timeline);
        }
        return noop;
      }
      play() {
        if (this.isStopped)
          return;
        const { resolved } = this;
        if (!resolved)
          return;
        const { animation } = resolved;
        if (animation.playState === "finished") {
          this.updateFinishedPromise();
        }
        animation.play();
      }
      pause() {
        const { resolved } = this;
        if (!resolved)
          return;
        const { animation } = resolved;
        animation.pause();
      }
      stop() {
        this.resolver.cancel();
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.resolveFinishedPromise();
        this.updateFinishedPromise();
        const { resolved } = this;
        if (!resolved)
          return;
        const { animation, keyframes: keyframes2, duration, type: type6, ease: ease2, times } = resolved;
        if (animation.playState === "idle" || animation.playState === "finished") {
          return;
        }
        if (this.time) {
          const { motionValue: motionValue2, onUpdate, onComplete, element, ...options2 } = this.options;
          const sampleAnimation = new MainThreadAnimation({
            ...options2,
            keyframes: keyframes2,
            duration,
            type: type6,
            ease: ease2,
            times,
            isGenerator: true
          });
          const sampleTime = secondsToMilliseconds(this.time);
          motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
        }
        const { onStop } = this.options;
        onStop && onStop();
        this.cancel();
      }
      complete() {
        const { resolved } = this;
        if (!resolved)
          return;
        resolved.animation.finish();
      }
      cancel() {
        const { resolved } = this;
        if (!resolved)
          return;
        resolved.animation.cancel();
      }
      static supports(options2) {
        const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type: type6 } = options2;
        if (!motionValue2 || !motionValue2.owner || !(motionValue2.owner.current instanceof HTMLElement)) {
          return false;
        }
        const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
        return supportsWaapi() && name && acceleratedValues.has(name) && /**
        * If we're outputting values to onUpdate then we can't use WAAPI as there's
        * no way to read the value from WAAPI every frame.
        */
        !onUpdate && !transformTemplate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type6 !== "inertia";
      }
    }, "AcceleratedAnimation");
    __name2(AcceleratedAnimation, "AcceleratedAnimation");
  }
});
var underDampedSpring;
var criticallyDampedSpring;
var keyframesTransition;
var ease;
var getDefaultTransition;
var init_default_transitions = __esm({
  "../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_keys_transform();
    underDampedSpring = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    };
    criticallyDampedSpring = /* @__PURE__ */ __name2((target) => ({
      type: "spring",
      stiffness: 550,
      damping: target === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    }), "criticallyDampedSpring");
    keyframesTransition = {
      type: "keyframes",
      duration: 0.8
    };
    ease = {
      type: "keyframes",
      ease: [0.25, 0.1, 0.35, 1],
      duration: 0.3
    };
    getDefaultTransition = /* @__PURE__ */ __name2((valueKey, { keyframes: keyframes2 }) => {
      if (keyframes2.length > 2) {
        return keyframesTransition;
      } else if (transformProps.has(valueKey)) {
        return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
      }
      return ease;
    }, "getDefaultTransition");
  }
});
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from27, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
__name(isTransitionDefined, "isTransitionDefined");
var init_is_transition_defined = __esm({
  "../node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isTransitionDefined, "isTransitionDefined");
  }
});
var animateMotionValue;
var init_motion_value = __esm({
  "../node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_frame();
    init_GlobalConfig();
    init_use_instant_transition_state();
    init_AcceleratedAnimation();
    init_MainThreadAnimation();
    init_get_final_keyframe();
    init_default_transitions();
    init_is_transition_defined();
    animateMotionValue = /* @__PURE__ */ __name2((name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
      const valueTransition = getValueTransition(transition, name) || {};
      const delay2 = valueTransition.delay || transition.delay || 0;
      let { elapsed = 0 } = transition;
      elapsed = elapsed - secondsToMilliseconds(delay2);
      let options2 = {
        keyframes: Array.isArray(target) ? target : [null, target],
        ease: "easeOut",
        velocity: value.getVelocity(),
        ...valueTransition,
        delay: -elapsed,
        onUpdate: (v2) => {
          value.set(v2);
          valueTransition.onUpdate && valueTransition.onUpdate(v2);
        },
        onComplete: () => {
          onComplete();
          valueTransition.onComplete && valueTransition.onComplete();
        },
        name,
        motionValue: value,
        element: isHandoff ? void 0 : element
      };
      if (!isTransitionDefined(valueTransition)) {
        options2 = {
          ...options2,
          ...getDefaultTransition(name, options2)
        };
      }
      if (options2.duration) {
        options2.duration = secondsToMilliseconds(options2.duration);
      }
      if (options2.repeatDelay) {
        options2.repeatDelay = secondsToMilliseconds(options2.repeatDelay);
      }
      if (options2.from !== void 0) {
        options2.keyframes[0] = options2.from;
      }
      let shouldSkip = false;
      if (options2.type === false || options2.duration === 0 && !options2.repeatDelay) {
        options2.duration = 0;
        if (options2.delay === 0) {
          shouldSkip = true;
        }
      }
      if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {
        shouldSkip = true;
        options2.duration = 0;
        options2.delay = 0;
      }
      if (shouldSkip && !isHandoff && value.get() !== void 0) {
        const finalKeyframe = getFinalKeyframe(options2.keyframes, valueTransition);
        if (finalKeyframe !== void 0) {
          frame.update(() => {
            options2.onUpdate(finalKeyframe);
            options2.onComplete();
          });
          return new GroupPlaybackControls([]);
        }
      }
      if (!isHandoff && AcceleratedAnimation.supports(options2)) {
        return new AcceleratedAnimation(options2);
      } else {
        return new MainThreadAnimation(options2);
      }
    }, "animateMotionValue");
  }
});
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
__name(shouldBlockAnimation, "shouldBlockAnimation");
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type: type6 } = {}) {
  var _a;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type6 && visualElement.animationState && visualElement.animationState.getState()[type6];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key)
    };
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
__name(animateTarget, "animateTarget");
var init_visual_element_target = __esm({
  "../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_keys_position();
    init_setters();
    init_add_will_change();
    init_get_appear_id();
    init_motion_value();
    init_frame();
    __name2(shouldBlockAnimation, "shouldBlockAnimation");
    __name2(animateTarget, "animateTarget");
  }
});
function animateVariant(visualElement, variant, options2 = {}) {
  var _a;
  const resolved = resolveVariant(visualElement, variant, options2.type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options2.transitionOverride) {
    transition = options2.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options2)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options2);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options2.delay)]);
  }
}
__name(animateVariant, "animateVariant");
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options2) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options2,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
__name(animateChildren, "animateChildren");
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
__name(sortByTreeOrder, "sortByTreeOrder");
var init_visual_element_variant = __esm({
  "../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_resolve_dynamic_variants();
    init_visual_element_target();
    __name2(animateVariant, "animateVariant");
    __name2(animateChildren, "animateChildren");
    __name2(sortByTreeOrder, "sortByTreeOrder");
  }
});
function animateVisualElement(visualElement, definition, options2 = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options2));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options2);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options2.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options2));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
__name(animateVisualElement, "animateVisualElement");
var init_visual_element = __esm({
  "../node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_resolve_dynamic_variants();
    init_visual_element_target();
    init_visual_element_variant();
    __name2(animateVisualElement, "animateVisualElement");
  }
});
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
__name(getVariantContext, "getVariantContext");
var numVariantProps;
var init_get_variant_context = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_variant_label();
    init_variant_props();
    numVariantProps = variantProps.length;
    __name2(getVariantContext, "getVariantContext");
  }
});
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options: options2 }) => animateVisualElement(visualElement, animation, options2)));
}
__name(animateList, "animateList");
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = /* @__PURE__ */ __name2((type6) => (acc, definition) => {
    var _a;
    const resolved = resolveVariant(visualElement, definition, type6 === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  }, "buildResolvedTypeValues");
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  __name(setAnimateFunction, "setAnimateFunction");
  __name2(setAnimateFunction, "setAnimateFunction");
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type6 = reversePriorityOrder[i2];
      const typeState = state[type6];
      const prop = props[type6] !== void 0 ? props[type6] : context[type6];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type6 === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type6] && prop !== props[type6] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type6 === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type6), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = /* @__PURE__ */ __name2((key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      }, "markToAnimate");
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0 && next !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type: type6 }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  __name(animateChanges, "animateChanges");
  __name2(animateChanges, "animateChanges");
  function setActive(type6, isActive) {
    var _a;
    if (state[type6].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type6, isActive);
    });
    state[type6].isActive = isActive;
    const animations2 = animateChanges(type6);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  __name(setActive, "setActive");
  __name2(setActive, "setActive");
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
__name(createAnimationState, "createAnimationState");
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
__name(checkVariantsDidChange, "checkVariantsDidChange");
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
__name(createTypeState, "createTypeState");
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
__name(createState, "createState");
var reversePriorityOrder;
var numAnimationTypes;
var init_animation_state = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_animation_controls();
    init_is_keyframes_target();
    init_shallow_compare();
    init_is_variant_label();
    init_resolve_dynamic_variants();
    init_variant_props();
    init_visual_element();
    init_get_variant_context();
    reversePriorityOrder = [...variantPriorityOrder].reverse();
    numAnimationTypes = variantPriorityOrder.length;
    __name2(animateList, "animateList");
    __name2(createAnimationState, "createAnimationState");
    __name2(checkVariantsDidChange, "checkVariantsDidChange");
    __name2(createTypeState, "createTypeState");
    __name2(createState, "createState");
  }
});
var Feature;
var init_Feature = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/Feature.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    Feature = /* @__PURE__ */ __name(class {
      constructor(node) {
        this.isMounted = false;
        this.node = node;
      }
      update() {
      }
    }, "Feature");
    __name2(Feature, "Feature");
  }
});
var AnimationFeature;
var init_animation = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/animation/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_animation_controls();
    init_animation_state();
    init_Feature();
    AnimationFeature = /* @__PURE__ */ __name(class extends Feature {
      /**
       * We dynamically generate the AnimationState manager as it contains a reference
       * to the underlying animation library. We only want to load that if we load this,
       * so people can optionally code split it out using the `m` component.
       */
      constructor(node) {
        super(node);
        node.animationState || (node.animationState = createAnimationState(node));
      }
      updateAnimationControlsSubscription() {
        const { animate } = this.node.getProps();
        if (isAnimationControls(animate)) {
          this.unmountControls = animate.subscribe(this.node);
        }
      }
      /**
       * Subscribe any provided AnimationControls to the component's VisualElement
       */
      mount() {
        this.updateAnimationControlsSubscription();
      }
      update() {
        const { animate } = this.node.getProps();
        const { animate: prevAnimate } = this.node.prevProps || {};
        if (animate !== prevAnimate) {
          this.updateAnimationControlsSubscription();
        }
      }
      unmount() {
        var _a;
        this.node.animationState.reset();
        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
      }
    }, "AnimationFeature");
    __name2(AnimationFeature, "AnimationFeature");
  }
});
var id;
var ExitAnimationFeature;
var init_exit = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Feature();
    id = 0;
    ExitAnimationFeature = /* @__PURE__ */ __name(class extends Feature {
      constructor() {
        super(...arguments);
        this.id = id++;
      }
      update() {
        if (!this.node.presenceContext)
          return;
        const { isPresent, onExitComplete } = this.node.presenceContext;
        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || isPresent === prevIsPresent) {
          return;
        }
        const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
        if (onExitComplete && !isPresent) {
          exitAnimation.then(() => onExitComplete(this.id));
        }
      }
      mount() {
        const { register } = this.node.presenceContext || {};
        if (register) {
          this.unmount = register(this.id);
        }
      }
      unmount() {
      }
    }, "ExitAnimationFeature");
    __name2(ExitAnimationFeature, "ExitAnimationFeature");
  }
});
var animations;
var init_animations = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/animations.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_animation();
    init_exit();
    animations = {
      animation: {
        Feature: AnimationFeature
      },
      exit: {
        Feature: ExitAnimationFeature
      }
    };
  }
});
function addDomEvent(target, eventName, handler, options2 = { passive: true }) {
  target.addEventListener(eventName, handler, options2);
  return () => target.removeEventListener(eventName, handler);
}
__name(addDomEvent, "addDomEvent");
var init_add_dom_event = __esm({
  "../node_modules/framer-motion/dist/es/events/add-dom-event.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(addDomEvent, "addDomEvent");
  }
});
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
__name(extractEventInfo, "extractEventInfo");
var addPointerInfo;
var init_event_info = __esm({
  "../node_modules/framer-motion/dist/es/events/event-info.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    __name2(extractEventInfo, "extractEventInfo");
    addPointerInfo = /* @__PURE__ */ __name2((handler) => {
      return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
    }, "addPointerInfo");
  }
});
function addPointerEvent(target, eventName, handler, options2) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options2);
}
__name(addPointerEvent, "addPointerEvent");
var init_add_pointer_event = __esm({
  "../node_modules/framer-motion/dist/es/events/add-pointer-event.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_add_dom_event();
    init_event_info();
    __name2(addPointerEvent, "addPointerEvent");
  }
});
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x);
  const yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
__name(distance2D, "distance2D");
var distance;
var init_distance = __esm({
  "../node_modules/framer-motion/dist/es/utils/distance.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    distance = /* @__PURE__ */ __name2((a2, b2) => Math.abs(a2 - b2), "distance");
    __name2(distance2D, "distance2D");
  }
});
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
__name(transformPoint, "transformPoint");
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
__name(subtractPoint, "subtractPoint");
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
__name(getPanInfo, "getPanInfo");
function startDevicePoint(history) {
  return history[0];
}
__name(startDevicePoint, "startDevicePoint");
function lastDevicePoint(history) {
  return history[history.length - 1];
}
__name(lastDevicePoint, "lastDevicePoint");
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
__name(getVelocity, "getVelocity");
var PanSession;
var init_PanSession = __esm({
  "../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_add_pointer_event();
    init_event_info();
    init_distance();
    init_pipe();
    init_frame();
    PanSession = /* @__PURE__ */ __name(class {
      constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
        this.startEvent = null;
        this.lastMoveEvent = null;
        this.lastMoveEventInfo = null;
        this.handlers = {};
        this.contextWindow = window;
        this.updatePoint = () => {
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
          const isPanStarted = this.startEvent !== null;
          const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
          if (!isPanStarted && !isDistancePastThreshold)
            return;
          const { point: point2 } = info2;
          const { timestamp: timestamp2 } = frameData;
          this.history.push({ ...point2, timestamp: timestamp2 });
          const { onStart, onMove } = this.handlers;
          if (!isPanStarted) {
            onStart && onStart(this.lastMoveEvent, info2);
            this.startEvent = this.lastMoveEvent;
          }
          onMove && onMove(this.lastMoveEvent, info2);
        };
        this.handlePointerMove = (event2, info2) => {
          this.lastMoveEvent = event2;
          this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
          frame.update(this.updatePoint, true);
        };
        this.handlePointerUp = (event2, info2) => {
          this.end();
          const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
          if (this.dragSnapToOrigin)
            resumeAnimation && resumeAnimation();
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
          if (this.startEvent && onEnd) {
            onEnd(event2, panInfo);
          }
          onSessionEnd && onSessionEnd(event2, panInfo);
        };
        if (!isPrimaryPointer(event))
          return;
        this.dragSnapToOrigin = dragSnapToOrigin;
        this.handlers = handlers;
        this.transformPagePoint = transformPagePoint;
        this.contextWindow = contextWindow || window;
        const info = extractEventInfo(event);
        const initialInfo = transformPoint(info, this.transformPagePoint);
        const { point } = initialInfo;
        const { timestamp } = frameData;
        this.history = [{ ...point, timestamp }];
        const { onSessionStart } = handlers;
        onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
      }
      updateHandlers(handlers) {
        this.handlers = handlers;
      }
      end() {
        this.removeListeners && this.removeListeners();
        cancelFrame(this.updatePoint);
      }
    }, "PanSession");
    __name2(PanSession, "PanSession");
    __name2(transformPoint, "transformPoint");
    __name2(subtractPoint, "subtractPoint");
    __name2(getPanInfo, "getPanInfo");
    __name2(startDevicePoint, "startDevicePoint");
    __name2(lastDevicePoint, "lastDevicePoint");
    __name2(getVelocity, "getVelocity");
  }
});
function calcLength(axis) {
  return axis.max - axis.min;
}
__name(calcLength, "calcLength");
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
__name(isNear, "isNear");
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
__name(calcAxisDelta, "calcAxisDelta");
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
__name(calcBoxDelta, "calcBoxDelta");
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
__name(calcRelativeAxis, "calcRelativeAxis");
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
__name(calcRelativeBox, "calcRelativeBox");
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
__name(calcRelativeAxisPosition, "calcRelativeAxisPosition");
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
__name(calcRelativePosition, "calcRelativePosition");
var SCALE_PRECISION;
var SCALE_MIN;
var SCALE_MAX;
var TRANSLATE_PRECISION;
var TRANSLATE_MIN;
var TRANSLATE_MAX;
var init_delta_calc = __esm({
  "../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_number2();
    SCALE_PRECISION = 1e-4;
    SCALE_MIN = 1 - SCALE_PRECISION;
    SCALE_MAX = 1 + SCALE_PRECISION;
    TRANSLATE_PRECISION = 0.01;
    TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
    TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
    __name2(calcLength, "calcLength");
    __name2(isNear, "isNear");
    __name2(calcAxisDelta, "calcAxisDelta");
    __name2(calcBoxDelta, "calcBoxDelta");
    __name2(calcRelativeAxis, "calcRelativeAxis");
    __name2(calcRelativeBox, "calcRelativeBox");
    __name2(calcRelativeAxisPosition, "calcRelativeAxisPosition");
    __name2(calcRelativePosition, "calcRelativePosition");
  }
});
function applyConstraints(point, { min, max }, elastic) {
  if (min !== void 0 && point < min) {
    point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
__name(applyConstraints, "applyConstraints");
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
__name(calcRelativeAxisConstraints, "calcRelativeAxisConstraints");
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
__name(calcRelativeConstraints, "calcRelativeConstraints");
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
__name(calcViewportAxisConstraints, "calcViewportAxisConstraints");
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
__name(calcViewportConstraints, "calcViewportConstraints");
function calcOrigin2(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
__name(calcOrigin2, "calcOrigin2");
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
__name(rebaseAxisConstraints, "rebaseAxisConstraints");
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
__name(resolveDragElastic, "resolveDragElastic");
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
__name(resolveAxisElastic, "resolveAxisElastic");
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
__name(resolvePointElastic, "resolvePointElastic");
var defaultElastic;
var init_constraints = __esm({
  "../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_delta_calc();
    init_clamp();
    init_number2();
    __name2(applyConstraints, "applyConstraints");
    __name2(calcRelativeAxisConstraints, "calcRelativeAxisConstraints");
    __name2(calcRelativeConstraints, "calcRelativeConstraints");
    __name2(calcViewportAxisConstraints, "calcViewportAxisConstraints");
    __name2(calcViewportConstraints, "calcViewportConstraints");
    __name2(calcOrigin2, "calcOrigin");
    __name2(rebaseAxisConstraints, "rebaseAxisConstraints");
    defaultElastic = 0.35;
    __name2(resolveDragElastic, "resolveDragElastic");
    __name2(resolveAxisElastic, "resolveAxisElastic");
    __name2(resolvePointElastic, "resolvePointElastic");
  }
});
var createAxisDelta;
var createDelta;
var createAxis;
var createBox;
var init_models = __esm({
  "../node_modules/framer-motion/dist/es/projection/geometry/models.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    createAxisDelta = /* @__PURE__ */ __name2(() => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    }), "createAxisDelta");
    createDelta = /* @__PURE__ */ __name2(() => ({
      x: createAxisDelta(),
      y: createAxisDelta()
    }), "createDelta");
    createAxis = /* @__PURE__ */ __name2(() => ({ min: 0, max: 0 }), "createAxis");
    createBox = /* @__PURE__ */ __name2(() => ({
      x: createAxis(),
      y: createAxis()
    }), "createBox");
  }
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
__name(eachAxis, "eachAxis");
var init_each_axis = __esm({
  "../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(eachAxis, "eachAxis");
  }
});
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
__name(convertBoundingBoxToBox, "convertBoundingBoxToBox");
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
__name(convertBoxToBoundingBox, "convertBoxToBoundingBox");
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
__name(transformBoxPoints, "transformBoxPoints");
var init_conversion = __esm({
  "../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(convertBoundingBoxToBox, "convertBoundingBoxToBox");
    __name2(convertBoxToBoundingBox, "convertBoxToBoundingBox");
    __name2(transformBoxPoints, "transformBoxPoints");
  }
});
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
__name(isIdentityScale, "isIdentityScale");
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
__name(hasScale, "hasScale");
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
__name(hasTransform, "hasTransform");
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
__name(has2DTranslate, "has2DTranslate");
function is2DTranslate(value) {
  return value && value !== "0%";
}
__name(is2DTranslate, "is2DTranslate");
var init_has_transform = __esm({
  "../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isIdentityScale, "isIdentityScale");
    __name2(hasScale, "hasScale");
    __name2(hasTransform, "hasTransform");
    __name2(has2DTranslate, "has2DTranslate");
    __name2(is2DTranslate, "is2DTranslate");
  }
});
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
__name(scalePoint, "scalePoint");
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
__name(applyPointDelta, "applyPointDelta");
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(applyAxisDelta, "applyAxisDelta");
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
__name(applyBoxDelta, "applyBoxDelta");
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node = treePath[i2];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
__name(applyTreeDeltas, "applyTreeDeltas");
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
__name(translateAxis, "translateAxis");
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
__name(transformAxis, "transformAxis");
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
__name(transformBox, "transformBox");
var TREE_SCALE_SNAP_MIN;
var TREE_SCALE_SNAP_MAX;
var init_delta_apply = __esm({
  "../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_number2();
    init_has_transform();
    __name2(scalePoint, "scalePoint");
    __name2(applyPointDelta, "applyPointDelta");
    __name2(applyAxisDelta, "applyAxisDelta");
    __name2(applyBoxDelta, "applyBoxDelta");
    TREE_SCALE_SNAP_MIN = 0.999999999999;
    TREE_SCALE_SNAP_MAX = 1.0000000000001;
    __name2(applyTreeDeltas, "applyTreeDeltas");
    __name2(translateAxis, "translateAxis");
    __name2(transformAxis, "transformAxis");
    __name2(transformBox, "transformBox");
  }
});
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
__name(measureViewportBox, "measureViewportBox");
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
__name(measurePageBox, "measurePageBox");
var init_measure = __esm({
  "../node_modules/framer-motion/dist/es/projection/utils/measure.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_conversion();
    init_delta_apply();
    __name2(measureViewportBox, "measureViewportBox");
    __name2(measurePageBox, "measurePageBox");
  }
});
var getContextWindow;
var init_get_context_window = __esm({
  "../node_modules/framer-motion/dist/es/utils/get-context-window.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    getContextWindow = /* @__PURE__ */ __name2(({ current }) => {
      return current ? current.ownerDocument.defaultView : null;
    }, "getContextWindow");
  }
});
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
__name(shouldDrag, "shouldDrag");
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
__name(getCurrentDirection, "getCurrentDirection");
var elementDragControls;
var VisualElementDragControls;
var init_VisualElementDragControls = __esm({
  "../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_es2();
    init_PanSession();
    init_is_ref_object();
    init_add_pointer_event();
    init_constraints();
    init_models();
    init_each_axis();
    init_measure();
    init_event_info();
    init_conversion();
    init_add_dom_event();
    init_delta_calc();
    init_number2();
    init_units();
    init_motion_value();
    init_get_context_window();
    init_add_will_change();
    init_frame();
    elementDragControls = /* @__PURE__ */ new WeakMap();
    VisualElementDragControls = /* @__PURE__ */ __name(class {
      constructor(visualElement) {
        this.openDragLock = null;
        this.isDragging = false;
        this.currentDirection = null;
        this.originPoint = { x: 0, y: 0 };
        this.constraints = false;
        this.hasMutatedConstraints = false;
        this.elastic = createBox();
        this.visualElement = visualElement;
      }
      start(originEvent, { snapToCursor = false } = {}) {
        const { presenceContext } = this.visualElement;
        if (presenceContext && presenceContext.isPresent === false)
          return;
        const onSessionStart = /* @__PURE__ */ __name2((event) => {
          const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
          dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
          if (snapToCursor) {
            this.snapToCursor(extractEventInfo(event).point);
          }
        }, "onSessionStart");
        const onStart = /* @__PURE__ */ __name2((event, info) => {
          const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
          if (drag2 && !dragPropagation) {
            if (this.openDragLock)
              this.openDragLock();
            this.openDragLock = setDragLock(drag2);
            if (!this.openDragLock)
              return;
          }
          this.isDragging = true;
          this.currentDirection = null;
          this.resolveConstraints();
          if (this.visualElement.projection) {
            this.visualElement.projection.isAnimationBlocked = true;
            this.visualElement.projection.target = void 0;
          }
          eachAxis((axis) => {
            let current = this.getAxisMotionValue(axis).get() || 0;
            if (percent.test(current)) {
              const { projection } = this.visualElement;
              if (projection && projection.layout) {
                const measuredAxis = projection.layout.layoutBox[axis];
                if (measuredAxis) {
                  const length = calcLength(measuredAxis);
                  current = length * (parseFloat(current) / 100);
                }
              }
            }
            this.originPoint[axis] = current;
          });
          if (onDragStart) {
            frame.postRender(() => onDragStart(event, info));
          }
          addValueToWillChange(this.visualElement, "transform");
          const { animationState } = this.visualElement;
          animationState && animationState.setActive("whileDrag", true);
        }, "onStart");
        const onMove = /* @__PURE__ */ __name2((event, info) => {
          const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
          if (!dragPropagation && !this.openDragLock)
            return;
          const { offset } = info;
          if (dragDirectionLock && this.currentDirection === null) {
            this.currentDirection = getCurrentDirection(offset);
            if (this.currentDirection !== null) {
              onDirectionLock && onDirectionLock(this.currentDirection);
            }
            return;
          }
          this.updateAxis("x", info.point, offset);
          this.updateAxis("y", info.point, offset);
          this.visualElement.render();
          onDrag && onDrag(event, info);
        }, "onMove");
        const onSessionEnd = /* @__PURE__ */ __name2((event, info) => this.stop(event, info), "onSessionEnd");
        const resumeAnimation = /* @__PURE__ */ __name2(() => eachAxis((axis) => {
          var _a;
          return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
        }), "resumeAnimation");
        const { dragSnapToOrigin } = this.getProps();
        this.panSession = new PanSession(originEvent, {
          onSessionStart,
          onStart,
          onMove,
          onSessionEnd,
          resumeAnimation
        }, {
          transformPagePoint: this.visualElement.getTransformPagePoint(),
          dragSnapToOrigin,
          contextWindow: getContextWindow(this.visualElement)
        });
      }
      stop(event, info) {
        const isDragging2 = this.isDragging;
        this.cancel();
        if (!isDragging2)
          return;
        const { velocity } = info;
        this.startAnimation(velocity);
        const { onDragEnd } = this.getProps();
        if (onDragEnd) {
          frame.postRender(() => onDragEnd(event, info));
        }
      }
      cancel() {
        this.isDragging = false;
        const { projection, animationState } = this.visualElement;
        if (projection) {
          projection.isAnimationBlocked = false;
        }
        this.panSession && this.panSession.end();
        this.panSession = void 0;
        const { dragPropagation } = this.getProps();
        if (!dragPropagation && this.openDragLock) {
          this.openDragLock();
          this.openDragLock = null;
        }
        animationState && animationState.setActive("whileDrag", false);
      }
      updateAxis(axis, _point, offset) {
        const { drag: drag2 } = this.getProps();
        if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        let next = this.originPoint[axis] + offset[axis];
        if (this.constraints && this.constraints[axis]) {
          next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
        }
        axisValue.set(next);
      }
      resolveConstraints() {
        var _a;
        const { dragConstraints, dragElastic } = this.getProps();
        const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
        const prevConstraints = this.constraints;
        if (dragConstraints && isRefObject(dragConstraints)) {
          if (!this.constraints) {
            this.constraints = this.resolveRefConstraints();
          }
        } else {
          if (dragConstraints && layout2) {
            this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
          } else {
            this.constraints = false;
          }
        }
        this.elastic = resolveDragElastic(dragElastic);
        if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
          eachAxis((axis) => {
            if (this.constraints !== false && this.getAxisMotionValue(axis)) {
              this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
            }
          });
        }
      }
      resolveRefConstraints() {
        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
        if (!constraints || !isRefObject(constraints))
          return false;
        const constraintsElement = constraints.current;
        invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
        const { projection } = this.visualElement;
        if (!projection || !projection.layout)
          return false;
        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
        if (onMeasureDragConstraints) {
          const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
          this.hasMutatedConstraints = !!userConstraints;
          if (userConstraints) {
            measuredConstraints = convertBoundingBoxToBox(userConstraints);
          }
        }
        return measuredConstraints;
      }
      startAnimation(velocity) {
        const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
        const constraints = this.constraints || {};
        const momentumAnimations = eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, this.currentDirection)) {
            return;
          }
          let transition = constraints && constraints[axis] || {};
          if (dragSnapToOrigin)
            transition = { min: 0, max: 0 };
          const bounceStiffness = dragElastic ? 200 : 1e6;
          const bounceDamping = dragElastic ? 40 : 1e7;
          const inertia2 = {
            type: "inertia",
            velocity: dragMomentum ? velocity[axis] : 0,
            bounceStiffness,
            bounceDamping,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...dragTransition,
            ...transition
          };
          return this.startAxisValueAnimation(axis, inertia2);
        });
        return Promise.all(momentumAnimations).then(onDragTransitionEnd);
      }
      startAxisValueAnimation(axis, transition) {
        const axisValue = this.getAxisMotionValue(axis);
        addValueToWillChange(this.visualElement, axis);
        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
      }
      stopAnimation() {
        eachAxis((axis) => this.getAxisMotionValue(axis).stop());
      }
      pauseAnimation() {
        eachAxis((axis) => {
          var _a;
          return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
        });
      }
      getAnimationState(axis) {
        var _a;
        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
      }
      /**
       * Drag works differently depending on which props are provided.
       *
       * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
       * - Otherwise, we apply the delta to the x/y motion values.
       */
      getAxisMotionValue(axis) {
        const dragKey = `_drag${axis.toUpperCase()}`;
        const props = this.visualElement.getProps();
        const externalMotionValue = props[dragKey];
        return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
      }
      snapToCursor(point) {
        eachAxis((axis) => {
          const { drag: drag2 } = this.getProps();
          if (!shouldDrag(axis, drag2, this.currentDirection))
            return;
          const { projection } = this.visualElement;
          const axisValue = this.getAxisMotionValue(axis);
          if (projection && projection.layout) {
            const { min, max } = projection.layout.layoutBox[axis];
            axisValue.set(point[axis] - mixNumber(min, max, 0.5));
          }
        });
      }
      /**
       * When the viewport resizes we want to check if the measured constraints
       * have changed and, if so, reposition the element within those new constraints
       * relative to where it was before the resize.
       */
      scalePositionWithinConstraints() {
        if (!this.visualElement.current)
          return;
        const { drag: drag2, dragConstraints } = this.getProps();
        const { projection } = this.visualElement;
        if (!isRefObject(dragConstraints) || !projection || !this.constraints)
          return;
        this.stopAnimation();
        const boxProgress = { x: 0, y: 0 };
        eachAxis((axis) => {
          const axisValue = this.getAxisMotionValue(axis);
          if (axisValue && this.constraints !== false) {
            const latest = axisValue.get();
            boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
          }
        });
        const { transformTemplate } = this.visualElement.getProps();
        this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
        this.resolveConstraints();
        eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, null))
            return;
          const axisValue = this.getAxisMotionValue(axis);
          const { min, max } = this.constraints[axis];
          axisValue.set(mixNumber(min, max, boxProgress[axis]));
        });
      }
      addListeners() {
        if (!this.visualElement.current)
          return;
        elementDragControls.set(this.visualElement, this);
        const element = this.visualElement.current;
        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
          const { drag: drag2, dragListener = true } = this.getProps();
          drag2 && dragListener && this.start(event);
        });
        const measureDragConstraints = /* @__PURE__ */ __name2(() => {
          const { dragConstraints } = this.getProps();
          if (isRefObject(dragConstraints) && dragConstraints.current) {
            this.constraints = this.resolveRefConstraints();
          }
        }, "measureDragConstraints");
        const { projection } = this.visualElement;
        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
        if (projection && !projection.layout) {
          projection.root && projection.root.updateScroll();
          projection.updateLayout();
        }
        frame.read(measureDragConstraints);
        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
          if (this.isDragging && hasLayoutChanged) {
            eachAxis((axis) => {
              const motionValue2 = this.getAxisMotionValue(axis);
              if (!motionValue2)
                return;
              this.originPoint[axis] += delta[axis].translate;
              motionValue2.set(motionValue2.get() + delta[axis].translate);
            });
            this.visualElement.render();
          }
        });
        return () => {
          stopResizeListener();
          stopPointerListener();
          stopMeasureLayoutListener();
          stopLayoutUpdateListener && stopLayoutUpdateListener();
        };
      }
      getProps() {
        const props = this.visualElement.getProps();
        const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
        return {
          ...props,
          drag: drag2,
          dragDirectionLock,
          dragPropagation,
          dragConstraints,
          dragElastic,
          dragMomentum
        };
      }
    }, "VisualElementDragControls");
    __name2(VisualElementDragControls, "VisualElementDragControls");
    __name2(shouldDrag, "shouldDrag");
    __name2(getCurrentDirection, "getCurrentDirection");
  }
});
var DragGesture;
var init_drag = __esm({
  "../node_modules/framer-motion/dist/es/gestures/drag/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Feature();
    init_es();
    init_VisualElementDragControls();
    DragGesture = /* @__PURE__ */ __name(class extends Feature {
      constructor(node) {
        super(node);
        this.removeGroupControls = noop;
        this.removeListeners = noop;
        this.controls = new VisualElementDragControls(node);
      }
      mount() {
        const { dragControls } = this.node.getProps();
        if (dragControls) {
          this.removeGroupControls = dragControls.subscribe(this.controls);
        }
        this.removeListeners = this.controls.addListeners() || noop;
      }
      unmount() {
        this.removeGroupControls();
        this.removeListeners();
      }
    }, "DragGesture");
    __name2(DragGesture, "DragGesture");
  }
});
var asyncHandler;
var PanGesture;
var init_pan = __esm({
  "../node_modules/framer-motion/dist/es/gestures/pan/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_PanSession();
    init_add_pointer_event();
    init_Feature();
    init_es();
    init_get_context_window();
    init_frame();
    asyncHandler = /* @__PURE__ */ __name2((handler) => (event, info) => {
      if (handler) {
        frame.postRender(() => handler(event, info));
      }
    }, "asyncHandler");
    PanGesture = /* @__PURE__ */ __name(class extends Feature {
      constructor() {
        super(...arguments);
        this.removePointerDownListener = noop;
      }
      onPointerDown(pointerDownEvent) {
        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
          transformPagePoint: this.node.getTransformPagePoint(),
          contextWindow: getContextWindow(this.node)
        });
      }
      createPanHandlers() {
        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
        return {
          onSessionStart: asyncHandler(onPanSessionStart),
          onStart: asyncHandler(onPanStart),
          onMove: onPan,
          onEnd: (event, info) => {
            delete this.session;
            if (onPanEnd) {
              frame.postRender(() => onPanEnd(event, info));
            }
          }
        };
      }
      mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
      }
      update() {
        this.session && this.session.updateHandlers(this.createPanHandlers());
      }
      unmount() {
        this.removePointerDownListener();
        this.session && this.session.end();
      }
    }, "PanGesture");
    __name2(PanGesture, "PanGesture");
  }
});
var globalProjectionState;
var init_state2 = __esm({
  "../node_modules/framer-motion/dist/es/projection/node/state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    globalProjectionState = {
      /**
       * Global flag as to whether the tree has animated since the last time
       * we resized the window
       */
      hasAnimatedSinceResize: true,
      /**
       * We set this to true once, on the first update. Any nodes added to the tree beyond that
       * update will be given a `data-projection-id` attribute.
       */
      hasEverUpdated: false
    };
  }
});
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
__name(pixelsToPercent, "pixelsToPercent");
var correctBorderRadius;
var init_scale_border_radius = __esm({
  "../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_units();
    __name2(pixelsToPercent, "pixelsToPercent");
    correctBorderRadius = {
      correct: (latest, node) => {
        if (!node.target)
          return latest;
        if (typeof latest === "string") {
          if (px.test(latest)) {
            latest = parseFloat(latest);
          } else {
            return latest;
          }
        }
        const x2 = pixelsToPercent(latest, node.target.x);
        const y2 = pixelsToPercent(latest, node.target.y);
        return `${x2}% ${y2}%`;
      }
    };
  }
});
var correctBoxShadow;
var init_scale_box_shadow = __esm({
  "../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_number2();
    init_complex();
    correctBoxShadow = {
      correct: (latest, { treeScale, projectionDelta }) => {
        const original = latest;
        const shadow = complex.parse(latest);
        if (shadow.length > 5)
          return original;
        const template = complex.createTransformer(latest);
        const offset = typeof shadow[0] !== "number" ? 1 : 0;
        const xScale = projectionDelta.x.scale * treeScale.x;
        const yScale = projectionDelta.y.scale * treeScale.y;
        shadow[0 + offset] /= xScale;
        shadow[1 + offset] /= yScale;
        const averageScale = mixNumber(xScale, yScale, 0.5);
        if (typeof shadow[2 + offset] === "number")
          shadow[2 + offset] /= averageScale;
        if (typeof shadow[3 + offset] === "number")
          shadow[3 + offset] /= averageScale;
        return template(shadow);
      }
    };
  }
});
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence2();
  const layoutGroup = (0, import_react28.useContext)(LayoutGroupContext);
  return (0, import_jsx_runtime15.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react28.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
__name(MeasureLayout, "MeasureLayout");
var import_jsx_runtime15;
var import_react28;
var MeasureLayoutWithContext;
var defaultScaleCorrectors;
var init_MeasureLayout = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
    import_react28 = __toESM(require_react(), 1);
    init_use_presence();
    init_LayoutGroupContext();
    init_SwitchLayoutGroupContext();
    init_state2();
    init_scale_border_radius();
    init_scale_box_shadow();
    init_scale_correction();
    init_microtask();
    init_frame();
    MeasureLayoutWithContext = /* @__PURE__ */ __name(class extends import_react28.Component {
      /**
       * This only mounts projection nodes for components that
       * need measuring, we might want to do it for all components
       * in order to incorporate transforms
       */
      componentDidMount() {
        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
        const { projection } = visualElement;
        addScaleCorrector(defaultScaleCorrectors);
        if (projection) {
          if (layoutGroup.group)
            layoutGroup.group.add(projection);
          if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
            switchLayoutGroup.register(projection);
          }
          projection.root.didUpdate();
          projection.addEventListener("animationComplete", () => {
            this.safeToRemove();
          });
          projection.setOptions({
            ...projection.options,
            onExitComplete: () => this.safeToRemove()
          });
        }
        globalProjectionState.hasEverUpdated = true;
      }
      getSnapshotBeforeUpdate(prevProps) {
        const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
        const projection = visualElement.projection;
        if (!projection)
          return null;
        projection.isPresent = isPresent;
        if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
          projection.willUpdate();
        } else {
          this.safeToRemove();
        }
        if (prevProps.isPresent !== isPresent) {
          if (isPresent) {
            projection.promote();
          } else if (!projection.relegate()) {
            frame.postRender(() => {
              const stack = projection.getStack();
              if (!stack || !stack.members.length) {
                this.safeToRemove();
              }
            });
          }
        }
        return null;
      }
      componentDidUpdate() {
        const { projection } = this.props.visualElement;
        if (projection) {
          projection.root.didUpdate();
          microtask.postRender(() => {
            if (!projection.currentAnimation && projection.isLead()) {
              this.safeToRemove();
            }
          });
        }
      }
      componentWillUnmount() {
        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
        const { projection } = visualElement;
        if (projection) {
          projection.scheduleCheckAfterUnmount();
          if (layoutGroup && layoutGroup.group)
            layoutGroup.group.remove(projection);
          if (promoteContext && promoteContext.deregister)
            promoteContext.deregister(projection);
        }
      }
      safeToRemove() {
        const { safeToRemove } = this.props;
        safeToRemove && safeToRemove();
      }
      render() {
        return null;
      }
    }, "MeasureLayoutWithContext");
    __name2(MeasureLayoutWithContext, "MeasureLayoutWithContext");
    __name2(MeasureLayout, "MeasureLayout");
    defaultScaleCorrectors = {
      borderRadius: {
        ...correctBorderRadius,
        applyTo: [
          "borderTopLeftRadius",
          "borderTopRightRadius",
          "borderBottomLeftRadius",
          "borderBottomRightRadius"
        ]
      },
      borderTopLeftRadius: correctBorderRadius,
      borderTopRightRadius: correctBorderRadius,
      borderBottomLeftRadius: correctBorderRadius,
      borderBottomRightRadius: correctBorderRadius,
      boxShadow: correctBoxShadow
    };
  }
});
function animateSingleValue(value, keyframes2, options2) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options2));
  return motionValue$1.animation;
}
__name(animateSingleValue, "animateSingleValue");
var init_single_value = __esm({
  "../node_modules/framer-motion/dist/es/animation/animate/single-value.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_value();
    init_is_motion_value();
    init_motion_value();
    __name2(animateSingleValue, "animateSingleValue");
  }
});
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
__name(isSVGElement, "isSVGElement");
var init_is_svg_element = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(isSVGElement, "isSVGElement");
  }
});
var compareByDepth;
var init_compare_by_depth = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    compareByDepth = /* @__PURE__ */ __name2((a2, b2) => a2.depth - b2.depth, "compareByDepth");
  }
});
var FlatTree;
var init_flat_tree = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_array();
    init_compare_by_depth();
    FlatTree = /* @__PURE__ */ __name(class {
      constructor() {
        this.children = [];
        this.isDirty = false;
      }
      add(child) {
        addUniqueItem(this.children, child);
        this.isDirty = true;
      }
      remove(child) {
        removeItem(this.children, child);
        this.isDirty = true;
      }
      forEach(callback) {
        this.isDirty && this.children.sort(compareByDepth);
        this.isDirty = false;
        this.children.forEach(callback);
      }
    }, "FlatTree");
    __name2(FlatTree, "FlatTree");
  }
});
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = /* @__PURE__ */ __name2(({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  }, "checkElapsed");
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
__name(delay, "delay");
var init_delay = __esm({
  "../node_modules/framer-motion/dist/es/utils/delay.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_sync_time();
    init_frame();
    __name2(delay, "delay");
  }
});
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
__name(mixValues, "mixValues");
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
__name(getRadius, "getRadius");
function compress2(min, max, easing) {
  return (p2) => {
    if (p2 < min)
      return 0;
    if (p2 > max)
      return 1;
    return easing(progress(min, max, p2));
  };
}
__name(compress2, "compress2");
var borders;
var numBorders;
var asNumber;
var isPx;
var easeCrossfadeIn;
var easeCrossfadeOut;
var init_mix_values = __esm({
  "../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es();
    init_circ();
    init_number2();
    init_units();
    borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
    numBorders = borders.length;
    asNumber = /* @__PURE__ */ __name2((value) => typeof value === "string" ? parseFloat(value) : value, "asNumber");
    isPx = /* @__PURE__ */ __name2((value) => typeof value === "number" || px.test(value), "isPx");
    __name2(mixValues, "mixValues");
    __name2(getRadius, "getRadius");
    easeCrossfadeIn = /* @__PURE__ */ compress2(0, 0.5, circOut);
    easeCrossfadeOut = /* @__PURE__ */ compress2(0.5, 0.95, noop);
    __name2(compress2, "compress");
  }
});
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
__name(copyAxisInto, "copyAxisInto");
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
__name(copyBoxInto, "copyBoxInto");
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
__name(copyAxisDeltaInto, "copyAxisDeltaInto");
var init_copy = __esm({
  "../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(copyAxisInto, "copyAxisInto");
    __name2(copyBoxInto, "copyBoxInto");
    __name2(copyAxisDeltaInto, "copyAxisDeltaInto");
  }
});
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
__name(removePointDelta, "removePointDelta");
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(removeAxisDelta, "removeAxisDelta");
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
__name(removeAxisTransforms, "removeAxisTransforms");
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
__name(removeBoxTransforms, "removeBoxTransforms");
var xKeys;
var yKeys;
var init_delta_remove = __esm({
  "../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_number2();
    init_units();
    init_delta_apply();
    __name2(removePointDelta, "removePointDelta");
    __name2(removeAxisDelta, "removeAxisDelta");
    __name2(removeAxisTransforms, "removeAxisTransforms");
    xKeys = ["x", "scaleX", "originX"];
    yKeys = ["y", "scaleY", "originY"];
    __name2(removeBoxTransforms, "removeBoxTransforms");
  }
});
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
__name(isAxisDeltaZero, "isAxisDeltaZero");
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
__name(isDeltaZero, "isDeltaZero");
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
__name(axisEquals, "axisEquals");
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
__name(boxEquals, "boxEquals");
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
__name(axisEqualsRounded, "axisEqualsRounded");
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
__name(boxEqualsRounded, "boxEqualsRounded");
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
__name(aspectRatio, "aspectRatio");
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}
__name(axisDeltaEquals, "axisDeltaEquals");
var init_utils7 = __esm({
  "../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_delta_calc();
    __name2(isAxisDeltaZero, "isAxisDeltaZero");
    __name2(isDeltaZero, "isDeltaZero");
    __name2(axisEquals, "axisEquals");
    __name2(boxEquals, "boxEquals");
    __name2(axisEqualsRounded, "axisEqualsRounded");
    __name2(boxEqualsRounded, "boxEqualsRounded");
    __name2(aspectRatio, "aspectRatio");
    __name2(axisDeltaEquals, "axisDeltaEquals");
  }
});
var NodeStack;
var init_stack = __esm({
  "../node_modules/framer-motion/dist/es/projection/shared/stack.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_array();
    NodeStack = /* @__PURE__ */ __name(class {
      constructor() {
        this.members = [];
      }
      add(node) {
        addUniqueItem(this.members, node);
        node.scheduleRender();
      }
      remove(node) {
        removeItem(this.members, node);
        if (node === this.prevLead) {
          this.prevLead = void 0;
        }
        if (node === this.lead) {
          const prevLead = this.members[this.members.length - 1];
          if (prevLead) {
            this.promote(prevLead);
          }
        }
      }
      relegate(node) {
        const indexOfNode = this.members.findIndex((member) => node === member);
        if (indexOfNode === 0)
          return false;
        let prevLead;
        for (let i2 = indexOfNode; i2 >= 0; i2--) {
          const member = this.members[i2];
          if (member.isPresent !== false) {
            prevLead = member;
            break;
          }
        }
        if (prevLead) {
          this.promote(prevLead);
          return true;
        } else {
          return false;
        }
      }
      promote(node, preserveFollowOpacity) {
        const prevLead = this.lead;
        if (node === prevLead)
          return;
        this.prevLead = prevLead;
        this.lead = node;
        node.show();
        if (prevLead) {
          prevLead.instance && prevLead.scheduleRender();
          node.scheduleRender();
          node.resumeFrom = prevLead;
          if (preserveFollowOpacity) {
            node.resumeFrom.preserveOpacity = true;
          }
          if (prevLead.snapshot) {
            node.snapshot = prevLead.snapshot;
            node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          }
          if (node.root && node.root.isUpdating) {
            node.isLayoutDirty = true;
          }
          const { crossfade } = node.options;
          if (crossfade === false) {
            prevLead.hide();
          }
        }
      }
      exitAnimationComplete() {
        this.members.forEach((node) => {
          const { options: options2, resumingFrom } = node;
          options2.onExitComplete && options2.onExitComplete();
          if (resumingFrom) {
            resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
          }
        });
      }
      scheduleRender() {
        this.members.forEach((node) => {
          node.instance && node.scheduleRender(false);
        });
      }
      /**
       * Clear any leads that have been removed this render to prevent them from being
       * used in future animations and to prevent memory leaks
       */
      removeLeadSnapshot() {
        if (this.lead && this.lead.snapshot) {
          this.lead.snapshot = void 0;
        }
      }
    }, "NodeStack");
    __name2(NodeStack, "NodeStack");
  }
});
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform += `skewX(${skewX}deg) `;
    if (skewY)
      transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
__name(buildProjectionTransform, "buildProjectionTransform");
var init_transform2 = __esm({
  "../node_modules/framer-motion/dist/es/projection/styles/transform.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(buildProjectionTransform, "buildProjectionTransform");
  }
});
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
__name(resetDistortingTransform, "resetDistortingTransform");
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
__name(cancelTreeOptimisedTransformAnimations, "cancelTreeOptimisedTransformAnimations");
function createProjectionNode2({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return /* @__PURE__ */ __name2(/* @__PURE__ */ __name(class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id2++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        if (isDebug) {
          metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;
        }
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        if (isDebug) {
          window.MotionDebug.record(metrics);
        }
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = /* @__PURE__ */ __name2(() => this.root.updateBlockedByResize = false, "resizeUnblockUpdate");
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        const { scroll, options: options2 } = node;
        if (node !== this.root && scroll && options2.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options2) {
      this.options = {
        ...this.options,
        ...options2,
        crossfade: options2.crossfade !== void 0 ? options2.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (isDebug) {
        metrics.resolvedTargetDeltas++;
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      if (isDebug) {
        metrics.recalculatedProjection++;
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a;
      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options2) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options2,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options2.onUpdate && options2.onUpdate(latest);
          },
          onComplete: () => {
            options2.onComplete && options2.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a, _b;
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            styles[applyTo[i2]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  }, "ProjectionNode"), "ProjectionNode");
}
__name(createProjectionNode2, "createProjectionNode2");
function updateLayout(node) {
  node.updateLayout();
}
__name(updateLayout, "updateLayout");
function notifyLayoutUpdate(node) {
  var _a;
  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
__name(notifyLayoutUpdate, "notifyLayoutUpdate");
function propagateDirtyNodes(node) {
  if (isDebug) {
    metrics.totalNodes++;
  }
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
__name(propagateDirtyNodes, "propagateDirtyNodes");
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
__name(cleanDirtyNodes, "cleanDirtyNodes");
function clearSnapshot(node) {
  node.clearSnapshot();
}
__name(clearSnapshot, "clearSnapshot");
function clearMeasurements(node) {
  node.clearMeasurements();
}
__name(clearMeasurements, "clearMeasurements");
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
__name(clearIsLayoutDirty, "clearIsLayoutDirty");
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
__name(resetTransformStyle, "resetTransformStyle");
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
__name(finishAnimation, "finishAnimation");
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
__name(resolveTargetDelta, "resolveTargetDelta");
function calcProjection(node) {
  node.calcProjection();
}
__name(calcProjection, "calcProjection");
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
__name(resetSkewAndRotation, "resetSkewAndRotation");
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
__name(removeLeadSnapshots, "removeLeadSnapshots");
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber(delta.translate, 0, p2);
  output.scale = mixNumber(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
__name(mixAxisDelta, "mixAxisDelta");
function mixAxis(output, from27, to3, p2) {
  output.min = mixNumber(from27.min, to3.min, p2);
  output.max = mixNumber(from27.max, to3.max, p2);
}
__name(mixAxis, "mixAxis");
function mixBox(output, from27, to3, p2) {
  mixAxis(output.x, from27.x, to3.x, p2);
  mixAxis(output.y, from27.y, to3.y, p2);
}
__name(mixBox, "mixBox");
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
__name(hasOpacityCrossfade, "hasOpacityCrossfade");
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
__name(roundAxis, "roundAxis");
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
__name(roundBox, "roundBox");
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
__name(shouldAnimatePositionOnly, "shouldAnimatePositionOnly");
function checkNodeWasScrollRoot(node) {
  var _a;
  return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
}
__name(checkNodeWasScrollRoot, "checkNodeWasScrollRoot");
var metrics;
var isDebug;
var transformAxes;
var hiddenVisibility;
var animationTarget;
var id2;
var defaultLayoutTransition;
var userAgentContains;
var roundPoint;
var init_create_projection_node = __esm({
  "../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es2();
    init_es();
    init_single_value();
    init_get_appear_id();
    init_frame();
    init_microtask();
    init_sync_time();
    init_is_svg_element();
    init_flat_tree();
    init_clamp();
    init_delay();
    init_number2();
    init_subscription_manager();
    init_resolve_motion_value();
    init_mix_values();
    init_copy();
    init_delta_apply();
    init_delta_calc();
    init_delta_remove();
    init_models();
    init_utils7();
    init_stack();
    init_scale_correction();
    init_transform2();
    init_each_axis();
    init_has_transform();
    init_state2();
    metrics = {
      type: "projectionFrame",
      totalNodes: 0,
      resolvedTargetDeltas: 0,
      recalculatedProjection: 0
    };
    isDebug = typeof window !== "undefined" && window.MotionDebug !== void 0;
    transformAxes = ["", "X", "Y", "Z"];
    hiddenVisibility = { visibility: "hidden" };
    animationTarget = 1e3;
    id2 = 0;
    __name2(resetDistortingTransform, "resetDistortingTransform");
    __name2(cancelTreeOptimisedTransformAnimations, "cancelTreeOptimisedTransformAnimations");
    __name2(createProjectionNode2, "createProjectionNode");
    __name2(updateLayout, "updateLayout");
    __name2(notifyLayoutUpdate, "notifyLayoutUpdate");
    __name2(propagateDirtyNodes, "propagateDirtyNodes");
    __name2(cleanDirtyNodes, "cleanDirtyNodes");
    __name2(clearSnapshot, "clearSnapshot");
    __name2(clearMeasurements, "clearMeasurements");
    __name2(clearIsLayoutDirty, "clearIsLayoutDirty");
    __name2(resetTransformStyle, "resetTransformStyle");
    __name2(finishAnimation, "finishAnimation");
    __name2(resolveTargetDelta, "resolveTargetDelta");
    __name2(calcProjection, "calcProjection");
    __name2(resetSkewAndRotation, "resetSkewAndRotation");
    __name2(removeLeadSnapshots, "removeLeadSnapshots");
    __name2(mixAxisDelta, "mixAxisDelta");
    __name2(mixAxis, "mixAxis");
    __name2(mixBox, "mixBox");
    __name2(hasOpacityCrossfade, "hasOpacityCrossfade");
    defaultLayoutTransition = {
      duration: 0.45,
      ease: [0.4, 0, 0.1, 1]
    };
    userAgentContains = /* @__PURE__ */ __name2((string) => typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().includes(string), "userAgentContains");
    roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
    __name2(roundAxis, "roundAxis");
    __name2(roundBox, "roundBox");
    __name2(shouldAnimatePositionOnly, "shouldAnimatePositionOnly");
    __name2(checkNodeWasScrollRoot, "checkNodeWasScrollRoot");
  }
});
var DocumentProjectionNode;
var init_DocumentProjectionNode = __esm({
  "../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_create_projection_node();
    init_add_dom_event();
    DocumentProjectionNode = createProjectionNode2({
      attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
      measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => true
    });
  }
});
var rootProjectionNode;
var HTMLProjectionNode;
var init_HTMLProjectionNode = __esm({
  "../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_create_projection_node();
    init_DocumentProjectionNode();
    rootProjectionNode = {
      current: void 0
    };
    HTMLProjectionNode = createProjectionNode2({
      measureScroll: (instance) => ({
        x: instance.scrollLeft,
        y: instance.scrollTop
      }),
      defaultParent: () => {
        if (!rootProjectionNode.current) {
          const documentNode = new DocumentProjectionNode({});
          documentNode.mount(window);
          documentNode.setOptions({ layoutScroll: true });
          rootProjectionNode.current = documentNode;
        }
        return rootProjectionNode.current;
      },
      resetTransform: (instance, value) => {
        instance.style.transform = value !== void 0 ? value : "none";
      },
      checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
    });
  }
});
var drag;
var init_drag2 = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/drag.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_drag();
    init_pan();
    init_MeasureLayout();
    init_HTMLProjectionNode();
    drag = {
      pan: {
        Feature: PanGesture
      },
      drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
  }
});
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
__name(handleHoverEvent, "handleHoverEvent");
var HoverGesture;
var init_hover2 = __esm({
  "../node_modules/framer-motion/dist/es/gestures/hover.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Feature();
    init_es2();
    init_event_info();
    init_frame();
    __name2(handleHoverEvent, "handleHoverEvent");
    HoverGesture = /* @__PURE__ */ __name(class extends Feature {
      mount() {
        const { current } = this.node;
        if (!current)
          return;
        this.unmount = hover(current, (startEvent) => {
          handleHoverEvent(this.node, startEvent, "Start");
          return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
        });
      }
      unmount() {
      }
    }, "HoverGesture");
    __name2(HoverGesture, "HoverGesture");
  }
});
var FocusGesture;
var init_focus = __esm({
  "../node_modules/framer-motion/dist/es/gestures/focus.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_add_dom_event();
    init_Feature();
    init_pipe();
    FocusGesture = /* @__PURE__ */ __name(class extends Feature {
      constructor() {
        super(...arguments);
        this.isActive = false;
      }
      onFocus() {
        let isFocusVisible = false;
        try {
          isFocusVisible = this.node.current.matches(":focus-visible");
        } catch (e2) {
          isFocusVisible = true;
        }
        if (!isFocusVisible || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", true);
        this.isActive = true;
      }
      onBlur() {
        if (!this.isActive || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", false);
        this.isActive = false;
      }
      mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
      }
      unmount() {
      }
    }, "FocusGesture");
    __name2(FocusGesture, "FocusGesture");
  }
});
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
__name(handlePressEvent, "handlePressEvent");
var PressGesture;
var init_press2 = __esm({
  "../node_modules/framer-motion/dist/es/gestures/press.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Feature();
    init_es2();
    init_event_info();
    init_frame();
    __name2(handlePressEvent, "handlePressEvent");
    PressGesture = /* @__PURE__ */ __name(class extends Feature {
      mount() {
        const { current } = this.node;
        if (!current)
          return;
        this.unmount = press(current, (startEvent) => {
          handlePressEvent(this.node, startEvent, "Start");
          return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
        }, { useGlobalTarget: this.node.props.globalTapTarget });
      }
      unmount() {
      }
    }, "PressGesture");
    __name2(PressGesture, "PressGesture");
  }
});
function initIntersectionObserver({ root, ...options2 }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options2);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options2 });
  }
  return rootObservers[key];
}
__name(initIntersectionObserver, "initIntersectionObserver");
function observeIntersection(element, options2, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options2);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
__name(observeIntersection, "observeIntersection");
var observerCallbacks;
var observers;
var fireObserverCallback;
var fireAllObserverCallbacks;
var init_observers = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    observerCallbacks = /* @__PURE__ */ new WeakMap();
    observers = /* @__PURE__ */ new WeakMap();
    fireObserverCallback = /* @__PURE__ */ __name2((entry) => {
      const callback = observerCallbacks.get(entry.target);
      callback && callback(entry);
    }, "fireObserverCallback");
    fireAllObserverCallbacks = /* @__PURE__ */ __name2((entries) => {
      entries.forEach(fireObserverCallback);
    }, "fireAllObserverCallbacks");
    __name2(initIntersectionObserver, "initIntersectionObserver");
    __name2(observeIntersection, "observeIntersection");
  }
});
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
__name(hasViewportOptionChanged, "hasViewportOptionChanged");
var thresholdNames;
var InViewFeature;
var init_viewport = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Feature();
    init_observers();
    thresholdNames = {
      some: 0,
      all: 1
    };
    InViewFeature = /* @__PURE__ */ __name(class extends Feature {
      constructor() {
        super(...arguments);
        this.hasEnteredView = false;
        this.isInView = false;
      }
      startObserver() {
        this.unmount();
        const { viewport = {} } = this.node.getProps();
        const { root, margin: rootMargin, amount = "some", once } = viewport;
        const options2 = {
          root: root ? root.current : void 0,
          rootMargin,
          threshold: typeof amount === "number" ? amount : thresholdNames[amount]
        };
        const onIntersectionUpdate = /* @__PURE__ */ __name2((entry) => {
          const { isIntersecting } = entry;
          if (this.isInView === isIntersecting)
            return;
          this.isInView = isIntersecting;
          if (once && !isIntersecting && this.hasEnteredView) {
            return;
          } else if (isIntersecting) {
            this.hasEnteredView = true;
          }
          if (this.node.animationState) {
            this.node.animationState.setActive("whileInView", isIntersecting);
          }
          const { onViewportEnter, onViewportLeave } = this.node.getProps();
          const callback = isIntersecting ? onViewportEnter : onViewportLeave;
          callback && callback(entry);
        }, "onIntersectionUpdate");
        return observeIntersection(this.node.current, options2, onIntersectionUpdate);
      }
      mount() {
        this.startObserver();
      }
      update() {
        if (typeof IntersectionObserver === "undefined")
          return;
        const { props, prevProps } = this.node;
        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
        if (hasOptionsChanged) {
          this.startObserver();
        }
      }
      unmount() {
      }
    }, "InViewFeature");
    __name2(InViewFeature, "InViewFeature");
    __name2(hasViewportOptionChanged, "hasViewportOptionChanged");
  }
});
var gestureAnimations;
var init_gestures = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/gestures.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_hover2();
    init_focus();
    init_press2();
    init_viewport();
    gestureAnimations = {
      inView: {
        Feature: InViewFeature
      },
      tap: {
        Feature: PressGesture
      },
      focus: {
        Feature: FocusGesture
      },
      hover: {
        Feature: HoverGesture
      }
    };
  }
});
var layout;
var init_layout = __esm({
  "../node_modules/framer-motion/dist/es/motion/features/layout.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_HTMLProjectionNode();
    init_MeasureLayout();
    layout = {
      layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
  }
});
var prefersReducedMotion;
var hasReducedMotionListener;
var init_state3 = __esm({
  "../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    prefersReducedMotion = { current: null };
    hasReducedMotionListener = { current: false };
  }
});
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser2)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = /* @__PURE__ */ __name2(() => prefersReducedMotion.current = motionMediaQuery.matches, "setReducedMotionPreferences");
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
__name(initPrefersReducedMotion, "initPrefersReducedMotion");
var init_reduced_motion = __esm({
  "../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_is_browser();
    init_state3();
    __name2(initPrefersReducedMotion, "initPrefersReducedMotion");
  }
});
var valueTypes;
var findValueType;
var init_find2 = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_color();
    init_complex();
    init_dimensions();
    init_test();
    valueTypes = [...dimensionValueTypes, color, complex];
    findValueType = /* @__PURE__ */ __name2((v2) => valueTypes.find(testValueType(v2)), "findValueType");
  }
});
var visualElementStore;
var init_store = __esm({
  "../node_modules/framer-motion/dist/es/render/store.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    visualElementStore = /* @__PURE__ */ new WeakMap();
  }
});
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (false) {
        warnOnce(nextValue.version === "11.18.2", `Attempting to mix Motion versions ${nextValue.version} with 11.18.2 may not work as expected.`);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
__name(updateMotionValuesFromProps, "updateMotionValuesFromProps");
var init_motion_values = __esm({
  "../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_value();
    init_is_motion_value();
    __name2(updateMotionValuesFromProps, "updateMotionValuesFromProps");
  }
});
var propEventHandlers;
var VisualElement;
var init_VisualElement = __esm({
  "../node_modules/framer-motion/dist/es/render/VisualElement.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_sync_time();
    init_definitions();
    init_models();
    init_is_numerical_string();
    init_is_zero_value_string();
    init_reduced_motion();
    init_state3();
    init_subscription_manager();
    init_warn_once();
    init_value();
    init_complex();
    init_is_motion_value();
    init_animatable_none();
    init_find2();
    init_keys_transform();
    init_store();
    init_is_controlling_variants();
    init_KeyframesResolver();
    init_motion_values();
    init_resolve_variants();
    init_frame();
    propEventHandlers = [
      "AnimationStart",
      "AnimationComplete",
      "Update",
      "BeforeLayoutMeasure",
      "LayoutMeasure",
      "LayoutAnimationStart",
      "LayoutAnimationComplete"
    ];
    VisualElement = /* @__PURE__ */ __name(class {
      /**
       * This method takes React props and returns found MotionValues. For example, HTML
       * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
       *
       * This isn't an abstract method as it needs calling in the constructor, but it is
       * intended to be one.
       */
      scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
        return {};
      }
      constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options2 = {}) {
        this.current = null;
        this.children = /* @__PURE__ */ new Set();
        this.isVariantNode = false;
        this.isControllingVariants = false;
        this.shouldReduceMotion = null;
        this.values = /* @__PURE__ */ new Map();
        this.KeyframeResolver = KeyframeResolver;
        this.features = {};
        this.valueSubscriptions = /* @__PURE__ */ new Map();
        this.prevMotionValues = {};
        this.events = {};
        this.propEventSubscriptions = {};
        this.notifyUpdate = () => this.notify("Update", this.latestValues);
        this.render = () => {
          if (!this.current)
            return;
          this.triggerBuild();
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
        };
        this.renderScheduledAt = 0;
        this.scheduleRender = () => {
          const now2 = time.now();
          if (this.renderScheduledAt < now2) {
            this.renderScheduledAt = now2;
            frame.render(this.render, false, true);
          }
        };
        const { latestValues, renderState, onUpdate } = visualState;
        this.onUpdate = onUpdate;
        this.latestValues = latestValues;
        this.baseTarget = { ...latestValues };
        this.initialValues = props.initial ? { ...latestValues } : {};
        this.renderState = renderState;
        this.parent = parent;
        this.props = props;
        this.presenceContext = presenceContext;
        this.depth = parent ? parent.depth + 1 : 0;
        this.reducedMotionConfig = reducedMotionConfig;
        this.options = options2;
        this.blockInitialAnimation = Boolean(blockInitialAnimation);
        this.isControllingVariants = isControllingVariants(props);
        this.isVariantNode = isVariantNode(props);
        if (this.isVariantNode) {
          this.variantChildren = /* @__PURE__ */ new Set();
        }
        this.manuallyAnimateOnMount = Boolean(parent && parent.current);
        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
        for (const key in initialMotionValues) {
          const value = initialMotionValues[key];
          if (latestValues[key] !== void 0 && isMotionValue(value)) {
            value.set(latestValues[key], false);
          }
        }
      }
      mount(instance) {
        this.current = instance;
        visualElementStore.set(instance, this);
        if (this.projection && !this.projection.instance) {
          this.projection.mount(instance);
        }
        if (this.parent && this.isVariantNode && !this.isControllingVariants) {
          this.removeFromVariantTree = this.parent.addVariantChild(this);
        }
        this.values.forEach((value, key) => this.bindToMotionValue(key, value));
        if (!hasReducedMotionListener.current) {
          initPrefersReducedMotion();
        }
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
        if (true) {
          warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
        }
        if (this.parent)
          this.parent.children.add(this);
        this.update(this.props, this.presenceContext);
      }
      unmount() {
        visualElementStore.delete(this.current);
        this.projection && this.projection.unmount();
        cancelFrame(this.notifyUpdate);
        cancelFrame(this.render);
        this.valueSubscriptions.forEach((remove) => remove());
        this.valueSubscriptions.clear();
        this.removeFromVariantTree && this.removeFromVariantTree();
        this.parent && this.parent.children.delete(this);
        for (const key in this.events) {
          this.events[key].clear();
        }
        for (const key in this.features) {
          const feature = this.features[key];
          if (feature) {
            feature.unmount();
            feature.isMounted = false;
          }
        }
        this.current = null;
      }
      bindToMotionValue(key, value) {
        if (this.valueSubscriptions.has(key)) {
          this.valueSubscriptions.get(key)();
        }
        const valueIsTransform = transformProps.has(key);
        const removeOnChange = value.on("change", (latestValue) => {
          this.latestValues[key] = latestValue;
          this.props.onUpdate && frame.preRender(this.notifyUpdate);
          if (valueIsTransform && this.projection) {
            this.projection.isTransformDirty = true;
          }
        });
        const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
        let removeSyncCheck;
        if (window.MotionCheckAppearSync) {
          removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
        }
        this.valueSubscriptions.set(key, () => {
          removeOnChange();
          removeOnRenderRequest();
          if (removeSyncCheck)
            removeSyncCheck();
          if (value.owner)
            value.stop();
        });
      }
      sortNodePosition(other) {
        if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
          return 0;
        }
        return this.sortInstanceNodePosition(this.current, other.current);
      }
      updateFeatures() {
        let key = "animation";
        for (key in featureDefinitions) {
          const featureDefinition = featureDefinitions[key];
          if (!featureDefinition)
            continue;
          const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
          if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
            this.features[key] = new FeatureConstructor(this);
          }
          if (this.features[key]) {
            const feature = this.features[key];
            if (feature.isMounted) {
              feature.update();
            } else {
              feature.mount();
              feature.isMounted = true;
            }
          }
        }
      }
      triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props);
      }
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
      }
      getStaticValue(key) {
        return this.latestValues[key];
      }
      setStaticValue(key, value) {
        this.latestValues[key] = value;
      }
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      update(props, presenceContext) {
        if (props.transformTemplate || this.props.transformTemplate) {
          this.scheduleRender();
        }
        this.prevProps = this.props;
        this.props = props;
        this.prevPresenceContext = this.presenceContext;
        this.presenceContext = presenceContext;
        for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
          const key = propEventHandlers[i2];
          if (this.propEventSubscriptions[key]) {
            this.propEventSubscriptions[key]();
            delete this.propEventSubscriptions[key];
          }
          const listenerName = "on" + key;
          const listener = props[listenerName];
          if (listener) {
            this.propEventSubscriptions[key] = this.on(key, listener);
          }
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
        if (this.handleChildMotionValue) {
          this.handleChildMotionValue();
        }
        this.onUpdate && this.onUpdate(this);
      }
      getProps() {
        return this.props;
      }
      /**
       * Returns the variant definition with a given name.
       */
      getVariant(name) {
        return this.props.variants ? this.props.variants[name] : void 0;
      }
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition() {
        return this.props.transition;
      }
      getTransformPagePoint() {
        return this.props.transformPagePoint;
      }
      getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
      }
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild(child) {
        const closestVariantNode = this.getClosestVariantNode();
        if (closestVariantNode) {
          closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
          return () => closestVariantNode.variantChildren.delete(child);
        }
      }
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue(key, value) {
        const existingValue = this.values.get(key);
        if (value !== existingValue) {
          if (existingValue)
            this.removeValue(key);
          this.bindToMotionValue(key, value);
          this.values.set(key, value);
          this.latestValues[key] = value.get();
        }
      }
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue(key) {
        this.values.delete(key);
        const unsubscribe = this.valueSubscriptions.get(key);
        if (unsubscribe) {
          unsubscribe();
          this.valueSubscriptions.delete(key);
        }
        delete this.latestValues[key];
        this.removeValueFromRenderState(key, this.renderState);
      }
      /**
       * Check whether we have a motion value for this key
       */
      hasValue(key) {
        return this.values.has(key);
      }
      getValue(key, defaultValue) {
        if (this.props.values && this.props.values[key]) {
          return this.props.values[key];
        }
        let value = this.values.get(key);
        if (value === void 0 && defaultValue !== void 0) {
          value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
          this.addValue(key, value);
        }
        return value;
      }
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue(key, target) {
        var _a;
        let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
        if (value !== void 0 && value !== null) {
          if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
            value = parseFloat(value);
          } else if (!findValueType(value) && complex.test(target)) {
            value = getAnimatableNone2(key, target);
          }
          this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
        }
        return isMotionValue(value) ? value.get() : value;
      }
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget(key, value) {
        this.baseTarget[key] = value;
      }
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget(key) {
        var _a;
        const { initial } = this.props;
        let valueFromInitial;
        if (typeof initial === "string" || typeof initial === "object") {
          const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
          if (variant) {
            valueFromInitial = variant[key];
          }
        }
        if (initial && valueFromInitial !== void 0) {
          return valueFromInitial;
        }
        const target = this.getBaseTargetFromProps(this.props, key);
        if (target !== void 0 && !isMotionValue(target))
          return target;
        return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new SubscriptionManager();
        }
        return this.events[eventName].add(callback);
      }
      notify(eventName, ...args) {
        if (this.events[eventName]) {
          this.events[eventName].notify(...args);
        }
      }
    }, "VisualElement");
    __name2(VisualElement, "VisualElement");
  }
});
var DOMVisualElement;
var init_DOMVisualElement = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_VisualElement();
    init_DOMKeyframesResolver();
    init_is_motion_value();
    DOMVisualElement = /* @__PURE__ */ __name(class extends VisualElement {
      constructor() {
        super(...arguments);
        this.KeyframeResolver = DOMKeyframesResolver;
      }
      sortInstanceNodePosition(a2, b2) {
        return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
      }
      getBaseTargetFromProps(props, key) {
        return props.style ? props.style[key] : void 0;
      }
      removeValueFromRenderState(key, { vars, style }) {
        delete vars[key];
        delete style[key];
      }
      handleChildMotionValue() {
        if (this.childSubscription) {
          this.childSubscription();
          delete this.childSubscription;
        }
        const { children } = this.props;
        if (isMotionValue(children)) {
          this.childSubscription = children.on("change", (latest) => {
            if (this.current) {
              this.current.textContent = `${latest}`;
            }
          });
        }
      }
    }, "DOMVisualElement");
    __name2(DOMVisualElement, "DOMVisualElement");
  }
});
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
__name(getComputedStyle2, "getComputedStyle2");
var HTMLVisualElement;
var init_HTMLVisualElement = __esm({
  "../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_measure();
    init_DOMVisualElement();
    init_is_css_variable();
    init_defaults();
    init_build_styles();
    init_keys_transform();
    init_render();
    init_scrape_motion_values();
    __name2(getComputedStyle2, "getComputedStyle");
    HTMLVisualElement = /* @__PURE__ */ __name(class extends DOMVisualElement {
      constructor() {
        super(...arguments);
        this.type = "html";
        this.renderInstance = renderHTML;
      }
      readValueFromInstance(instance, key) {
        if (transformProps.has(key)) {
          const defaultType = getDefaultValueType(key);
          return defaultType ? defaultType.default || 0 : 0;
        } else {
          const computedStyle = getComputedStyle2(instance);
          const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
          return typeof value === "string" ? value.trim() : value;
        }
      }
      measureInstanceViewportBox(instance, { transformPagePoint }) {
        return measureViewportBox(instance, transformPagePoint);
      }
      build(renderState, latestValues, props) {
        buildHTMLStyles(renderState, latestValues, props.transformTemplate);
      }
      scrapeMotionValuesFromProps(props, prevProps, visualElement) {
        return scrapeMotionValuesFromProps(props, prevProps, visualElement);
      }
    }, "HTMLVisualElement");
    __name2(HTMLVisualElement, "HTMLVisualElement");
  }
});
var SVGVisualElement;
var init_SVGVisualElement = __esm({
  "../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_models();
    init_DOMVisualElement();
    init_camel_to_dash();
    init_defaults();
    init_keys_transform();
    init_build_attrs();
    init_camel_case_attrs();
    init_is_svg_tag();
    init_render2();
    init_scrape_motion_values2();
    SVGVisualElement = /* @__PURE__ */ __name(class extends DOMVisualElement {
      constructor() {
        super(...arguments);
        this.type = "svg";
        this.isSVGTag = false;
        this.measureInstanceViewportBox = createBox;
      }
      getBaseTargetFromProps(props, key) {
        return props[key];
      }
      readValueFromInstance(instance, key) {
        if (transformProps.has(key)) {
          const defaultType = getDefaultValueType(key);
          return defaultType ? defaultType.default || 0 : 0;
        }
        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
        return instance.getAttribute(key);
      }
      scrapeMotionValuesFromProps(props, prevProps, visualElement) {
        return scrapeMotionValuesFromProps2(props, prevProps, visualElement);
      }
      build(renderState, latestValues, props) {
        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
      }
      renderInstance(instance, renderState, styleProp, projection) {
        renderSVG(instance, renderState, styleProp, projection);
      }
      mount(instance) {
        this.isSVGTag = isSVGTag(instance.tagName);
        super.mount(instance);
      }
    }, "SVGVisualElement");
    __name2(SVGVisualElement, "SVGVisualElement");
  }
});
var import_react29;
var createDomVisualElement;
var init_create_visual_element = __esm({
  "../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react29 = __toESM(require_react(), 1);
    init_HTMLVisualElement();
    init_SVGVisualElement();
    init_is_svg_component();
    createDomVisualElement = /* @__PURE__ */ __name2((Component3, options2) => {
      return isSVGComponent(Component3) ? new SVGVisualElement(options2) : new HTMLVisualElement(options2, {
        allowProjection: Component3 !== import_react29.Fragment
      });
    }, "createDomVisualElement");
  }
});
var createMotionComponent;
var init_create2 = __esm({
  "../node_modules/framer-motion/dist/es/render/components/motion/create.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_animations();
    init_drag2();
    init_gestures();
    init_layout();
    init_create_factory();
    init_create_visual_element();
    createMotionComponent = /* @__PURE__ */ createMotionComponentFactory({
      ...animations,
      ...gestureAnimations,
      ...drag,
      ...layout
    }, createDomVisualElement);
  }
});
var motion;
var init_proxy = __esm({
  "../node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_create_proxy();
    init_create2();
    motion = /* @__PURE__ */ createDOMMotionComponentProxy(createMotionComponent);
  }
});
var init_es3 = __esm({
  "../node_modules/framer-motion/dist/es/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_AnimatePresence();
    init_proxy();
    init_es2();
    init_es();
  }
});
function useId4(deterministicId) {
  const [id3, setId] = React17.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id3 ? `radix-${id3}` : "");
}
__name(useId4, "useId4");
var React17;
var useReactId;
var count;
var init_dist18 = __esm({
  "../node_modules/@radix-ui/react-id/dist/index.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React17 = __toESM(require_react(), 1);
    init_dist12();
    useReactId = React17[" useId ".trim().toString()] || (() => void 0);
    count = 0;
    __name2(useId4, "useId");
  }
});
function focusFirst2(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
__name(focusFirst2, "focusFirst2");
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates2(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
__name(getTabbableEdges, "getTabbableEdges");
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
__name(getTabbableCandidates2, "getTabbableCandidates2");
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container }))
      return element;
  }
}
__name(findVisible, "findVisible");
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
__name(isHidden, "isHidden");
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
__name(isSelectableInput, "isSelectableInput");
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
__name(focus, "focus");
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
__name(createFocusScopesStack, "createFocusScopesStack");
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
__name(arrayRemove, "arrayRemove");
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
__name(removeLinks, "removeLinks");
var React18;
var import_jsx_runtime16;
var AUTOFOCUS_ON_MOUNT;
var AUTOFOCUS_ON_UNMOUNT;
var EVENT_OPTIONS;
var FOCUS_SCOPE_NAME;
var FocusScope;
var focusScopesStack;
var init_dist19 = __esm({
  "../node_modules/@radix-ui/react-focus-scope/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React18 = __toESM(require_react(), 1);
    init_dist4();
    init_dist8();
    init_dist9();
    import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
    AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
    AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
    EVENT_OPTIONS = { bubbles: false, cancelable: true };
    FOCUS_SCOPE_NAME = "FocusScope";
    FocusScope = React18.forwardRef((props, forwardedRef) => {
      const {
        loop = false,
        trapped = false,
        onMountAutoFocus: onMountAutoFocusProp,
        onUnmountAutoFocus: onUnmountAutoFocusProp,
        ...scopeProps
      } = props;
      const [container, setContainer] = React18.useState(null);
      const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
      const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
      const lastFocusedElementRef = React18.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
      const focusScope = React18.useRef({
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      }).current;
      React18.useEffect(() => {
        if (trapped) {
          let handleFocusIn2 = /* @__PURE__ */ __name2(function(event) {
            if (focusScope.paused || !container)
              return;
            const target = event.target;
            if (container.contains(target)) {
              lastFocusedElementRef.current = target;
            } else {
              focus(lastFocusedElementRef.current, { select: true });
            }
          }, "handleFocusIn2"), handleFocusOut2 = /* @__PURE__ */ __name2(function(event) {
            if (focusScope.paused || !container)
              return;
            const relatedTarget = event.relatedTarget;
            if (relatedTarget === null)
              return;
            if (!container.contains(relatedTarget)) {
              focus(lastFocusedElementRef.current, { select: true });
            }
          }, "handleFocusOut2"), handleMutations2 = /* @__PURE__ */ __name2(function(mutations) {
            const focusedElement = document.activeElement;
            if (focusedElement !== document.body)
              return;
            for (const mutation of mutations) {
              if (mutation.removedNodes.length > 0)
                focus(container);
            }
          }, "handleMutations2");
          var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
          document.addEventListener("focusin", handleFocusIn2);
          document.addEventListener("focusout", handleFocusOut2);
          const mutationObserver = new MutationObserver(handleMutations2);
          if (container)
            mutationObserver.observe(container, { childList: true, subtree: true });
          return () => {
            document.removeEventListener("focusin", handleFocusIn2);
            document.removeEventListener("focusout", handleFocusOut2);
            mutationObserver.disconnect();
          };
        }
      }, [trapped, container, focusScope.paused]);
      React18.useEffect(() => {
        if (container) {
          focusScopesStack.add(focusScope);
          const previouslyFocusedElement = document.activeElement;
          const hasFocusedCandidate = container.contains(previouslyFocusedElement);
          if (!hasFocusedCandidate) {
            const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
            container.dispatchEvent(mountEvent);
            if (!mountEvent.defaultPrevented) {
              focusFirst2(removeLinks(getTabbableCandidates2(container)), { select: true });
              if (document.activeElement === previouslyFocusedElement) {
                focus(container);
              }
            }
          }
          return () => {
            container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
            setTimeout(() => {
              const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
              container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
              container.dispatchEvent(unmountEvent);
              if (!unmountEvent.defaultPrevented) {
                focus(previouslyFocusedElement ?? document.body, { select: true });
              }
              container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
              focusScopesStack.remove(focusScope);
            }, 0);
          };
        }
      }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
      const handleKeyDown = React18.useCallback(
        (event) => {
          if (!loop && !trapped)
            return;
          if (focusScope.paused)
            return;
          const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
          const focusedElement = document.activeElement;
          if (isTabKey && focusedElement) {
            const container2 = event.currentTarget;
            const [first, last] = getTabbableEdges(container2);
            const hasTabbableElementsInside = first && last;
            if (!hasTabbableElementsInside) {
              if (focusedElement === container2)
                event.preventDefault();
            } else {
              if (!event.shiftKey && focusedElement === last) {
                event.preventDefault();
                if (loop)
                  focus(first, { select: true });
              } else if (event.shiftKey && focusedElement === first) {
                event.preventDefault();
                if (loop)
                  focus(last, { select: true });
              }
            }
          }
        },
        [loop, trapped, focusScope.paused]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
    });
    FocusScope.displayName = FOCUS_SCOPE_NAME;
    __name2(focusFirst2, "focusFirst");
    __name2(getTabbableEdges, "getTabbableEdges");
    __name2(getTabbableCandidates2, "getTabbableCandidates");
    __name2(findVisible, "findVisible");
    __name2(isHidden, "isHidden");
    __name2(isSelectableInput, "isSelectableInput");
    __name2(focus, "focus");
    focusScopesStack = createFocusScopesStack();
    __name2(createFocusScopesStack, "createFocusScopesStack");
    __name2(arrayRemove, "arrayRemove");
    __name2(removeLinks, "removeLinks");
  }
});
function useFocusGuards() {
  React19.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
__name(useFocusGuards, "useFocusGuards");
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
__name(createFocusGuard, "createFocusGuard");
var React19;
var count2;
var init_dist20 = __esm({
  "../node_modules/@radix-ui/react-focus-guards/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React19 = __toESM(require_react(), 1);
    count2 = 0;
    __name2(useFocusGuards, "useFocusGuards");
    __name2(createFocusGuard, "createFocusGuard");
  }
});
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
__name(__rest, "__rest");
function __spreadArray(to3, from27, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from27.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from27)) {
        if (!ar)
          ar = Array.prototype.slice.call(from27, 0, i2);
        ar[i2] = from27[i2];
      }
    }
  return to3.concat(ar || Array.prototype.slice.call(from27));
}
__name(__spreadArray, "__spreadArray");
var __assign;
var init_tslib_es6 = __esm({
  "../node_modules/tslib/tslib.es6.mjs"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __assign = /* @__PURE__ */ __name2(function() {
      __assign = Object.assign || /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function __assign2(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      }, "__assign2"), "__assign");
      return __assign.apply(this, arguments);
    }, "__assign");
    __name2(__rest, "__rest");
    __name2(__spreadArray, "__spreadArray");
  }
});
var zeroRightClassName;
var fullWidthClassName;
var noScrollbarsClassName;
var removedBarSizeVariable;
var init_constants = __esm({
  "../node_modules/react-remove-scroll-bar/dist/es2015/constants.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    zeroRightClassName = "right-scroll-bar-position";
    fullWidthClassName = "width-before-scroll-bar";
    noScrollbarsClassName = "with-scroll-bars-hidden";
    removedBarSizeVariable = "--removed-body-scroll-bar-size";
  }
});
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
__name(assignRef, "assignRef");
var init_assignRef = __esm({
  "../node_modules/use-callback-ref/dist/es2015/assignRef.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(assignRef, "assignRef");
  }
});
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react30.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
__name(useCallbackRef2, "useCallbackRef2");
var import_react30;
var init_useRef = __esm({
  "../node_modules/use-callback-ref/dist/es2015/useRef.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    import_react30 = __toESM(require_react());
    __name2(useCallbackRef2, "useCallbackRef");
  }
});
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect2(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
__name(useMergeRefs, "useMergeRefs");
var React20;
var useIsomorphicLayoutEffect2;
var currentValues;
var init_useMergeRef = __esm({
  "../node_modules/use-callback-ref/dist/es2015/useMergeRef.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React20 = __toESM(require_react());
    init_assignRef();
    init_useRef();
    useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React20.useLayoutEffect : React20.useEffect;
    currentValues = /* @__PURE__ */ new WeakMap();
    __name2(useMergeRefs, "useMergeRefs");
  }
});
var init_es2015 = __esm({
  "../node_modules/use-callback-ref/dist/es2015/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_useMergeRef();
  }
});
function ItoI(a2) {
  return a2;
}
__name(ItoI, "ItoI");
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = /* @__PURE__ */ __name2(function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      }, "executeQueue");
      var cycle = /* @__PURE__ */ __name2(function() {
        return Promise.resolve().then(executeQueue);
      }, "cycle");
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
__name(innerCreateMedium, "innerCreateMedium");
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options2);
  return medium;
}
__name(createSidecarMedium, "createSidecarMedium");
var init_medium = __esm({
  "../node_modules/use-sidecar/dist/es2015/medium.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_tslib_es6();
    __name2(ItoI, "ItoI");
    __name2(innerCreateMedium, "innerCreateMedium");
    __name2(createSidecarMedium, "createSidecarMedium");
  }
});
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}
__name(exportSidecar, "exportSidecar");
var React21;
var SideCar;
var init_exports2 = __esm({
  "../node_modules/use-sidecar/dist/es2015/exports.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_tslib_es6();
    React21 = __toESM(require_react());
    SideCar = /* @__PURE__ */ __name2(function(_a) {
      var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
      if (!sideCar) {
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
      }
      var Target = sideCar.read();
      if (!Target) {
        throw new Error("Sidecar medium not found");
      }
      return React21.createElement(Target, __assign({}, rest));
    }, "SideCar");
    SideCar.isSideCarExport = true;
    __name2(exportSidecar, "exportSidecar");
  }
});
var init_es20152 = __esm({
  "../node_modules/use-sidecar/dist/es2015/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_medium();
    init_exports2();
  }
});
var effectCar;
var init_medium2 = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/medium.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es20152();
    effectCar = createSidecarMedium();
  }
});
var React25;
var nothing;
var RemoveScroll;
var init_UI = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/UI.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_tslib_es6();
    React25 = __toESM(require_react());
    init_constants();
    init_es2015();
    init_medium2();
    nothing = /* @__PURE__ */ __name2(function() {
      return;
    }, "nothing");
    RemoveScroll = React25.forwardRef(function(props, parentRef) {
      var ref = React25.useRef(null);
      var _a = React25.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing
      }), callbacks = _a[0], setCallbacks = _a[1];
      var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
      var SideCar2 = sideCar;
      var containerRef = useMergeRefs([ref, parentRef]);
      var containerProps = __assign(__assign({}, rest), callbacks);
      return React25.createElement(
        React25.Fragment,
        null,
        enabled && React25.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
        forwardProps ? React25.cloneElement(React25.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React25.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
      );
    });
    RemoveScroll.defaultProps = {
      enabled: true,
      removeScrollBar: true,
      inert: false
    };
    RemoveScroll.classNames = {
      fullWidth: fullWidthClassName,
      zeroRight: zeroRightClassName
    };
  }
});
var currentNonce;
var getNonce;
var init_es20153 = __esm({
  "../node_modules/get-nonce/dist/es2015/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    getNonce = /* @__PURE__ */ __name2(function() {
      if (currentNonce) {
        return currentNonce;
      }
      if (typeof __webpack_nonce__ !== "undefined") {
        return __webpack_nonce__;
      }
      return void 0;
    }, "getNonce");
  }
});
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
__name(makeStyleTag, "makeStyleTag");
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
__name(injectStyles, "injectStyles");
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
__name(insertStyleTag, "insertStyleTag");
var stylesheetSingleton;
var init_singleton = __esm({
  "../node_modules/react-style-singleton/dist/es2015/singleton.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es20153();
    __name2(makeStyleTag, "makeStyleTag");
    __name2(injectStyles, "injectStyles");
    __name2(insertStyleTag, "insertStyleTag");
    stylesheetSingleton = /* @__PURE__ */ __name2(function() {
      var counter = 0;
      var stylesheet = null;
      return {
        add: function(style) {
          if (counter == 0) {
            if (stylesheet = makeStyleTag()) {
              injectStyles(stylesheet, style);
              insertStyleTag(stylesheet);
            }
          }
          counter++;
        },
        remove: function() {
          counter--;
          if (!counter && stylesheet) {
            stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
            stylesheet = null;
          }
        }
      };
    }, "stylesheetSingleton");
  }
});
var React26;
var styleHookSingleton;
var init_hook = __esm({
  "../node_modules/react-style-singleton/dist/es2015/hook.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React26 = __toESM(require_react());
    init_singleton();
    styleHookSingleton = /* @__PURE__ */ __name2(function() {
      var sheet = stylesheetSingleton();
      return function(styles, isDynamic) {
        React26.useEffect(function() {
          sheet.add(styles);
          return function() {
            sheet.remove();
          };
        }, [styles && isDynamic]);
      };
    }, "styleHookSingleton");
  }
});
var styleSingleton;
var init_component = __esm({
  "../node_modules/react-style-singleton/dist/es2015/component.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_hook();
    styleSingleton = /* @__PURE__ */ __name2(function() {
      var useStyle2 = styleHookSingleton();
      var Sheet = /* @__PURE__ */ __name2(function(_a) {
        var styles = _a.styles, dynamic = _a.dynamic;
        useStyle2(styles, dynamic);
        return null;
      }, "Sheet");
      return Sheet;
    }, "styleSingleton");
  }
});
var init_es20154 = __esm({
  "../node_modules/react-style-singleton/dist/es2015/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_component();
    init_singleton();
    init_hook();
  }
});
var zeroGap;
var parse3;
var getOffset;
var getGapWidth;
var init_utils8 = __esm({
  "../node_modules/react-remove-scroll-bar/dist/es2015/utils.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    zeroGap = {
      left: 0,
      top: 0,
      right: 0,
      gap: 0
    };
    parse3 = /* @__PURE__ */ __name2(function(x2) {
      return parseInt(x2 || "", 10) || 0;
    }, "parse");
    getOffset = /* @__PURE__ */ __name2(function(gapMode) {
      var cs = window.getComputedStyle(document.body);
      var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
      var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
      var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
      return [parse3(left), parse3(top), parse3(right)];
    }, "getOffset");
    getGapWidth = /* @__PURE__ */ __name2(function(gapMode) {
      if (gapMode === void 0) {
        gapMode = "margin";
      }
      if (typeof window === "undefined") {
        return zeroGap;
      }
      var offsets = getOffset(gapMode);
      var documentWidth = document.documentElement.clientWidth;
      var windowWidth = window.innerWidth;
      return {
        left: offsets[0],
        top: offsets[1],
        right: offsets[2],
        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
      };
    }, "getGapWidth");
  }
});
var React27;
var Style;
var lockAttribute;
var getStyles;
var getCurrentUseCounter;
var useLockAttribute;
var RemoveScrollBar;
var init_component2 = __esm({
  "../node_modules/react-remove-scroll-bar/dist/es2015/component.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React27 = __toESM(require_react());
    init_es20154();
    init_constants();
    init_utils8();
    Style = styleSingleton();
    lockAttribute = "data-scroll-locked";
    getStyles = /* @__PURE__ */ __name2(function(_a, allowRelative, gapMode, important) {
      var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
      if (gapMode === void 0) {
        gapMode = "margin";
      }
      return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
        allowRelative && "position: relative ".concat(important, ";"),
        gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
        gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
      ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
    }, "getStyles");
    getCurrentUseCounter = /* @__PURE__ */ __name2(function() {
      var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
      return isFinite(counter) ? counter : 0;
    }, "getCurrentUseCounter");
    useLockAttribute = /* @__PURE__ */ __name2(function() {
      React27.useEffect(function() {
        document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
        return function() {
          var newCounter = getCurrentUseCounter() - 1;
          if (newCounter <= 0) {
            document.body.removeAttribute(lockAttribute);
          } else {
            document.body.setAttribute(lockAttribute, newCounter.toString());
          }
        };
      }, []);
    }, "useLockAttribute");
    RemoveScrollBar = /* @__PURE__ */ __name2(function(_a) {
      var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
      useLockAttribute();
      var gap = React27.useMemo(function() {
        return getGapWidth(gapMode);
      }, [gapMode]);
      return React27.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
    }, "RemoveScrollBar");
  }
});
var init_es20155 = __esm({
  "../node_modules/react-remove-scroll-bar/dist/es2015/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_component2();
    init_constants();
    init_utils8();
  }
});
var passiveSupported;
var options;
var nonPassive;
var init_aggresiveCapture = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    passiveSupported = false;
    if (typeof window !== "undefined") {
      try {
        options = Object.defineProperty({}, "passive", {
          get: function() {
            passiveSupported = true;
            return true;
          }
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (err) {
        passiveSupported = false;
      }
    }
    nonPassive = passiveSupported ? { passive: false } : false;
  }
});
var alwaysContainsScroll;
var elementCanBeScrolled;
var elementCouldBeVScrolled;
var elementCouldBeHScrolled;
var locationCouldBeScrolled;
var getVScrollVariables;
var getHScrollVariables;
var elementCouldBeScrolled;
var getScrollVariables;
var getDirectionFactor;
var handleScroll;
var init_handleScroll = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/handleScroll.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    alwaysContainsScroll = /* @__PURE__ */ __name2(function(node) {
      return node.tagName === "TEXTAREA";
    }, "alwaysContainsScroll");
    elementCanBeScrolled = /* @__PURE__ */ __name2(function(node, overflow) {
      if (!(node instanceof Element)) {
        return false;
      }
      var styles = window.getComputedStyle(node);
      return (
        // not-not-scrollable
        styles[overflow] !== "hidden" && // contains scroll inside self
        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
      );
    }, "elementCanBeScrolled");
    elementCouldBeVScrolled = /* @__PURE__ */ __name2(function(node) {
      return elementCanBeScrolled(node, "overflowY");
    }, "elementCouldBeVScrolled");
    elementCouldBeHScrolled = /* @__PURE__ */ __name2(function(node) {
      return elementCanBeScrolled(node, "overflowX");
    }, "elementCouldBeHScrolled");
    locationCouldBeScrolled = /* @__PURE__ */ __name2(function(axis, node) {
      var ownerDocument = node.ownerDocument;
      var current = node;
      do {
        if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
          current = current.host;
        }
        var isScrollable = elementCouldBeScrolled(axis, current);
        if (isScrollable) {
          var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
          if (scrollHeight > clientHeight) {
            return true;
          }
        }
        current = current.parentNode;
      } while (current && current !== ownerDocument.body);
      return false;
    }, "locationCouldBeScrolled");
    getVScrollVariables = /* @__PURE__ */ __name2(function(_a) {
      var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
      return [
        scrollTop,
        scrollHeight,
        clientHeight
      ];
    }, "getVScrollVariables");
    getHScrollVariables = /* @__PURE__ */ __name2(function(_a) {
      var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
      return [
        scrollLeft,
        scrollWidth,
        clientWidth
      ];
    }, "getHScrollVariables");
    elementCouldBeScrolled = /* @__PURE__ */ __name2(function(axis, node) {
      return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
    }, "elementCouldBeScrolled");
    getScrollVariables = /* @__PURE__ */ __name2(function(axis, node) {
      return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
    }, "getScrollVariables");
    getDirectionFactor = /* @__PURE__ */ __name2(function(axis, direction) {
      return axis === "h" && direction === "rtl" ? -1 : 1;
    }, "getDirectionFactor");
    handleScroll = /* @__PURE__ */ __name2(function(axis, endTarget, event, sourceDelta, noOverscroll) {
      var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
      var delta = directionFactor * sourceDelta;
      var target = event.target;
      var targetInLock = endTarget.contains(target);
      var shouldCancelScroll = false;
      var isDeltaPositive = delta > 0;
      var availableScroll = 0;
      var availableScrollTop = 0;
      do {
        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
        var elementScroll = scroll_1 - capacity - directionFactor * position;
        if (position || elementScroll) {
          if (elementCouldBeScrolled(axis, target)) {
            availableScroll += elementScroll;
            availableScrollTop += position;
          }
        }
        if (target instanceof ShadowRoot) {
          target = target.host;
        } else {
          target = target.parentNode;
        }
      } while (
        // portaled content
        !targetInLock && target !== document.body || // self content
        targetInLock && (endTarget.contains(target) || endTarget === target)
      );
      if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
        shouldCancelScroll = true;
      } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
        shouldCancelScroll = true;
      }
      return shouldCancelScroll;
    }, "handleScroll");
  }
});
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React28.useRef([]);
  var touchStartRef = React28.useRef([0, 0]);
  var activeAxis = React28.useRef();
  var id3 = React28.useState(idCounter++)[0];
  var Style2 = React28.useState(styleSingleton)[0];
  var lastProps = React28.useRef(props);
  React28.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React28.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id3));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id3));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id3));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id3));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React28.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React28.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React28.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React28.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React28.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React28.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React28.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React28.createElement(
    React28.Fragment,
    null,
    inert ? React28.createElement(Style2, { styles: generateStyle(id3) }) : null,
    removeScrollBar ? React28.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
__name(RemoveScrollSideCar, "RemoveScrollSideCar");
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
__name(getOutermostShadowParent, "getOutermostShadowParent");
var React28;
var getTouchXY;
var getDeltaXY;
var extractRef;
var deltaCompare;
var generateStyle;
var idCounter;
var lockStack;
var init_SideEffect = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/SideEffect.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_tslib_es6();
    React28 = __toESM(require_react());
    init_es20155();
    init_es20154();
    init_aggresiveCapture();
    init_handleScroll();
    getTouchXY = /* @__PURE__ */ __name2(function(event) {
      return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
    }, "getTouchXY");
    getDeltaXY = /* @__PURE__ */ __name2(function(event) {
      return [event.deltaX, event.deltaY];
    }, "getDeltaXY");
    extractRef = /* @__PURE__ */ __name2(function(ref) {
      return ref && "current" in ref ? ref.current : ref;
    }, "extractRef");
    deltaCompare = /* @__PURE__ */ __name2(function(x2, y2) {
      return x2[0] === y2[0] && x2[1] === y2[1];
    }, "deltaCompare");
    generateStyle = /* @__PURE__ */ __name2(function(id3) {
      return "\n  .block-interactivity-".concat(id3, " {pointer-events: none;}\n  .allow-interactivity-").concat(id3, " {pointer-events: all;}\n");
    }, "generateStyle");
    idCounter = 0;
    lockStack = [];
    __name2(RemoveScrollSideCar, "RemoveScrollSideCar");
    __name2(getOutermostShadowParent, "getOutermostShadowParent");
  }
});
var sidecar_default;
var init_sidecar = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/sidecar.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_es20152();
    init_SideEffect();
    init_medium2();
    sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);
  }
});
var React29;
var ReactRemoveScroll;
var Combination_default;
var init_Combination = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/Combination.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_tslib_es6();
    React29 = __toESM(require_react());
    init_UI();
    init_sidecar();
    ReactRemoveScroll = React29.forwardRef(function(props, ref) {
      return React29.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
    });
    ReactRemoveScroll.classNames = RemoveScroll.classNames;
    Combination_default = ReactRemoveScroll;
  }
});
var init_es20156 = __esm({
  "../node_modules/react-remove-scroll/dist/es2015/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_Combination();
  }
});
var getDefaultParent;
var counterMap;
var uncontrolledNodes;
var markerMap;
var lockCount;
var unwrapHost;
var correctTargets;
var applyAttributeToOthers;
var hideOthers;
var init_es20157 = __esm({
  "../node_modules/aria-hidden/dist/es2015/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    getDefaultParent = /* @__PURE__ */ __name2(function(originalTarget) {
      if (typeof document === "undefined") {
        return null;
      }
      var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
      return sampleTarget.ownerDocument.body;
    }, "getDefaultParent");
    counterMap = /* @__PURE__ */ new WeakMap();
    uncontrolledNodes = /* @__PURE__ */ new WeakMap();
    markerMap = {};
    lockCount = 0;
    unwrapHost = /* @__PURE__ */ __name2(function(node) {
      return node && (node.host || unwrapHost(node.parentNode));
    }, "unwrapHost");
    correctTargets = /* @__PURE__ */ __name2(function(parent, targets) {
      return targets.map(function(target) {
        if (parent.contains(target)) {
          return target;
        }
        var correctedTarget = unwrapHost(target);
        if (correctedTarget && parent.contains(correctedTarget)) {
          return correctedTarget;
        }
        console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
        return null;
      }).filter(function(x2) {
        return Boolean(x2);
      });
    }, "correctTargets");
    applyAttributeToOthers = /* @__PURE__ */ __name2(function(originalTarget, parentNode, markerName, controlAttribute) {
      var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
      if (!markerMap[markerName]) {
        markerMap[markerName] = /* @__PURE__ */ new WeakMap();
      }
      var markerCounter = markerMap[markerName];
      var hiddenNodes = [];
      var elementsToKeep = /* @__PURE__ */ new Set();
      var elementsToStop = new Set(targets);
      var keep = /* @__PURE__ */ __name2(function(el) {
        if (!el || elementsToKeep.has(el)) {
          return;
        }
        elementsToKeep.add(el);
        keep(el.parentNode);
      }, "keep");
      targets.forEach(keep);
      var deep = /* @__PURE__ */ __name2(function(parent) {
        if (!parent || elementsToStop.has(parent)) {
          return;
        }
        Array.prototype.forEach.call(parent.children, function(node) {
          if (elementsToKeep.has(node)) {
            deep(node);
          } else {
            try {
              var attr = node.getAttribute(controlAttribute);
              var alreadyHidden = attr !== null && attr !== "false";
              var counterValue = (counterMap.get(node) || 0) + 1;
              var markerValue = (markerCounter.get(node) || 0) + 1;
              counterMap.set(node, counterValue);
              markerCounter.set(node, markerValue);
              hiddenNodes.push(node);
              if (counterValue === 1 && alreadyHidden) {
                uncontrolledNodes.set(node, true);
              }
              if (markerValue === 1) {
                node.setAttribute(markerName, "true");
              }
              if (!alreadyHidden) {
                node.setAttribute(controlAttribute, "true");
              }
            } catch (e2) {
              console.error("aria-hidden: cannot operate on ", node, e2);
            }
          }
        });
      }, "deep");
      deep(parentNode);
      elementsToKeep.clear();
      lockCount++;
      return function() {
        hiddenNodes.forEach(function(node) {
          var counterValue = counterMap.get(node) - 1;
          var markerValue = markerCounter.get(node) - 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          if (!counterValue) {
            if (!uncontrolledNodes.has(node)) {
              node.removeAttribute(controlAttribute);
            }
            uncontrolledNodes.delete(node);
          }
          if (!markerValue) {
            node.removeAttribute(markerName);
          }
        });
        lockCount--;
        if (!lockCount) {
          counterMap = /* @__PURE__ */ new WeakMap();
          counterMap = /* @__PURE__ */ new WeakMap();
          uncontrolledNodes = /* @__PURE__ */ new WeakMap();
          markerMap = {};
        }
      };
    }, "applyAttributeToOthers");
    hideOthers = /* @__PURE__ */ __name2(function(originalTarget, parentNode, markerName) {
      if (markerName === void 0) {
        markerName = "data-aria-hidden";
      }
      var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
      var activeParentNode = parentNode || getDefaultParent(originalTarget);
      if (!activeParentNode) {
        return function() {
          return null;
        };
      }
      targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
      return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
    }, "hideOthers");
  }
});
function getState(open) {
  return open ? "open" : "closed";
}
__name(getState, "getState");
var React30;
var import_jsx_runtime17;
var DIALOG_NAME;
var createDialogContext;
var createDialogScope;
var DialogProvider;
var useDialogContext;
var Dialog;
var TRIGGER_NAME;
var DialogTrigger;
var PORTAL_NAME2;
var PortalProvider;
var usePortalContext;
var DialogPortal;
var OVERLAY_NAME;
var DialogOverlay;
var Slot;
var DialogOverlayImpl;
var CONTENT_NAME;
var DialogContent;
var DialogContentModal;
var DialogContentNonModal;
var DialogContentImpl;
var TITLE_NAME2;
var DialogTitle;
var DESCRIPTION_NAME2;
var DialogDescription;
var CLOSE_NAME2;
var DialogClose;
var TITLE_WARNING_NAME;
var WarningProvider;
var useWarningContext;
var TitleWarning;
var DESCRIPTION_WARNING_NAME;
var DescriptionWarning;
var Root2;
var Portal2;
var Overlay;
var Content;
var Close;
var init_dist21 = __esm({
  "../node_modules/@radix-ui/react-dialog/dist/index.mjs"() {
    "use client";
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    React30 = __toESM(require_react(), 1);
    init_dist3();
    init_dist4();
    init_dist5();
    init_dist18();
    init_dist15();
    init_dist11();
    init_dist19();
    init_dist13();
    init_dist14();
    init_dist8();
    init_dist20();
    init_es20156();
    init_es20157();
    init_dist6();
    import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
    DIALOG_NAME = "Dialog";
    [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
    [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
    Dialog = /* @__PURE__ */ __name2((props) => {
      const {
        __scopeDialog,
        children,
        open: openProp,
        defaultOpen,
        onOpenChange,
        modal = true
      } = props;
      const triggerRef = React30.useRef(null);
      const contentRef = React30.useRef(null);
      const [open, setOpen] = useControllableState({
        prop: openProp,
        defaultProp: defaultOpen ?? false,
        onChange: onOpenChange,
        caller: DIALOG_NAME
      });
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        DialogProvider,
        {
          scope: __scopeDialog,
          triggerRef,
          contentRef,
          contentId: useId4(),
          titleId: useId4(),
          descriptionId: useId4(),
          open,
          onOpenChange: setOpen,
          onOpenToggle: React30.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
          modal,
          children
        }
      );
    }, "Dialog");
    Dialog.displayName = DIALOG_NAME;
    TRIGGER_NAME = "DialogTrigger";
    DialogTrigger = React30.forwardRef(
      (props, forwardedRef) => {
        const { __scopeDialog, ...triggerProps } = props;
        const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
        const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          Primitive.button,
          {
            type: "button",
            "aria-haspopup": "dialog",
            "aria-expanded": context.open,
            "aria-controls": context.contentId,
            "data-state": getState(context.open),
            ...triggerProps,
            ref: composedTriggerRef,
            onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
          }
        );
      }
    );
    DialogTrigger.displayName = TRIGGER_NAME;
    PORTAL_NAME2 = "DialogPortal";
    [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
      forceMount: void 0
    });
    DialogPortal = /* @__PURE__ */ __name2((props) => {
      const { __scopeDialog, forceMount, children, container } = props;
      const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React30.Children.map(children, (child) => /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Portal, { asChild: true, container, children: child }) })) });
    }, "DialogPortal");
    DialogPortal.displayName = PORTAL_NAME2;
    OVERLAY_NAME = "DialogOverlay";
    DialogOverlay = React30.forwardRef(
      (props, forwardedRef) => {
        const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
        const { forceMount = portalContext.forceMount, ...overlayProps } = props;
        const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
        return context.modal ? /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
      }
    );
    DialogOverlay.displayName = OVERLAY_NAME;
    Slot = createSlot("DialogOverlay.RemoveScroll");
    DialogOverlayImpl = React30.forwardRef(
      (props, forwardedRef) => {
        const { __scopeDialog, ...overlayProps } = props;
        const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
        return (
          // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
          // ie. when `Overlay` and `Content` are siblings
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            Primitive.div,
            {
              "data-state": getState(context.open),
              ...overlayProps,
              ref: forwardedRef,
              style: { pointerEvents: "auto", ...overlayProps.style }
            }
          ) })
        );
      }
    );
    CONTENT_NAME = "DialogContent";
    DialogContent = React30.forwardRef(
      (props, forwardedRef) => {
        const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
        const { forceMount = portalContext.forceMount, ...contentProps } = props;
        const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
      }
    );
    DialogContent.displayName = CONTENT_NAME;
    DialogContentModal = React30.forwardRef(
      (props, forwardedRef) => {
        const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
        const contentRef = React30.useRef(null);
        const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
        React30.useEffect(() => {
          const content = contentRef.current;
          if (content)
            return hideOthers(content);
        }, []);
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          DialogContentImpl,
          {
            ...props,
            ref: composedRefs,
            trapFocus: context.open,
            disableOutsidePointerEvents: true,
            onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
              event.preventDefault();
              context.triggerRef.current?.focus();
            }),
            onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
              const originalEvent = event.detail.originalEvent;
              const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
              const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
              if (isRightClick)
                event.preventDefault();
            }),
            onFocusOutside: composeEventHandlers(
              props.onFocusOutside,
              (event) => event.preventDefault()
            )
          }
        );
      }
    );
    DialogContentNonModal = React30.forwardRef(
      (props, forwardedRef) => {
        const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
        const hasInteractedOutsideRef = React30.useRef(false);
        const hasPointerDownOutsideRef = React30.useRef(false);
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          DialogContentImpl,
          {
            ...props,
            ref: forwardedRef,
            trapFocus: false,
            disableOutsidePointerEvents: false,
            onCloseAutoFocus: (event) => {
              props.onCloseAutoFocus?.(event);
              if (!event.defaultPrevented) {
                if (!hasInteractedOutsideRef.current)
                  context.triggerRef.current?.focus();
                event.preventDefault();
              }
              hasInteractedOutsideRef.current = false;
              hasPointerDownOutsideRef.current = false;
            },
            onInteractOutside: (event) => {
              props.onInteractOutside?.(event);
              if (!event.defaultPrevented) {
                hasInteractedOutsideRef.current = true;
                if (event.detail.originalEvent.type === "pointerdown") {
                  hasPointerDownOutsideRef.current = true;
                }
              }
              const target = event.target;
              const targetIsTrigger = context.triggerRef.current?.contains(target);
              if (targetIsTrigger)
                event.preventDefault();
              if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
                event.preventDefault();
              }
            }
          }
        );
      }
    );
    DialogContentImpl = React30.forwardRef(
      (props, forwardedRef) => {
        const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
        const context = useDialogContext(CONTENT_NAME, __scopeDialog);
        const contentRef = React30.useRef(null);
        const composedRefs = useComposedRefs(forwardedRef, contentRef);
        useFocusGuards();
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            FocusScope,
            {
              asChild: true,
              loop: true,
              trapped: trapFocus,
              onMountAutoFocus: onOpenAutoFocus,
              onUnmountAutoFocus: onCloseAutoFocus,
              children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
                DismissableLayer,
                {
                  role: "dialog",
                  id: context.contentId,
                  "aria-describedby": context.descriptionId,
                  "aria-labelledby": context.titleId,
                  "data-state": getState(context.open),
                  ...contentProps,
                  ref: composedRefs,
                  onDismiss: () => context.onOpenChange(false)
                }
              )
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(TitleWarning, { titleId: context.titleId }),
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
          ] })
        ] });
      }
    );
    TITLE_NAME2 = "DialogTitle";
    DialogTitle = React30.forwardRef(
      (props, forwardedRef) => {
        const { __scopeDialog, ...titleProps } = props;
        const context = useDialogContext(TITLE_NAME2, __scopeDialog);
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
      }
    );
    DialogTitle.displayName = TITLE_NAME2;
    DESCRIPTION_NAME2 = "DialogDescription";
    DialogDescription = React30.forwardRef(
      (props, forwardedRef) => {
        const { __scopeDialog, ...descriptionProps } = props;
        const context = useDialogContext(DESCRIPTION_NAME2, __scopeDialog);
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
      }
    );
    DialogDescription.displayName = DESCRIPTION_NAME2;
    CLOSE_NAME2 = "DialogClose";
    DialogClose = React30.forwardRef(
      (props, forwardedRef) => {
        const { __scopeDialog, ...closeProps } = props;
        const context = useDialogContext(CLOSE_NAME2, __scopeDialog);
        return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          Primitive.button,
          {
            type: "button",
            ...closeProps,
            ref: forwardedRef,
            onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
          }
        );
      }
    );
    DialogClose.displayName = CLOSE_NAME2;
    __name2(getState, "getState");
    TITLE_WARNING_NAME = "DialogTitleWarning";
    [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
      contentName: CONTENT_NAME,
      titleName: TITLE_NAME2,
      docsSlug: "dialog"
    });
    TitleWarning = /* @__PURE__ */ __name2(({ titleId }) => {
      const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
      const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
      React30.useEffect(() => {
        if (titleId) {
          const hasTitle = document.getElementById(titleId);
          if (!hasTitle)
            console.error(MESSAGE);
        }
      }, [MESSAGE, titleId]);
      return null;
    }, "TitleWarning");
    DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
    DescriptionWarning = /* @__PURE__ */ __name2(({ contentRef, descriptionId }) => {
      const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
      const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
      React30.useEffect(() => {
        const describedById = contentRef.current?.getAttribute("aria-describedby");
        if (descriptionId && describedById) {
          const hasDescription = document.getElementById(descriptionId);
          if (!hasDescription)
            console.warn(MESSAGE);
        }
      }, [MESSAGE, contentRef, descriptionId]);
      return null;
    }, "DescriptionWarning");
    Root2 = Dialog;
    Portal2 = DialogPortal;
    Overlay = DialogOverlay;
    Content = DialogContent;
    Close = DialogClose;
  }
});
var init_hashing = __esm({
  "../node_modules/@worldcoin/idkit-core/build/lib/hashing.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_chunk_HZ2SQA5V();
  }
});
async function verifyCloudProof(proof, app_id, action, signal, endpoint) {
  if (isBrowser) {
    throw new Error("verifyCloudProof can only be used in the backend.");
  }
  const response = await fetch(endpoint ?? `https://developer.worldcoin.org/api/v2/verify/${app_id}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      ...proof,
      action,
      signal_hash: hashToField(signal ?? "").digest
    })
  });
  if (response.ok) {
    return { success: true };
  } else {
    return { success: false, ...await response.json() };
  }
}
__name(verifyCloudProof, "verifyCloudProof");
var init_backend = __esm({
  "../node_modules/@worldcoin/idkit-core/build/lib/backend.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_chunk_HZ2SQA5V();
    init_dist2();
    __name2(verifyCloudProof, "verifyCloudProof");
  }
});
function r2(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++)
        e2[t2] && (f2 = r2(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e2)
        e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
__name(r2, "r2");
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++)
    (e2 = arguments[f2]) && (t2 = r2(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
__name(clsx, "clsx");
var import_react31;
var import_react32;
var import_react33;
var import_jsx_runtime18;
var import_jsx_runtime19;
var import_jsx_runtime20;
var import_jsx_runtime21;
var import_jsx_runtime22;
var import_jsx_runtime23;
var import_jsx_runtime24;
var import_jsx_runtime25;
var import_copy_to_clipboard;
var import_react34;
var import_jsx_runtime26;
var import_jsx_runtime27;
var import_jsx_runtime28;
var import_react35;
var import_react36;
var import_jsx_runtime29;
var import_jsx_runtime30;
var import_react37;
var import_react38;
var import_jsx_runtime31;
var import_jsx_runtime32;
var useMedia;
var useMedia_default;
var styles_default;
var Styles;
var Styles_default;
var XMarkIcon;
var XMarkIcon_default;
var ErrorIcon;
var ErrorIcon_default;
var ReloadIcon;
var ReloadIcon_default;
var WarningIcon;
var WarningIcon_default;
var getParams;
var ERROR_TITLES;
var ERROR_MESSAGES;
var ErrorState;
var ErrorState_default;
var CheckIcon;
var CheckIcon_default;
var SuccessState;
var SuccessState_default;
var clsx_default;
var WorldcoinIcon;
var WorldcoinIcon_default;
var QRPlaceholderIcon;
var QRPlaceholderIcon_default;
var QRState;
var QRState_default;
var useWorldBridge;
var LoadingIcon;
var LoadingIcon_default;
var getOptions;
var WorldIDState;
var WorldIDState_default;
var HostAppVerificationState;
var HostAppVerificationState_default;
var getParams2;
var IDKitWidget;
var BaseWidget_default;
var IDKitWidget_default;
var init_build2 = __esm({
  "../node_modules/@worldcoin/idkit/build/index.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_chunk_5OWPJUHG();
    import_react31 = __toESM(require_react(), 1);
    import_react32 = __toESM(require_react(), 1);
    init_react_shadow_esm();
    import_react33 = __toESM(require_react(), 1);
    import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
    init_shallow();
    import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
    import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
    init_build();
    import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
    import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
    import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
    init_dist17();
    import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
    import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
    import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);
    import_react34 = __toESM(require_react(), 1);
    init_es3();
    import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
    import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
    import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
    init_shallow();
    import_react35 = __toESM(require_react(), 1);
    import_react36 = __toESM(require_react(), 1);
    init_build();
    import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
    init_build();
    import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
    init_dist21();
    import_react37 = __toESM(require_react(), 1);
    init_es3();
    import_react38 = __toESM(require_react(), 1);
    import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
    import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
    init_build();
    init_hashing();
    init_backend();
    useMedia = /* @__PURE__ */ __name2(() => {
      const [media, setMedia] = (0, import_react33.useState)("desktop");
      (0, import_react33.useEffect)(() => {
        const mql = window.matchMedia("(max-width: 768px)");
        const handleChange = /* @__PURE__ */ __name2((mql2) => setMedia(mql2.matches ? "mobile" : "desktop"), "handleChange");
        handleChange(mql);
        mql.addEventListener("change", handleChange);
        return () => {
          mql.removeEventListener("change", handleChange);
        };
      }, []);
      return media;
    }, "useMedia");
    useMedia_default = useMedia;
    styles_default = `/* TODO: Use an alternative to avoid the extra request to Google (e.g. hosting ourselves, or local file)  */
@import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;600;700&family=Sora:wght@600&display=swap');
/* ! tailwindcss v3.4.4 | MIT License | https://tailwindcss.com  */
/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/
*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}
::before,
::after {
  --tw-content: '';
}
/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/
html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: Rubik, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}
/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/
body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}
/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/
hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}
/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/
abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}
/*
Remove the default font size and weight for headings.
*/
h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}
/*
Reset links to optimize for opt-in styling instead of opt-out.
*/
a {
  color: inherit;
  text-decoration: inherit;
}
/*
Add the correct font weight in Edge and Safari.
*/
b,
strong {
  font-weight: bolder;
}
/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/
code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}
/*
Add the correct font size in all browsers.
*/
small {
  font-size: 80%;
}
/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/
table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}
/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/
button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}
/*
Remove the inheritance of text transform in Edge and Firefox.
*/
button,
select {
  text-transform: none;
}
/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/
button,
input:where([type='button']),
input:where([type='reset']),
input:where([type='submit']) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}
/*
Use the modern Firefox focus style for all focusable elements.
*/
:-moz-focusring {
  outline: auto;
}
/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/
:-moz-ui-invalid {
  box-shadow: none;
}
/*
Add the correct vertical alignment in Chrome and Firefox.
*/
progress {
  vertical-align: baseline;
}
/*
Correct the cursor style of increment and decrement buttons in Safari.
*/
::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}
/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/
[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}
/*
Remove the inner padding in Chrome and Safari on macOS.
*/
::-webkit-search-decoration {
  -webkit-appearance: none;
}
/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/
::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}
/*
Add the correct display in Chrome and Safari.
*/
summary {
  display: list-item;
}
/*
Removes the default spacing and border for appropriate elements.
*/
blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}
fieldset {
  margin: 0;
  padding: 0;
}
legend {
  padding: 0;
}
ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}
/*
Reset default styling for dialogs.
*/
dialog {
  padding: 0;
}
/*
Prevent resizing textareas horizontally by default.
*/
textarea {
  resize: vertical;
}
/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/
input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}
input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}
/*
Set the default cursor for buttons.
*/
button,
[role="button"] {
  cursor: pointer;
}
/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}
/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/
img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}
/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/
img,
video {
  max-width: 100%;
  height: auto;
}
/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}
[type='text'],input:where(:not([type])),[type='email'],[type='url'],[type='password'],[type='number'],[type='date'],[type='datetime-local'],[type='month'],[type='search'],[type='tel'],[type='time'],[type='week'],[multiple],textarea,select{
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  background-color: #fff;
  border-color: #6b7280;
  border-width: 1px;
  border-radius: 0px;
  padding-top: 0.5rem;
  padding-right: 0.75rem;
  padding-bottom: 0.5rem;
  padding-left: 0.75rem;
  font-size: 1rem;
  line-height: 1.5rem;
  --tw-shadow: 0 0 #0000;
}
[type='text']:focus, input:where(:not([type])):focus, [type='email']:focus, [type='url']:focus, [type='password']:focus, [type='number']:focus, [type='date']:focus, [type='datetime-local']:focus, [type='month']:focus, [type='search']:focus, [type='tel']:focus, [type='time']:focus, [type='week']:focus, [multiple]:focus, textarea:focus, select:focus{
  outline: 2px solid transparent;
  outline-offset: 2px;
  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #2563eb;
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  border-color: #2563eb;
}
input::-moz-placeholder, textarea::-moz-placeholder{
  color: #6b7280;
  opacity: 1;
}
input::placeholder,textarea::placeholder{
  color: #6b7280;
  opacity: 1;
}
::-webkit-datetime-edit-fields-wrapper{
  padding: 0;
}
::-webkit-date-and-time-value{
  min-height: 1.5em;
  text-align: inherit;
}
::-webkit-datetime-edit{
  display: inline-flex;
}
::-webkit-datetime-edit,::-webkit-datetime-edit-year-field,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute-field,::-webkit-datetime-edit-second-field,::-webkit-datetime-edit-millisecond-field,::-webkit-datetime-edit-meridiem-field{
  padding-top: 0;
  padding-bottom: 0;
}
select{
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
  -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
}
[multiple],[size]:where(select:not([size="1"])){
  background-image: initial;
  background-position: initial;
  background-repeat: unset;
  background-size: initial;
  padding-right: 0.75rem;
  -webkit-print-color-adjust: unset;
          print-color-adjust: unset;
}
[type='checkbox'],[type='radio']{
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  padding: 0;
  -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
  display: inline-block;
  vertical-align: middle;
  background-origin: border-box;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  flex-shrink: 0;
  height: 1rem;
  width: 1rem;
  color: #2563eb;
  background-color: #fff;
  border-color: #6b7280;
  border-width: 1px;
  --tw-shadow: 0 0 #0000;
}
[type='checkbox']{
  border-radius: 0px;
}
[type='radio']{
  border-radius: 100%;
}
[type='checkbox']:focus,[type='radio']:focus{
  outline: 2px solid transparent;
  outline-offset: 2px;
  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);
  --tw-ring-offset-width: 2px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: #2563eb;
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
}
[type='checkbox']:checked,[type='radio']:checked{
  border-color: transparent;
  background-color: currentColor;
  background-size: 100% 100%;
  background-position: center;
  background-repeat: no-repeat;
}
[type='checkbox']:checked{
  background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
}
@media (forced-colors: active) {
  [type='checkbox']:checked{
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}
[type='radio']:checked{
  background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3ccircle cx='8' cy='8' r='3'/%3e%3c/svg%3e");
}
@media (forced-colors: active) {
  [type='radio']:checked{
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}
[type='checkbox']:checked:hover,[type='checkbox']:checked:focus,[type='radio']:checked:hover,[type='radio']:checked:focus{
  border-color: transparent;
  background-color: currentColor;
}
[type='checkbox']:indeterminate{
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 16 16'%3e%3cpath stroke='white' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 8h8'/%3e%3c/svg%3e");
  border-color: transparent;
  background-color: currentColor;
  background-size: 100% 100%;
  background-position: center;
  background-repeat: no-repeat;
}
@media (forced-colors: active) {
  [type='checkbox']:indeterminate{
    -webkit-appearance: auto;
       -moz-appearance: auto;
            appearance: auto;
  }
}
[type='checkbox']:indeterminate:hover,[type='checkbox']:indeterminate:focus{
  border-color: transparent;
  background-color: currentColor;
}
[type='file']{
  background: unset;
  border-color: inherit;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-size: unset;
  line-height: inherit;
}
[type='file']:focus{
  outline: 1px solid ButtonText;
  outline: 1px auto -webkit-focus-ring-color;
}
*, ::before, ::after{
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
::backdrop{
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
.visible{
  visibility: visible;
}
.fixed{
  position: fixed;
}
.absolute{
  position: absolute;
}
.relative{
  position: relative;
}
.inset-0{
  inset: 0;
}
.z-10{
  z-index: 10;
}
.z-50{
  z-index: 50;
}
.mx-6{
  margin-left: 24px;
  margin-right: 24px;
}
.mx-auto{
  margin-left: auto;
  margin-right: auto;
}
.-mt-5{
  margin-top: -20px;
}
.-mt-6{
  margin-top: -24px;
}
.mb-10{
  margin-bottom: 40px;
}
.mb-12{
  margin-bottom: 48px;
}
.mb-3{
  margin-bottom: 12px;
}
.mb-4{
  margin-bottom: 16px;
}
.mb-6{
  margin-bottom: 24px;
}
.mr-1{
  margin-right: 4px;
}
.mr-1\\.5{
  margin-right: 6px;
}
.mt-2{
  margin-top: 8px;
}
.mt-3{
  margin-top: 12px;
}
.mt-4{
  margin-top: 16px;
}
.flex{
  display: flex;
}
.inline-flex{
  display: inline-flex;
}
.hidden{
  display: none;
}
.size-5{
  width: 20px;
  height: 20px;
}
.size-6{
  width: 24px;
  height: 24px;
}
.size-\\[244px\\]{
  width: 244px;
  height: 244px;
}
.h-10{
  height: 40px;
}
.h-24{
  height: 96px;
}
.min-h-full{
  min-height: 100%;
}
.min-h-screen{
  min-height: 100vh;
}
.w-24{
  width: 96px;
}
.w-4{
  width: 16px;
}
.w-full{
  width: 100%;
}
.max-w-\\[224px\\]{
  max-width: 224px;
}
.flex-1{
  flex: 1 1 0%;
}
@keyframes pulse{
  50%{
    opacity: .5;
  }
}
.animate-pulse{
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}
@keyframes spin{
  to{
    transform: rotate(360deg);
  }
}
.animate-spin{
  animation: spin 1s linear infinite;
}
.cursor-pointer{
  cursor: pointer;
}
.flex-col{
  flex-direction: column;
}
.items-end{
  align-items: flex-end;
}
.items-center{
  align-items: center;
}
.justify-center{
  justify-content: center;
}
.justify-between{
  justify-content: space-between;
}
.gap-1{
  gap: 4px;
}
.space-x-2 > :not([hidden]) ~ :not([hidden]){
  --tw-space-x-reverse: 0;
  margin-right: calc(8px * var(--tw-space-x-reverse));
  margin-left: calc(8px * calc(1 - var(--tw-space-x-reverse)));
}
.space-x-4 > :not([hidden]) ~ :not([hidden]){
  --tw-space-x-reverse: 0;
  margin-right: calc(16px * var(--tw-space-x-reverse));
  margin-left: calc(16px * calc(1 - var(--tw-space-x-reverse)));
}
.space-y-10 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(40px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(40px * var(--tw-space-y-reverse));
}
.space-y-4 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(16px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(16px * var(--tw-space-y-reverse));
}
.space-y-5 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(20px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(20px * var(--tw-space-y-reverse));
}
.space-y-6 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(24px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(24px * var(--tw-space-y-reverse));
}
.space-y-8 > :not([hidden]) ~ :not([hidden]){
  --tw-space-y-reverse: 0;
  margin-top: calc(32px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(32px * var(--tw-space-y-reverse));
}
.overflow-y-hidden{
  overflow-y: hidden;
}
.rounded-2xl{
  border-radius: 1rem;
}
.rounded-full{
  border-radius: 9999px;
}
.rounded-lg{
  border-radius: 0.5rem;
}
.border{
  border-width: 1px;
}
.border-t{
  border-top-width: 1px;
}
.border-ebecef{
  --tw-border-opacity: 1;
  border-color: rgb(235 236 239 / var(--tw-border-opacity));
}
.border-f1f5f8{
  --tw-border-opacity: 1;
  border-color: rgb(241 245 248 / var(--tw-border-opacity));
}
.border-f5f5f7{
  --tw-border-opacity: 1;
  border-color: rgb(245 245 247 / var(--tw-border-opacity));
}
.border-transparent{
  border-color: transparent;
}
.bg-0d151d{
  --tw-bg-opacity: 1;
  background-color: rgb(13 21 29 / var(--tw-bg-opacity));
}
.bg-black\\/50{
  background-color: rgb(0 0 0 / 0.5);
}
.bg-transparent{
  background-color: transparent;
}
.bg-white{
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.p-2{
  padding: 8px;
}
.p-4{
  padding: 16px;
}
.p-7{
  padding: 28px;
}
.px-2{
  padding-left: 8px;
  padding-right: 8px;
}
.px-8{
  padding-left: 32px;
  padding-right: 32px;
}
.py-1{
  padding-top: 4px;
  padding-bottom: 4px;
}
.py-3{
  padding-top: 12px;
  padding-bottom: 12px;
}
.pt-6{
  padding-top: 24px;
}
.text-center{
  text-align: center;
}
.font-sans{
  font-family: Rubik, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.font-sora{
  font-family: Sora, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.text-2xl{
  font-size: 24px;
  line-height: 32px;
}
.text-lg{
  font-size: 18px;
  line-height: 28px;
}
.text-sm{
  font-size: 14px;
  line-height: 20px;
}
.text-xs{
  font-size: 12px;
  line-height: 16px;
}
.font-bold{
  font-weight: 700;
}
.font-medium{
  font-weight: 500;
}
.font-semibold{
  font-weight: 600;
}
.text-0d151d{
  --tw-text-opacity: 1;
  color: rgb(13 21 29 / var(--tw-text-opacity));
}
.text-29343f{
  --tw-text-opacity: 1;
  color: rgb(41 52 63 / var(--tw-text-opacity));
}
.text-3c424b{
  --tw-text-opacity: 1;
  color: rgb(60 66 75 / var(--tw-text-opacity));
}
.text-657080{
  --tw-text-opacity: 1;
  color: rgb(101 112 128 / var(--tw-text-opacity));
}
.text-70868f{
  --tw-text-opacity: 1;
  color: rgb(112 134 143 / var(--tw-text-opacity));
}
.text-9ba3ae{
  --tw-text-opacity: 1;
  color: rgb(155 163 174 / var(--tw-text-opacity));
}
.text-9eafc0{
  --tw-text-opacity: 1;
  color: rgb(158 175 192 / var(--tw-text-opacity));
}
.text-black{
  --tw-text-opacity: 1;
  color: rgb(0 0 0 / var(--tw-text-opacity));
}
.text-gray-900{
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity));
}
.text-white{
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.opacity-40{
  opacity: 0.4;
}
.shadow{
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-sm{
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.blur-lg{
  --tw-blur: blur(16px);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.filter{
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.backdrop-blur-lg{
  --tw-backdrop-blur: blur(16px);
  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
}
.transition{
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.duration-300{
  transition-duration: 300ms;
}
.duration-500{
  transition-duration: 500ms;
}
.ease-in-out{
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}
input[type='number']::-webkit-inner-spin-button,
	input[type='number']::-webkit-outer-spin-button{
  -webkit-appearance: none;
          appearance: none;
}
.hover\\:underline:hover{
  text-decoration-line: underline;
}
.hover\\:shadow:hover{
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.focus\\:outline-none:focus{
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.focus\\:ring-2:focus{
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus\\:ring-indigo-500:focus{
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));
}
.focus\\:ring-offset-2:focus{
  --tw-ring-offset-width: 2px;
}
.focus-visible\\:ring:focus-visible{
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.focus-visible\\:ring-purple-500\\/75:focus-visible{
  --tw-ring-color: rgb(168 85 247 / 0.75);
}
.disabled\\:cursor-not-allowed:disabled{
  cursor: not-allowed;
}
.disabled\\:opacity-40:disabled{
  opacity: 0.4;
}
@media (prefers-reduced-motion: reduce){
  @keyframes spin{
    to{
      transform: rotate(360deg);
    }
  }
  .motion-reduce\\:animate-\\[spin_1\\.5s_linear_infinite\\]{
    animation: spin 1.5s linear infinite;
  }
}
.dark\\:border-f1f5f8\\/10:is(.dark *){
  border-color: rgb(241 245 248 / 0.1);
}
.dark\\:bg-0d151d:is(.dark *){
  --tw-bg-opacity: 1;
  background-color: rgb(13 21 29 / var(--tw-bg-opacity));
}
.dark\\:bg-white:is(.dark *){
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.dark\\:text-0d151d:is(.dark *){
  --tw-text-opacity: 1;
  color: rgb(13 21 29 / var(--tw-text-opacity));
}
.dark\\:text-9eafc0:is(.dark *){
  --tw-text-opacity: 1;
  color: rgb(158 175 192 / var(--tw-text-opacity));
}
.dark\\:text-white:is(.dark *){
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
@media (min-width: 768px){
  .md\\:mt-2{
    margin-top: 8px;
  }
  .md\\:hidden{
    display: none;
  }
  .md\\:min-h-\\[35rem\\]{
    min-height: 35rem;
  }
  .md\\:max-w-md{
    max-width: 448px;
  }
  .md\\:items-center{
    align-items: center;
  }
  .md\\:overflow-y-auto{
    overflow-y: auto;
  }
  .md\\:rounded-2xl{
    border-radius: 1rem;
  }
  .md\\:rounded-b-2xl{
    border-bottom-right-radius: 1rem;
    border-bottom-left-radius: 1rem;
  }
  .md\\:p-4{
    padding: 16px;
  }
}
`;
    Styles = /* @__PURE__ */ __name2(() => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("style", { children: styles_default }), "Styles");
    Styles_default = Styles;
    XMarkIcon = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "path",
      {
        strokeWidth: "1.5",
        stroke: "currentColor",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m16.243 7.758-8.485 8.485m8.485 0L7.758 7.758"
      }
    ) }), "XMarkIcon");
    XMarkIcon_default = XMarkIcon;
    ErrorIcon = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 100 100", children: [
      /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("circle", { cx: "50", cy: "50", r: "49.375", fill: "url(#a)", fillOpacity: ".65", stroke: "url(#b)", strokeWidth: "1.25" }),
      /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("g", { filter: "url(#c)", children: [
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("circle", { cx: "50", cy: "50", r: "35", fill: "#fff" }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("circle", { cx: "50", cy: "50", r: "34.432", stroke: "#FFC9AD", strokeWidth: "1.136" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
        "path",
        {
          stroke: "#FF4732",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "3.75",
          d: "m57.5 42.5-15 14.999m15 .001-15-14.999"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("defs", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("linearGradient", { id: "a", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("stop", { stopColor: "#FFA483" }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("stop", { offset: "1", stopColor: "#FFA483", stopOpacity: "0" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("linearGradient", { id: "b", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("stop", { stopColor: "#FFA483" }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("stop", { offset: ".713", stopColor: "#FFA483", stopOpacity: "0" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(
          "filter",
          {
            id: "c",
            width: "77.5",
            height: "77.5",
            x: "11.25",
            y: "13.125",
            colorInterpolationFilters: "sRGB",
            filterUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("feColorMatrix", { in: "SourceAlpha", result: "hardAlpha", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("feOffset", { dy: "1.875" }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("feGaussianBlur", { stdDeviation: "1.875" }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("feColorMatrix", { values: "0 0 0 0 1 0 0 0 0 0.788235 0 0 0 0 0.678431 0 0 0 0.45 0" }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("feBlend", { in2: "BackgroundImageFix", result: "effect1_dropShadow_39_740" }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("feBlend", { in: "SourceGraphic", in2: "effect1_dropShadow_39_740", result: "shape" })
            ]
          }
        )
      ] })
    ] }), "ErrorIcon");
    ErrorIcon_default = ErrorIcon;
    ReloadIcon = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      "path",
      {
        d: "M12.3809 1.6665L13.3626 4.24214C12.3754 3.66434 11.2263 3.33317 9.99992 3.33317C6.31802 3.33317 3.33325 6.31794 3.33325 9.99984C3.33325 11.2141 3.6579 12.3526 4.22513 13.3332M7.61897 18.3332L6.63719 15.7575C7.62438 16.3353 8.77348 16.6665 9.99992 16.6665C13.6818 16.6665 16.6666 13.6817 16.6666 9.99984C16.6666 8.78555 16.3419 7.64708 15.7747 6.6665",
        stroke: "#3C424B",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) }), "ReloadIcon");
    ReloadIcon_default = ReloadIcon;
    WarningIcon = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 100 100", ...props, children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
        "circle",
        {
          cx: "50",
          cy: "50",
          r: "49.375",
          fill: "url(#warning-a)",
          fillOpacity: ".65",
          stroke: "url(#warning-b)",
          strokeWidth: "1.25"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("g", { filter: "url(#warning-c)", children: [
        /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("circle", { cx: "50", cy: "50", r: "35", fill: "#fff" }),
        /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("circle", { cx: "50", cy: "50", r: "34.432", stroke: "#FFE999", strokeWidth: "1.136" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
        "path",
        {
          fill: "#FFB200",
          fillRule: "evenodd",
          d: "M47.46 40.207c1.107-1.943 3.973-1.943 5.08 0l9.59 16.834c1.076 1.888-.324 4.209-2.54 4.209H40.41c-2.216 0-3.616-2.32-2.54-4.21l9.59-16.833Zm3.79 16.043a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Zm-.313-10a.937.937 0 1 0-1.875 0v6.25a.938.938 0 0 0 1.875 0v-6.25Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("defs", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("linearGradient", { id: "warning-a", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("stop", { stopColor: "#FFDA66" }),
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("stop", { offset: "1", stopColor: "#FFDA66", stopOpacity: "0" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("linearGradient", { id: "warning-b", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("stop", { stopColor: "#FFDA66" }),
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("stop", { offset: ".713", stopColor: "#FFDA66", stopOpacity: "0" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)(
          "filter",
          {
            id: "warning-c",
            width: "77.5",
            height: "77.5",
            x: "11.25",
            y: "13.125",
            colorInterpolationFilters: "sRGB",
            filterUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
              /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("feColorMatrix", { in: "SourceAlpha", result: "hardAlpha", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" }),
              /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("feOffset", { dy: "1.875" }),
              /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("feGaussianBlur", { stdDeviation: "1.875" }),
              /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("feColorMatrix", { values: "0 0 0 0 1 0 0 0 0 0.913725 0 0 0 0 0.6 0 0 0 0.45 0" }),
              /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("feBlend", { in2: "BackgroundImageFix", result: "effect1_dropShadow_39_758" }),
              /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("feBlend", { in: "SourceGraphic", in2: "effect1_dropShadow_39_758", result: "shape" })
            ]
          }
        )
      ] })
    ] }), "WarningIcon");
    WarningIcon_default = WarningIcon;
    getParams = /* @__PURE__ */ __name2(({ retryFlow, errorState }) => ({ retryFlow, errorState }), "getParams");
    ERROR_TITLES = {
      [AppErrorCodes.GenericError]: __("Something went wrong"),
      [AppErrorCodes.FailedByHostApp]: __("Verification Declined"),
      [AppErrorCodes.VerificationRejected]: __("Request cancelled")
    };
    ERROR_MESSAGES = {
      [AppErrorCodes.ConnectionFailed]: __("Connection to your wallet failed. Please try again."),
      [AppErrorCodes.VerificationRejected]: __("You\u2019ve cancelled the request in World App."),
      [AppErrorCodes.MaxVerificationsReached]: __(
        "You have already verified the maximum number of times for this action."
      ),
      [AppErrorCodes.CredentialUnavailable]: __("It seems you do not have the verification level required by this app."),
      [AppErrorCodes.MalformedRequest]: __(
        "There was a problem with this request. Please try again or contact the app owner."
      ),
      [AppErrorCodes.InvalidNetwork]: __(
        "Invalid network. If you are the app owner, visit docs.world.org/test for details."
      ),
      [AppErrorCodes.InclusionProofFailed]: __("There was an issue fetching your credential. Please try again."),
      [AppErrorCodes.InclusionProofPending]: __(
        "Your identity is still being registered. Please wait a few minutes and try again."
      ),
      [AppErrorCodes.GenericError]: __("Something unexpected went wrong. Please try again."),
      [AppErrorCodes.UnexpectedResponse]: __("Unexpected response from your wallet. Please try again."),
      [AppErrorCodes.FailedByHostApp]: __("Verification failed by the app. Please contact the app owner for details.")
    };
    ErrorState = /* @__PURE__ */ __name2(() => {
      const { retryFlow, errorState } = idkit_default(getParams);
      return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "space-y-8", children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "-mt-5 flex items-center justify-center", children: errorState?.code == AppErrorCodes.VerificationRejected ? /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(WarningIcon_default, { className: "w-24" }) : /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ErrorIcon_default, { className: "w-24" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("p", { className: "text-center text-2xl font-semibold text-gray-900 dark:text-white", children: (errorState?.code && ERROR_TITLES[errorState.code]) ?? ERROR_TITLES[AppErrorCodes.GenericError] }),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("p", { className: "mx-auto mt-2 max-w-[224px] text-center text-657080", children: errorState?.message ?? ERROR_MESSAGES[errorState?.code ?? AppErrorCodes.GenericError] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "flex justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
          "button",
          {
            type: "button",
            onClick: retryFlow,
            className: "inline-flex items-center rounded-lg border border-ebecef bg-transparent px-8 py-3 font-medium text-3c424b shadow-sm transition duration-300 hover:shadow focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-40",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ReloadIcon_default, { className: "mr-1.5 size-5" }),
              __("Try Again")
            ]
          }
        ) })
      ] });
    }, "ErrorState");
    ErrorState_default = ErrorState;
    CheckIcon = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 100 100", ...props, children: [
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        "circle",
        {
          cx: "50",
          cy: "50",
          r: "49.375",
          fill: "url(#success-a)",
          fillOpacity: ".65",
          stroke: "url(#success-b)",
          strokeWidth: "1.25"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("g", { filter: "url(#success-c)", children: [
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("circle", { cx: "50", cy: "50", r: "35", fill: "#fff" }),
        /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("circle", { cx: "50", cy: "50", r: "34.432", stroke: "#CCEBCC", strokeWidth: "1.136" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        "path",
        {
          stroke: "#090",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "3.75",
          d: "m41.25 52.5 4.375 4.375 13.125-13.75"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("defs", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("linearGradient", { id: "success-a", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("stop", { stopColor: "#99D699" }),
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("stop", { offset: "1", stopColor: "#99D699", stopOpacity: "0" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("linearGradient", { id: "success-b", x1: "50", x2: "50", y1: "0", y2: "100", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("stop", { stopColor: "#99D699" }),
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("stop", { offset: ".713", stopColor: "#99D699", stopOpacity: "0" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(
          "filter",
          {
            id: "success-c",
            width: "77.5",
            height: "77.5",
            x: "11.25",
            y: "13.125",
            colorInterpolationFilters: "sRGB",
            filterUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
              /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("feColorMatrix", { in: "SourceAlpha", result: "hardAlpha", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" }),
              /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("feOffset", { dy: "1.875" }),
              /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("feGaussianBlur", { stdDeviation: "1.875" }),
              /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("feColorMatrix", { values: "0 0 0 0 0.8 0 0 0 0 0.921569 0 0 0 0 0.8 0 0 0 0.45 0" }),
              /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("feBlend", { in2: "BackgroundImageFix", result: "effect1_dropShadow_39_712" }),
              /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("feBlend", { in: "SourceGraphic", in2: "effect1_dropShadow_39_712", result: "shape" })
            ]
          }
        )
      ] })
    ] }), "CheckIcon");
    CheckIcon_default = CheckIcon;
    SuccessState = /* @__PURE__ */ __name2(() => {
      return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { className: "space-y-6", children: [
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { className: "-mt-5 flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(CheckIcon_default, { className: "w-24 text-white" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("p", { className: "text-center text-2xl font-semibold text-gray-900 dark:text-white", children: __("Successfully verified") }),
          /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("p", { className: "mx-auto mt-2 max-w-[224px] text-center text-lg text-657080", children: __("Your World ID verification was successful") })
        ] })
      ] });
    }, "SuccessState");
    SuccessState_default = SuccessState;
    __name2(r2, "r");
    __name2(clsx, "clsx");
    clsx_default = clsx;
    WorldcoinIcon = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 33 32", children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M30.7195 9.77312C29.9097 7.87434 28.7647 6.17103 27.2845 4.6911C25.8044 3.21117 24.1288 2.06632 22.2298 1.25654C20.247 0.418848 18.1525 0 16.0021 0C13.8238 0 11.7293 0.418848 9.7744 1.25654C7.87537 2.06632 6.17184 3.21117 4.69171 4.6911C3.21159 6.17103 2.06659 7.87434 1.25671 9.77312C0.418903 11.7277 0 13.822 0 16C0 18.1501 0.418903 20.2443 1.25671 22.2269C2.06659 24.1257 3.21159 25.829 4.69171 27.3089C6.17184 28.7888 7.87537 29.9337 9.7744 30.7155C11.7572 31.5532 13.8517 31.9721 16.0021 31.9721C18.1525 31.9721 20.247 31.5532 22.2298 30.7155C24.1288 29.9058 25.8323 28.7609 27.3125 27.281C28.7926 25.801 29.9376 24.0977 30.7475 22.1989C31.5853 20.2164 32.0042 18.1222 32.0042 15.9721C32.0042 13.822 31.5574 11.7277 30.7195 9.77312ZM10.696 14.4921C11.3383 11.9232 13.6842 10.0524 16.4489 10.0524H27.5638C28.2899 11.4206 28.7367 12.9284 28.9043 14.4921H10.696ZM28.9043 17.5079C28.7367 19.0716 28.262 20.5794 27.5638 21.9476H16.4489C13.6842 21.9476 11.3662 20.0489 10.696 17.5079H28.9043ZM6.81415 6.81326C9.27172 4.35602 12.5392 3.01571 16.0021 3.01571C19.465 3.01571 22.7325 4.35602 25.19 6.81326C25.2738 6.89703 25.3297 6.95288 25.4134 7.03665H16.4489C14.0472 7.03665 11.8131 7.95811 10.1095 9.66143C8.76903 11.0017 7.9033 12.6771 7.62403 14.4921H3.09988C3.435 11.5881 4.71964 8.9075 6.81415 6.81326ZM16.0021 28.9843C12.5392 28.9843 9.27172 27.644 6.81415 25.1867C4.71964 23.0925 3.435 20.3839 3.09988 17.5079H7.62403C7.93123 19.3229 8.79696 20.9983 10.1095 22.3386C11.8131 24.0419 14.0472 24.9633 16.4489 24.9633H25.4134C25.3297 25.0471 25.2738 25.103 25.19 25.1867C22.7325 27.644 19.465 28.9843 16.0021 28.9843Z"
      }
    ) }), "WorldcoinIcon");
    WorldcoinIcon_default = WorldcoinIcon;
    QRPlaceholderIcon = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 200 200", children: [
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "#EBECEF",
          fillRule: "evenodd",
          d: "M12.1 0C5.417 0 0 5.417 0 12.1v18.505c0 6.682 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.418 12.1-12.1V12.1c0-6.683-5.418-12.1-12.1-12.1H12.1Zm18.505 11.388H12.1a.712.712 0 0 0-.712.712v18.505c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712V12.1a.712.712 0 0 0-.712-.712Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "#EBECEF",
          d: "M197.026 200c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-17.616c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.545.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808h-11.897v-11.744h-11.896v-23.487h11.896v8.808c0 .778.314 1.525.872 2.076.557.55 1.314.86 2.102.86h5.949c.788 0 1.545-.31 2.103-.86a2.922 2.922 0 0 0 .871-2.076v-8.808h8.922c.789 0 1.545-.309 2.103-.86a2.916 2.916 0 0 0 .871-2.076v-5.872c0-.779-.313-1.525-.871-2.076a2.992 2.992 0 0 0-2.103-.86h-29.741c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v8.808h-23.792v-11.744h8.922c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-5.872c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.546.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808H119.7c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.525.871 2.076.558.551 1.314.86 2.103.86h20.819v8.808c0 .778.313 1.525.871 2.076.557.55 1.314.86 2.103.86h8.922v8.808c0 .778.313 1.525.871 2.076.558.55 1.314.859 2.103.859h8.922v11.744h-20.818c-.789 0-1.546.31-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.526.871 2.076a2.99 2.99 0 0 0 2.103.86h17.844c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-8.808h11.896v8.808c0 .779.314 1.526.872 2.076a2.99 2.99 0 0 0 2.102.86h17.845Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "#EBECEF",
          fillRule: "evenodd",
          d: "M157.295 12.1c0-6.683 5.418-12.1 12.1-12.1H187.9c6.683 0 12.1 5.417 12.1 12.1v18.505c0 6.682-5.417 12.1-12.1 12.1h-18.505c-6.682 0-12.1-5.418-12.1-12.1V12.1Zm12.1-.712H187.9c.393 0 .712.319.712.712v18.505a.712.712 0 0 1-.712.712h-18.505a.712.712 0 0 1-.712-.712V12.1c0-.393.319-.712.712-.712ZM12.1 157.295c-6.683 0-12.1 5.418-12.1 12.1V187.9c0 6.683 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.417 12.1-12.1v-18.505c0-6.682-5.418-12.1-12.1-12.1H12.1Zm19.217 12.1a.712.712 0 0 0-.712-.712H12.1a.712.712 0 0 0-.712.712V187.9c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712v-18.505Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "#EBECEF",
          d: "M6.05 89.68A6.05 6.05 0 0 0 0 95.73v9.252a6.05 6.05 0 0 0 6.05 6.05h9.253a6.05 6.05 0 0 0 6.05-6.05V95.73c0-.678-.112-1.33-.318-1.94.445.105.908.16 1.385.16h27.758a6.05 6.05 0 0 0 6.05-6.05v-9.252a6.05 6.05 0 0 0-6.05-6.05H22.42a6.05 6.05 0 0 0-6.05 6.05V87.9c0 .678.112 1.33.317 1.939a6.065 6.065 0 0 0-1.385-.16H6.05Zm102.135-40.926a6.05 6.05 0 0 1 6.05-6.05h9.253a6.05 6.05 0 0 1 6.049 6.05v9.253a6.05 6.05 0 0 1-6.049 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.253ZM67.616 184.698a6.05 6.05 0 0 1 6.05-6.05h9.252c.678 0 1.33.111 1.939.317a6.064 6.064 0 0 1-.16-1.385v-9.253a6.05 6.05 0 0 1 6.05-6.049H100a6.05 6.05 0 0 1 6.05 6.049v9.253a6.05 6.05 0 0 1-6.05 6.05h-9.253c-.678 0-1.33-.112-1.938-.317.104.444.159.908.159 1.385v9.252a6.05 6.05 0 0 1-6.05 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.252Zm78.291-120.285a6.05 6.05 0 0 1 6.05-6.05h41.993a6.05 6.05 0 0 1 6.05 6.05v9.252a6.05 6.05 0 0 1-6.05 6.05h-41.993a6.05 6.05 0 0 1-6.05-6.05v-9.252ZM95.018 0a6.05 6.05 0 0 0-6.05 6.05v17.082a6.05 6.05 0 0 0 6.05 6.05h9.252a6.05 6.05 0 0 0 6.05-6.05V6.05A6.05 6.05 0 0 0 104.27 0h-9.252Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          fillRule: "evenodd",
          d: "M12.1 0C5.417 0 0 5.417 0 12.1v18.505c0 6.682 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.418 12.1-12.1V12.1c0-6.683-5.418-12.1-12.1-12.1H12.1Zm18.505 11.388H12.1a.712.712 0 0 0-.712.712v18.505c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712V12.1a.712.712 0 0 0-.712-.712Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          d: "M197.026 200c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-17.616c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.545.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808h-11.897v-11.744h-11.896v-23.487h11.896v8.808c0 .778.314 1.525.872 2.076.557.55 1.314.86 2.102.86h5.949c.788 0 1.545-.31 2.103-.86a2.922 2.922 0 0 0 .871-2.076v-8.808h8.922c.789 0 1.545-.309 2.103-.86a2.916 2.916 0 0 0 .871-2.076v-5.872c0-.779-.313-1.525-.871-2.076a2.992 2.992 0 0 0-2.103-.86h-29.741c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v8.808h-23.792v-11.744h8.922c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-5.872c0-.778-.313-1.525-.871-2.076a2.996 2.996 0 0 0-2.103-.86h-5.948c-.789 0-1.546.31-2.103.86a2.918 2.918 0 0 0-.871 2.076v8.808H119.7c-.789 0-1.545.309-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.525.871 2.076.558.551 1.314.86 2.103.86h20.819v8.808c0 .778.313 1.525.871 2.076.557.55 1.314.86 2.103.86h8.922v8.808c0 .778.313 1.525.871 2.076.558.55 1.314.859 2.103.859h8.922v11.744h-20.818c-.789 0-1.546.31-2.103.86a2.916 2.916 0 0 0-.871 2.076v5.872c0 .779.313 1.526.871 2.076a2.99 2.99 0 0 0 2.103.86h17.844c.789 0 1.545-.309 2.103-.86.558-.55.871-1.297.871-2.076v-8.808h11.896v8.808c0 .779.314 1.526.872 2.076a2.99 2.99 0 0 0 2.102.86h17.845Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          fillRule: "evenodd",
          d: "M157.295 12.1c0-6.683 5.418-12.1 12.1-12.1H187.9c6.683 0 12.1 5.417 12.1 12.1v18.505c0 6.682-5.417 12.1-12.1 12.1h-18.505c-6.682 0-12.1-5.418-12.1-12.1V12.1Zm12.1-.712H187.9c.393 0 .712.319.712.712v18.505a.712.712 0 0 1-.712.712h-18.505a.712.712 0 0 1-.712-.712V12.1c0-.393.319-.712.712-.712Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          fillRule: "evenodd",
          d: "M12.1 157.295c-6.683 0-12.1 5.418-12.1 12.1V187.9c0 6.683 5.417 12.1 12.1 12.1h18.505c6.682 0 12.1-5.417 12.1-12.1v-18.505c0-6.682-5.418-12.1-12.1-12.1H12.1Zm19.217 12.1a.712.712 0 0 0-.712-.712H12.1a.712.712 0 0 0-.712.712V187.9c0 .393.319.712.712.712h18.505a.712.712 0 0 0 .712-.712v-18.505Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          d: "M6.05 89.68A6.05 6.05 0 0 0 0 95.73v9.252a6.05 6.05 0 0 0 6.05 6.05h9.253a6.05 6.05 0 0 0 6.05-6.05V95.73c0-.678-.112-1.33-.318-1.94.445.105.908.16 1.385.16h27.758a6.05 6.05 0 0 0 6.05-6.05v-9.252a6.05 6.05 0 0 0-6.05-6.05H22.42a6.05 6.05 0 0 0-6.05 6.05V87.9c0 .678.112 1.33.317 1.939a6.065 6.065 0 0 0-1.385-.16H6.05Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          d: "M108.185 48.754a6.05 6.05 0 0 1 6.05-6.05h9.253a6.05 6.05 0 0 1 6.049 6.05v9.253a6.05 6.05 0 0 1-6.049 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.253Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          d: "M67.616 184.698a6.05 6.05 0 0 1 6.05-6.05h9.252c.678 0 1.33.111 1.939.317a6.064 6.064 0 0 1-.16-1.385v-9.253a6.05 6.05 0 0 1 6.05-6.049H100a6.05 6.05 0 0 1 6.05 6.049v9.253a6.05 6.05 0 0 1-6.05 6.05h-9.253c-.678 0-1.33-.112-1.938-.317.104.444.159.908.159 1.385v9.252a6.05 6.05 0 0 1-6.05 6.05h-9.253a6.05 6.05 0 0 1-6.05-6.05v-9.252Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          d: "M145.907 64.413a6.05 6.05 0 0 1 6.05-6.05h41.993a6.05 6.05 0 0 1 6.05 6.05v9.252a6.05 6.05 0 0 1-6.05 6.05h-41.993a6.05 6.05 0 0 1-6.05-6.05v-9.252Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
        "path",
        {
          fill: "url(#a)",
          d: "M95.018 0a6.05 6.05 0 0 0-6.05 6.05v17.082a6.05 6.05 0 0 0 6.05 6.05h9.252a6.05 6.05 0 0 0 6.05-6.05V6.05A6.05 6.05 0 0 0 104.27 0h-9.252Z"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("linearGradient", { id: "a", x1: "0", x2: "200", y1: "0", y2: "200", gradientUnits: "userSpaceOnUse", children: [
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("stop", { offset: ".37", stopColor: "#fff", stopOpacity: "0" }),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("stop", { offset: ".5", stopColor: "#fff", stopOpacity: ".85" }),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("stop", { offset: ".63", stopColor: "#fff", stopOpacity: "0" })
      ] }) })
    ] }), "QRPlaceholderIcon");
    QRPlaceholderIcon_default = QRPlaceholderIcon;
    QRState = /* @__PURE__ */ __name2(({ qrData, showQR, setShowQR }) => {
      const media = useMedia_default();
      const [copiedLink, setCopiedLink] = (0, import_react34.useState)(false);
      const copyLink = (0, import_react34.useCallback)(() => {
        (0, import_copy_to_clipboard.default)(qrData ?? "");
        setCopiedLink(true);
        setTimeout(() => setCopiedLink(false), 2e3);
      }, [qrData]);
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)("div", { className: clsx_default("md:hidden", { "mb-10 space-y-4": !showQR }), children: [
          /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(
            motion.a,
            {
              href: qrData ?? "",
              whileTap: { scale: 0.95 },
              whileHover: { scale: 1.05 },
              transition: { layout: { duration: 0.15 } },
              layoutId: media == "desktop" ? void 0 : "worldid-button",
              className: clsx_default(
                "flex w-full items-center space-x-2 rounded-2xl border border-transparent p-4 font-medium shadow-sm",
                "bg-0d151d text-white dark:bg-white dark:text-0d151d",
                { hidden: showQR }
              ),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(WorldcoinIcon_default, { className: "size-5" }),
                /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
                  motion.span,
                  {
                    className: "flex-1 text-center",
                    transition: { layout: { duration: 0.15 } },
                    layoutId: media == "desktop" ? void 0 : "worldid-text",
                    children: __("Open Worldcoin App")
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)("div", { className: clsx_default("mb-3", { "space-y-4": !showQR }), children: [
            /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)("div", { className: clsx_default("flex items-center space-x-4 ", { hidden: showQR }), children: [
              /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("hr", { className: "flex-1" }),
              /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("span", { className: "text-xs font-medium text-9ba3ae", children: "or" }),
              /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("hr", { className: "flex-1" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
              motion.button,
              {
                className: "w-full rounded-2xl border border-ebecef p-4 text-lg font-medium text-3c424b",
                onClick: () => setShowQR((state) => !state),
                children: showQR ? __("Hide QR Code") : __("Display QR Code")
              }
            )
          ] })
        ] }),
        (media == "desktop" || showQR) && /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(AnimatePresence, { children: copiedLink && /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
            motion.div,
            {
              className: "text-sm text-9eafc0",
              initial: "hidden",
              animate: "visible",
              exit: "exit",
              variants: {
                hidden: { opacity: 0, height: 0, marginTop: 0, y: 0 },
                visible: {
                  opacity: 1,
                  height: "auto",
                  marginTop: 8,
                  y: -20,
                  transition: {
                    duration: 0.25,
                    opacity: { delay: 0.05, duration: 0.2 },
                    ease: "easeInOut"
                  }
                },
                exit: {
                  opacity: 0,
                  height: 0,
                  marginTop: 0,
                  y: 0,
                  transition: {
                    duration: 0.4,
                    delay: 0.1,
                    opacity: { duration: 0.25, delay: 0 },
                    ease: "easeInOut"
                  }
                }
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("span", { className: "rounded-lg border border-f1f5f8 px-2 py-1 text-sm", children: __("QR Code copied") })
            },
            "copied"
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: "relative inline-flex items-center justify-center rounded-2xl border border-f1f5f8 p-2 dark:border-f1f5f8/10", children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: "text-29343f dark:text-white", children: qrData ? (
            // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
            /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { onClick: copyLink, className: "cursor-pointer", children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(QRCode_default, { data: qrData, size: 244 }) })
          ) : /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: "flex size-[244px] items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(QRPlaceholderIcon_default, { className: "size-[244px] animate-pulse" }) }) }) })
        ] })
      ] });
    }, "QRState");
    QRState_default = QRState;
    useWorldBridge = /* @__PURE__ */ __name2((app_id, action, signal, bridge_url, verification_level, action_description, partner) => {
      const ref_verification_level = (0, import_react36.useRef)(verification_level);
      const { reset, result, connectorURI, createClient, pollForUpdates, verificationState, errorCode } = useWorldBridgeStore();
      (0, import_react36.useEffect)(() => {
        if (!connectorURI) {
          void createClient({
            app_id,
            action,
            signal,
            bridge_url,
            action_description,
            verification_level: ref_verification_level.current,
            partner
          });
        }
      }, [
        app_id,
        action,
        signal,
        action_description,
        createClient,
        ref_verification_level,
        bridge_url,
        connectorURI,
        partner
      ]);
      (0, import_react36.useEffect)(() => {
        if (!connectorURI || result || errorCode)
          return;
        const interval = setInterval(() => void pollForUpdates(), 3e3);
        return () => clearInterval(interval);
      }, [connectorURI, pollForUpdates, errorCode, result]);
      return { connectorURI, reset, result, verificationState, errorCode };
    }, "useWorldBridge");
    LoadingIcon = /* @__PURE__ */ __name2(({ className, ...props }) => /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        className: `animate-spin motion-reduce:animate-[spin_1.5s_linear_infinite] ${className}`,
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("circle", { cx: "12", cy: "12", r: "10.75", stroke: "#191C20", strokeOpacity: ".16", strokeWidth: "2.5" }),
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
            "path",
            {
              fill: "#191C20",
              d: "M17.28 2.633c.338-.6.127-1.368-.505-1.642A12 12 0 0 0 7.459.892c-.638.261-.864 1.024-.539 1.632.326.607 1.08.827 1.725.584a9.504 9.504 0 0 1 6.897.073c.64.257 1.399.053 1.737-.548Z"
            }
          )
        ]
      }
    ), "LoadingIcon");
    LoadingIcon_default = LoadingIcon;
    getOptions = /* @__PURE__ */ __name2((store) => ({
      signal: store.signal,
      app_id: store.app_id,
      action: store.action,
      setStage: store.setStage,
      bridge_url: store.bridge_url,
      handleVerify: store.handleVerify,
      setErrorState: store.setErrorState,
      verification_level: store.verification_level,
      action_description: store.action_description,
      partner: store.partner
    }), "getOptions");
    WorldIDState = /* @__PURE__ */ __name2(() => {
      const [showQR, setShowQR] = (0, import_react35.useState)(false);
      const {
        app_id,
        action,
        signal,
        setStage,
        handleVerify,
        bridge_url,
        action_description,
        verification_level,
        setErrorState,
        partner
      } = idkit_default(getOptions, shallow$1);
      const { connectorURI, reset, errorCode, result, verificationState } = useWorldBridge(
        app_id,
        action,
        signal,
        bridge_url,
        verification_level,
        action_description,
        partner
      );
      (0, import_react35.useEffect)(() => reset, [reset]);
      (0, import_react35.useEffect)(() => {
        if (verificationState === VerificationState.Failed) {
          setStage(
            "ERROR"
            /* ERROR */
          );
          setErrorState({ code: errorCode ?? AppErrorCodes.GenericError });
        }
        if (result) {
          if (verification_level == VerificationLevel.Orb && result.verification_level == VerificationLevel.Device) {
            console.error(
              "Credential type received from wallet does not match configured credential_types. This should only happen when manually selecting disallowed credentials in the Worldcoin Simulator."
            );
            setStage(
              "ERROR"
              /* ERROR */
            );
            setErrorState({ code: AppErrorCodes.CredentialUnavailable });
            return;
          }
          return handleVerify(result);
        }
      }, [result, handleVerify, verificationState, setStage, errorCode, setErrorState, verification_level]);
      return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("div", { className: clsx_default("-mt-6 space-y-5", { "space-y-10": !showQR }), children: [
        /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: "mb-4 flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(WorldcoinIcon_default, { className: "h-10 text-0d151d dark:text-white" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("p", { className: "text-center font-sora text-2xl font-semibold text-gray-900 dark:text-white", children: __("Verify with World ID") }),
          /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("p", { className: "mt-3 text-center text-657080 dark:text-9eafc0 md:mt-2", children: "Please use your World App to scan the QR code" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("div", { className: "relative", children: [
          verificationState == VerificationState.WaitingForApp && /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("div", { className: "absolute inset-0 flex flex-col items-center justify-center space-y-6", children: [
            /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(LoadingIcon_default, { className: "size-6" }),
            /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("p", { className: "font-bold text-657080", children: "Verifying" }),
              /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("p", { className: "text-sm text-657080", children: "Please continue in app" })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
            "div",
            {
              className: verificationState === VerificationState.WaitingForApp ? "opacity-40 blur-lg transition duration-500 ease-in-out" : "transition duration-500 ease-in-out",
              children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(QRState_default, { showQR, setShowQR, qrData: connectorURI })
            }
          )
        ] })
      ] });
    }, "WorldIDState");
    WorldIDState_default = WorldIDState;
    HostAppVerificationState = /* @__PURE__ */ __name2(() => {
      return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("div", { className: "space-y-6", children: [
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "flex justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(LoadingIcon_default, { className: "h-24 w-24" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "mt-4 text-70868f", children: __("Transmitting verification to host app. Please wait...") })
      ] });
    }, "HostAppVerificationState");
    HostAppVerificationState_default = (0, import_react38.memo)(HostAppVerificationState);
    getParams2 = /* @__PURE__ */ __name2(({ open, processing, onOpenChange, stage, setStage, setOptions }) => ({
      stage,
      setStage,
      processing,
      setOptions,
      isOpen: open,
      onOpenChange
    }), "getParams2");
    IDKitWidget = /* @__PURE__ */ __name2(({ children, ...config }) => {
      const media = useMedia_default();
      const { isOpen, onOpenChange, stage, setOptions } = idkit_default(getParams2, shallow$1);
      (0, import_react37.useEffect)(() => {
        if (config.action === "") {
          throw new Error(__("Action cannot be an empty string."));
        }
        setOptions(
          config,
          "props"
          /* PROPS */
        );
      }, [config, setOptions]);
      const StageContent = (0, import_react37.useMemo)(() => {
        switch (stage) {
          case "WORLD_ID":
            return WorldIDState_default;
          case "SUCCESS":
            return SuccessState_default;
          case "ERROR":
            return ErrorState_default;
          case "HOST_APP_VERIFICATION":
            return HostAppVerificationState_default;
          default:
            throw new Error(__("Invalid IDKitStage :stage.", { stage }));
        }
      }, [stage]);
      return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(Root2, { open: isOpen, onOpenChange, children: [
        children?.({ open: () => onOpenChange(true) }),
        /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Portal2, { forceMount: true, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(import_react37.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(AnimatePresence, { children: isOpen && /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(react_shadow_esm_default.div, { mode: "open", id: "idkit-widget", children: [
          /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Styles_default, {}),
          /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("div", { id: "modal", className: "fixed z-10 font-sans", children: [
            /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Overlay, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
              motion.div,
              {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                exit: { opacity: 0 },
                className: "fixed inset-0 bg-black/50 backdrop-blur-lg"
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("div", { className: "fixed inset-0 z-10 overflow-y-hidden md:overflow-y-auto", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("div", { className: "flex min-h-full items-end justify-center text-center md:items-center md:p-4", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Content, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
              motion.div,
              {
                layout: media == "mobile" ? "position" : true,
                exit: media == "mobile" ? "initMob" : "init",
                initial: media == "mobile" ? "initMob" : "init",
                animate: media == "mobile" ? "animateMob" : "animate",
                variants: {
                  init: { opacity: 0, scale: 0.9 },
                  initMob: { translateY: "100%" },
                  animate: { opacity: 1, scale: 1 },
                  animateMob: { translateY: 0 }
                },
                transition: { layout: { duration: 0.15 } },
                className: "relative z-50 flex min-h-screen w-full flex-col bg-white pt-6 shadow focus:outline-none focus-visible:ring focus-visible:ring-purple-500/75 dark:bg-0d151d md:min-h-[35rem] md:max-w-md md:rounded-2xl",
                children: /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(Provider, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Viewport, { className: "flex justify-center" }),
                  /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("div", { className: "mx-6 mb-12 flex items-center justify-between", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Close, { className: "flex items-center justify-center rounded-full text-black dark:text-white", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(XMarkIcon_default, { className: "size-5" }) }) }),
                  /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("div", { className: "relative mx-6 mb-6 flex flex-1 flex-col items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(StageContent, {}) }),
                  /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("div", { className: "flex items-center justify-between border-t border-f5f5f7 p-7 md:rounded-b-2xl", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(
                      "a",
                      {
                        href: "https://world.org/world-id",
                        target: "_blank",
                        rel: "noreferrer",
                        className: "flex items-center gap-1 text-sm text-9eafc0",
                        children: [
                          /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(WorldcoinIcon_default, { className: "w-4 text-9eafc0 dark:text-white" }),
                          /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("span", { children: __("Powered by Worldcoin") })
                        ]
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
                      "a",
                      {
                        href: "https://developer.worldcoin.org/privacy-statement",
                        target: "_blank",
                        rel: "noreferrer",
                        className: "text-sm text-9eafc0 hover:underline",
                        children: __("Terms & Privacy")
                      }
                    )
                  ] })
                ] })
              }
            ) }) }) })
          ] })
        ] }) }) }) })
      ] });
    }, "IDKitWidget");
    BaseWidget_default = IDKitWidget;
    IDKitWidget_default = (0, import_react32.memo)(BaseWidget_default);
  }
});
var onRequestOptions;
var onRequestPost;
var init_verify = __esm({
  "verify.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    init_build2();
    onRequestOptions = /* @__PURE__ */ __name2(async () => {
      return new Response(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type"
        }
      });
    }, "onRequestOptions");
    onRequestPost = /* @__PURE__ */ __name2(async (context) => {
      const { request, env } = context;
      console.log("request", request);
      try {
        const proof = await request.json();
        console.log("proof", proof);
        const appId = env.APP_ID;
        const actionId = env.ACTION_ID;
        if (!appId || !actionId) {
          return new Response(
            JSON.stringify({ success: false, error: "Missing APP_ID or ACTION_ID" }),
            {
              status: 500,
              headers: {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "POST, OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type"
              }
            }
          );
        }
        const verifyRes = await verifyCloudProof(proof, appId, actionId);
        console.log("verifyRes", verifyRes);
        if (verifyRes.success) {
          console.log("success");
          return new Response(JSON.stringify(verifyRes), {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "POST, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type"
            }
          });
        } else {
          return new Response(JSON.stringify(verifyRes), {
            status: 400,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "POST, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type"
            }
          });
        }
      } catch (err) {
        return new Response(
          JSON.stringify({ success: false, error: err instanceof Error ? err.message : String(err) }),
          {
            status: 500,
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Methods": "POST, OPTIONS",
              "Access-Control-Allow-Headers": "Content-Type"
            }
          }
        );
      }
    }, "onRequestPost");
  }
});
function onRequest(context) {
  return new Response(
    "Hello, world!",
    {
      status: 200,
      headers: {
        // 'Content-Type': 'application/json',
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Max-Age": "86400",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type"
      }
    }
  );
}
__name(onRequest, "onRequest");
var init_helloworld = __esm({
  "helloworld.js"() {
    init_functionsRoutes_0_19477551827707917();
    init_checked_fetch();
    __name2(onRequest, "onRequest");
  }
});
var routes;
var init_functionsRoutes_0_19477551827707917 = __esm({
  "../.wrangler/tmp/pages-hrbx3s/functionsRoutes-0.19477551827707917.mjs"() {
    init_verify();
    init_verify();
    init_helloworld();
    routes = [
      {
        routePath: "/verify",
        mountPath: "/",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions]
      },
      {
        routePath: "/verify",
        mountPath: "/",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost]
      },
      {
        routePath: "/helloworld",
        mountPath: "/",
        method: "",
        middlewares: [],
        modules: [onRequest]
      }
    ];
  }
});
init_functionsRoutes_0_19477551827707917();
init_checked_fetch();
init_functionsRoutes_0_19477551827707917();
init_checked_fetch();
init_functionsRoutes_0_19477551827707917();
init_checked_fetch();
init_functionsRoutes_0_19477551827707917();
init_checked_fetch();
function lexer(str) {
  var tokens = [];
  var i2 = 0;
  while (i2 < str.length) {
    var char = str[i2];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i2++, value: str[i2++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i2, value: str[i2++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j2 = i2 + 1;
      while (j2 < str.length) {
        var code = str.charCodeAt(j2);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j2++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i2));
      tokens.push({ type: "NAME", index: i2, value: name });
      i2 = j2;
      continue;
    }
    if (char === "(") {
      var count3 = 1;
      var pattern = "";
      var j2 = i2 + 1;
      if (str[j2] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j2));
      }
      while (j2 < str.length) {
        if (str[j2] === "\\") {
          pattern += str[j2++] + str[j2++];
          continue;
        }
        if (str[j2] === ")") {
          count3--;
          if (count3 === 0) {
            j2++;
            break;
          }
        } else if (str[j2] === "(") {
          count3++;
          if (str[j2 + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j2));
          }
        }
        pattern += str[j2++];
      }
      if (count3)
        throw new TypeError("Unbalanced pattern at ".concat(i2));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i2));
      tokens.push({ type: "PATTERN", index: i2, value: pattern });
      i2 = j2;
      continue;
    }
    tokens.push({ type: "CHAR", index: i2, value: str[i2++] });
  }
  tokens.push({ type: "END", index: i2, value: "" });
  return tokens;
}
__name(lexer, "lexer");
__name2(lexer, "lexer");
function parse4(str, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var tokens = lexer(str);
  var _a = options2.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options2.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i2 = 0;
  var path2 = "";
  var tryConsume = /* @__PURE__ */ __name2(function(type6) {
    if (i2 < tokens.length && tokens[i2].type === type6)
      return tokens[i2++].value;
  }, "tryConsume");
  var mustConsume = /* @__PURE__ */ __name2(function(type6) {
    var value2 = tryConsume(type6);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i2], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type6));
  }, "mustConsume");
  var consumeText = /* @__PURE__ */ __name2(function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  }, "consumeText");
  var isSafe = /* @__PURE__ */ __name2(function(value2) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value2.indexOf(char2) > -1)
        return true;
    }
    return false;
  }, "isSafe");
  var safePattern = /* @__PURE__ */ __name2(function(prefix2) {
    var prev = result[result.length - 1];
    var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
    if (prev && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  }, "safePattern");
  while (i2 < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path2 += prefix;
        prefix = "";
      }
      if (path2) {
        result.push(path2);
        path2 = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path2 += value;
      continue;
    }
    if (path2) {
      result.push(path2);
      path2 = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
__name(parse4, "parse4");
__name2(parse4, "parse");
function match(str, options2) {
  var keys = [];
  var re = pathToRegexp(str, keys, options2);
  return regexpToFunction(re, keys, options2);
}
__name(match, "match");
__name2(match, "match");
function regexpToFunction(re, keys, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a = options2.decode, decode4 = _a === void 0 ? function(x2) {
    return x2;
  } : _a;
  return function(pathname) {
    var m2 = re.exec(pathname);
    if (!m2)
      return false;
    var path2 = m2[0], index = m2.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = /* @__PURE__ */ __name2(function(i3) {
      if (m2[i3] === void 0)
        return "continue";
      var key = keys[i3 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m2[i3].split(key.prefix + key.suffix).map(function(value) {
          return decode4(value, key);
        });
      } else {
        params[key.name] = decode4(m2[i3], key);
      }
    }, "_loop_1");
    for (var i2 = 1; i2 < m2.length; i2++) {
      _loop_1(i2);
    }
    return { path: path2, index, params };
  };
}
__name(regexpToFunction, "regexpToFunction");
__name2(regexpToFunction, "regexpToFunction");
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
__name(escapeString, "escapeString");
__name2(escapeString, "escapeString");
function flags(options2) {
  return options2 && options2.sensitive ? "" : "i";
}
__name(flags, "flags");
__name2(flags, "flags");
function regexpToRegexp(path2, keys) {
  if (!keys)
    return path2;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path2.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path2.source);
  }
  return path2;
}
__name(regexpToRegexp, "regexpToRegexp");
__name2(regexpToRegexp, "regexpToRegexp");
function arrayToRegexp(paths, keys, options2) {
  var parts = paths.map(function(path2) {
    return pathToRegexp(path2, keys, options2).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options2));
}
__name(arrayToRegexp, "arrayToRegexp");
__name2(arrayToRegexp, "arrayToRegexp");
function stringToRegexp(path2, keys, options2) {
  return tokensToRegexp(parse4(path2, options2), keys, options2);
}
__name(stringToRegexp, "stringToRegexp");
__name2(stringToRegexp, "stringToRegexp");
function tokensToRegexp(tokens, keys, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a = options2.strict, strict = _a === void 0 ? false : _a, _b = options2.start, start = _b === void 0 ? true : _b, _c = options2.end, end = _c === void 0 ? true : _c, _d = options2.encode, encode9 = _d === void 0 ? function(x2) {
    return x2;
  } : _d, _e = options2.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options2.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode9(token));
    } else {
      var prefix = escapeString(encode9(token.prefix));
      var suffix = escapeString(encode9(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod2 = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod2);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options2.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options2));
}
__name(tokensToRegexp, "tokensToRegexp");
__name2(tokensToRegexp, "tokensToRegexp");
function pathToRegexp(path2, keys, options2) {
  if (path2 instanceof RegExp)
    return regexpToRegexp(path2, keys);
  if (Array.isArray(path2))
    return arrayToRegexp(path2, keys, options2);
  return stringToRegexp(path2, keys, options2);
}
__name(pathToRegexp, "pathToRegexp");
__name2(pathToRegexp, "pathToRegexp");
var escapeRegex = /[.+?^${}()|[\]\\]/g;
function* executeRequest(request) {
  const requestPath = new URL(request.url).pathname;
  for (const route of [...routes].reverse()) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult) {
      for (const handler of route.middlewares.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: mountMatchResult.path
        };
      }
    }
  }
  for (const route of routes) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: true
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult && route.modules.length) {
      for (const handler of route.modules.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: matchResult.path
        };
      }
      break;
    }
  }
}
__name(executeRequest, "executeRequest");
__name2(executeRequest, "executeRequest");
var pages_template_worker_default = {
  async fetch(originalRequest, env, workerContext) {
    let request = originalRequest;
    const handlerIterator = executeRequest(request);
    let data = {};
    let isFailOpen = false;
    const next = /* @__PURE__ */ __name2(async (input, init2) => {
      if (input !== void 0) {
        let url = input;
        if (typeof input === "string") {
          url = new URL(input, request.url).toString();
        }
        request = new Request(url, init2);
      }
      const result = handlerIterator.next();
      if (result.done === false) {
        const { handler, params, path: path2 } = result.value;
        const context = {
          request: new Request(request.clone()),
          functionPath: path2,
          next,
          params,
          get data() {
            return data;
          },
          set data(value) {
            if (typeof value !== "object" || value === null) {
              throw new Error("context.data must be an object");
            }
            data = value;
          },
          env,
          waitUntil: workerContext.waitUntil.bind(workerContext),
          passThroughOnException: () => {
            isFailOpen = true;
          }
        };
        const response = await handler(context);
        if (!(response instanceof Response)) {
          throw new Error("Your Pages function should return a Response");
        }
        return cloneResponse(response);
      } else if ("ASSETS") {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      } else {
        const response = await fetch(request);
        return cloneResponse(response);
      }
    }, "next");
    try {
      return await next();
    } catch (error) {
      if (isFailOpen) {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      }
      throw error;
    }
  }
};
var cloneResponse = /* @__PURE__ */ __name2((response) => (
  // https://fetch.spec.whatwg.org/#null-body-status
  new Response(
    [101, 204, 205, 304].includes(response.status) ? null : response.body,
    response
  )
), "cloneResponse");
init_functionsRoutes_0_19477551827707917();
init_checked_fetch();
var drainBody = /* @__PURE__ */ __name2(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;
init_functionsRoutes_0_19477551827707917();
init_checked_fetch();
function reduceError(e2) {
  return {
    name: e2?.name,
    message: e2?.message ?? String(e2),
    stack: e2?.stack,
    cause: e2?.cause === void 0 ? void 0 : reduceError(e2.cause)
  };
}
__name(reduceError, "reduceError");
__name2(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name2(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e2) {
    const error = reduceError(e2);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = pages_template_worker_default;
init_functionsRoutes_0_19477551827707917();
init_checked_fetch();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
__name2(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
__name2(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");
__name2(__facade_invoke__, "__facade_invoke__");
var __Facade_ScheduledController__ = /* @__PURE__ */ __name(class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
}, "__Facade_ScheduledController__");
__name2(__Facade_ScheduledController__, "__Facade_ScheduledController__");
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name2(function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name2(function(type6, init2) {
        if (type6 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
__name2(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = (request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    };
    #dispatcher = (type6, init2) => {
      if (type6 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init2.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
__name2(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;

// ../../../AppData/Roaming/npm/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
var drainBody2 = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default2 = drainBody2;

// ../../../AppData/Roaming/npm/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
function reduceError2(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError2(e.cause)
  };
}
__name(reduceError2, "reduceError");
var jsonError2 = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e) {
    const error = reduceError2(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default2 = jsonError2;

// .wrangler/tmp/bundle-nu0i5Q/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__2 = [
  middleware_ensure_req_body_drained_default2,
  middleware_miniflare3_json_error_default2
];
var middleware_insertion_facade_default2 = middleware_loader_entry_default;

// ../../../AppData/Roaming/npm/node_modules/wrangler/templates/middleware/common.ts
var __facade_middleware__2 = [];
function __facade_register__2(...args) {
  __facade_middleware__2.push(...args.flat());
}
__name(__facade_register__2, "__facade_register__");
function __facade_invokeChain__2(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__2(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__2, "__facade_invokeChain__");
function __facade_invoke__2(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__2(request, env, ctx, dispatch, [
    ...__facade_middleware__2,
    finalMiddleware
  ]);
}
__name(__facade_invoke__2, "__facade_invoke__");

// .wrangler/tmp/bundle-nu0i5Q/middleware-loader.entry.ts
var __Facade_ScheduledController__2 = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__2)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
__name(__Facade_ScheduledController__2, "__Facade_ScheduledController__");
function wrapExportedHandler2(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__2 === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__2.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__2) {
    __facade_register__2(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type6, init2) {
        if (type6 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__2(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__2(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler2, "wrapExportedHandler");
function wrapWorkerEntrypoint2(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__2 === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__2.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__2) {
    __facade_register__2(middleware);
  }
  return class extends klass {
    #fetchDispatcher = (request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    };
    #dispatcher = (type6, init2) => {
      if (type6 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__2(
          Date.now(),
          init2.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request) {
      return __facade_invoke__2(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint2, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY2;
if (typeof middleware_insertion_facade_default2 === "object") {
  WRAPPED_ENTRY2 = wrapExportedHandler2(middleware_insertion_facade_default2);
} else if (typeof middleware_insertion_facade_default2 === "function") {
  WRAPPED_ENTRY2 = wrapWorkerEntrypoint2(middleware_insertion_facade_default2);
}
var middleware_loader_entry_default2 = WRAPPED_ENTRY2;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__2 as __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default2 as default
};
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/bls.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/tower.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/bls12-381.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/nist.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.edge.development.js:
  (**
   * @license React
   * react-dom-server.edge.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server-legacy.browser.development.js:
  (**
   * @license React
   * react-dom-server-legacy.browser.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=functionsWorker-0.05453709306899546.js.map
